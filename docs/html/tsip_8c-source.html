<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Procyon AVRlib: tsip.c Source File</title>
<link href="dox.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.2 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>tsip.c</h1><a href="tsip_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*! \file tsip.c \brief TSIP (Trimble Standard Interface Protocol) function library. */</span>
00002 <span class="comment">//*****************************************************************************</span>
00003 <span class="comment">//</span>
00004 <span class="comment">// File Name    : 'tsip.c'</span>
00005 <span class="comment">// Title        : TSIP (Trimble Standard Interface Protocol) function library</span>
00006 <span class="comment">// Author       : Pascal Stang - Copyright (C) 2002-2003</span>
00007 <span class="comment">// Created      : 2002.08.27</span>
00008 <span class="comment">// Revised      : 2003.07.17</span>
00009 <span class="comment">// Version      : 0.1</span>
00010 <span class="comment">// Target MCU   : Atmel AVR Series</span>
00011 <span class="comment">// Editor Tabs  : 4</span>
00012 <span class="comment">//</span>
00013 <span class="comment">// NOTE: This code is currently below version 1.0, and therefore is considered</span>
00014 <span class="comment">// to be lacking in some functionality or documentation, or may not be fully</span>
00015 <span class="comment">// tested.  Nonetheless, you can expect most functions to work.</span>
00016 <span class="comment">//</span>
00017 <span class="comment">// This code is distributed under the GNU Public License</span>
00018 <span class="comment">//      which can be found at http://www.gnu.org/licenses/gpl.txt</span>
00019 <span class="comment">//</span>
00020 <span class="comment">//*****************************************************************************</span>
00021 
00022 <span class="preprocessor">#ifndef WIN32</span>
00023 <span class="preprocessor"></span><span class="preprocessor">    #include &lt;avr/io.h&gt;</span>
00024 <span class="preprocessor">    #include &lt;avr/pgmspace.h&gt;</span>
00025 <span class="preprocessor">    #include &lt;math.h&gt;</span>
00026 <span class="preprocessor">    #include &lt;stdlib.h&gt;</span>
00027 <span class="preprocessor">#endif</span>
00028 <span class="preprocessor"></span>
00029 <span class="preprocessor">#include "<a class="code" href="global_8h.html">global.h</a>"</span>
00030 <span class="preprocessor">#include "<a class="code" href="buffer_8h.html">buffer.h</a>"</span>
00031 <span class="preprocessor">#include "<a class="code" href="rprintf_8h.html">rprintf.h</a>"</span>
00032 <span class="preprocessor">#include "<a class="code" href="uart2_8h.html">uart2.h</a>"</span>
00033 <span class="preprocessor">#include "<a class="code" href="gps_8h.html">gps.h</a>"</span>
00034 
00035 <span class="preprocessor">#include "<a class="code" href="tsip_8h.html">tsip.h</a>"</span>
00036 
00037 <span class="comment">// Program ROM constants</span>
00038 
00039 <span class="comment">// Global variables</span>
00040 <span class="keyword">extern</span> GpsInfoType GpsInfo;
00041 <span class="preprocessor">#define BUFFERSIZE 0x40</span>
00042 <span class="preprocessor"></span>u08 TsipPacket[BUFFERSIZE];
00043 u08 debug;
00044 
00045 <span class="comment">// function pointer to single byte output routine</span>
00046 <span class="keyword">static</span> void (*TsipTxByteFunc)(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> c);
00047 
00048 <span class="keywordtype">void</span> tsipInit(<span class="keywordtype">void</span> (*txbytefunc)(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> c))
00049 {
00050     <span class="comment">// set transmit function</span>
00051     <span class="comment">// (this function will be used for all SendPacket commands)</span>
00052     TsipTxByteFunc = txbytefunc;
00053 
00054     <span class="comment">// set debug status</span>
00055     debug = 0;
00056 
00057     <span class="comment">// compose GPS receiver configuration packet</span>
00058     u08 packet[4];
00059     packet[0] = BV(POS_LLA);
00060     packet[1] = BV(VEL_ENU);
00061     packet[2] = 0;
00062     packet[3] = 0;
00063     <span class="comment">// send configuration</span>
00064     tsipSendPacket(TSIPTYPE_SET_IO_OPTIONS, 4, packet);
00065 }
00066 
00067 <span class="keywordtype">void</span> tsipSendPacket(u08 tsipType, u08 dataLength, u08* data)
00068 {
00069     u08 i;
00070     u08 dataIdx = 0;
00071 
00072     <span class="comment">// start of packet</span>
00073     TsipPacket[dataIdx++] = DLE;
00074     <span class="comment">// packet type</span>
00075     TsipPacket[dataIdx++] = tsipType;
00076     <span class="comment">// add packet data</span>
00077     <span class="keywordflow">for</span>(i=0; i&lt;dataLength; i++)
00078     {
00079         <span class="keywordflow">if</span>(*data == DLE)
00080         {
00081             <span class="comment">// do double-DLE escape sequence</span>
00082             TsipPacket[dataIdx++] = *data;
00083             TsipPacket[dataIdx++] = *data++;
00084         }
00085         <span class="keywordflow">else</span>
00086             TsipPacket[dataIdx++] = *data++;
00087     }
00088     <span class="comment">// end of packet</span>
00089     TsipPacket[dataIdx++] = DLE;
00090     TsipPacket[dataIdx++] = ETX;
00091 
00092     <span class="keywordflow">for</span>(i=0; i&lt;dataIdx; i++)
00093         TsipTxByteFunc(TsipPacket[i]);
00094 }
00095 
00096 u08 tsipProcess(<a class="code" href="structstruct__cBuffer.html">cBuffer</a>* rxBuffer)
00097 {
00098     u08 foundpacket = FALSE;
00099     u08 startFlag = FALSE;
00100     u08 data;
00101     u08 i,j,k;
00102 
00103     u08 TsipPacketIdx;
00104     
00105     <span class="comment">// process the receive buffer</span>
00106     <span class="comment">// go through buffer looking for packets</span>
00107     <span class="keywordflow">while</span>(rxBuffer-&gt;<a class="code" href="structstruct__cBuffer.html#o2">datalength</a> &gt; 1)
00108     {
00109         <span class="comment">// look for a potential start of TSIP packet</span>
00110         <span class="keywordflow">if</span>(<a class="code" href="group__buffer.html#ga4">bufferGetAtIndex</a>(rxBuffer,0) == DLE)
00111         {
00112             <span class="comment">// make sure the next byte is not DLE or ETX</span>
00113             data = <a class="code" href="group__buffer.html#ga4">bufferGetAtIndex</a>(rxBuffer,1);
00114             <span class="keywordflow">if</span>((data != DLE) &amp;&amp; (data != ETX))
00115             {
00116                 <span class="comment">// found potential start</span>
00117                 startFlag = TRUE;
00118                 <span class="comment">// done looking for start</span>
00119                 <span class="keywordflow">break</span>;
00120             }
00121         }
00122         <span class="keywordflow">else</span>
00123             <span class="comment">// not DLE, dump character from buffer</span>
00124             <a class="code" href="group__buffer.html#ga2">bufferGetFromFront</a>(rxBuffer);
00125     }
00126     
00127     <span class="comment">// if we detected a start, look for end of packet</span>
00128     <span class="keywordflow">if</span>(startFlag)
00129     {
00130         <span class="keywordflow">for</span>(i=1; i&lt;(rxBuffer-&gt;<a class="code" href="structstruct__cBuffer.html#o2">datalength</a>)-1; i++)
00131         {
00132             <span class="comment">// check for potential end of TSIP packet</span>
00133             <span class="keywordflow">if</span>((<a class="code" href="group__buffer.html#ga4">bufferGetAtIndex</a>(rxBuffer,i) == DLE) &amp;&amp; (<a class="code" href="group__buffer.html#ga4">bufferGetAtIndex</a>(rxBuffer,i+1) == ETX))
00134             {
00135                 <span class="comment">// have a packet end</span>
00136                 <span class="comment">// dump initial DLE</span>
00137                 <a class="code" href="group__buffer.html#ga2">bufferGetFromFront</a>(rxBuffer);
00138                 <span class="comment">// copy data to TsipPacket</span>
00139                 TsipPacketIdx = 0;
00140                 <span class="keywordflow">for</span>(j=0; j&lt;(i-1); j++)
00141                 {
00142                     data = <a class="code" href="group__buffer.html#ga2">bufferGetFromFront</a>(rxBuffer);
00143                     <span class="keywordflow">if</span>(data == DLE)
00144                     {
00145                         <span class="keywordflow">if</span>(<a class="code" href="group__buffer.html#ga4">bufferGetAtIndex</a>(rxBuffer,0) == DLE)
00146                         {
00147                             <span class="comment">// found double-DLE escape sequence, skip one of them</span>
00148                             <a class="code" href="group__buffer.html#ga2">bufferGetFromFront</a>(rxBuffer);
00149                             j++;
00150                         }
00151                     }
00152                     TsipPacket[TsipPacketIdx++] = data;
00153                 }
00154                 <span class="comment">// dump ending DLE+ETX</span>
00155                 <a class="code" href="group__buffer.html#ga2">bufferGetFromFront</a>(rxBuffer);
00156                 <a class="code" href="group__buffer.html#ga2">bufferGetFromFront</a>(rxBuffer);
00157 
00158                 <span class="comment">// found a packet</span>
00159                 <span class="keywordflow">if</span>(debug)
00160                 {
00161                     rprintf(<span class="stringliteral">"Rx TSIP packet type: 0x%x  len: %d  rawlen: %d\r\n"</span>,
00162                         TsipPacket[0],
00163                         TsipPacketIdx,
00164                         i);
00165                     <span class="keywordflow">for</span>(k=0; k&lt;TsipPacketIdx; k++)
00166                     {
00167                         <a class="code" href="group__rprintf.html#ga7">rprintfu08</a>(TsipPacket[k]);
00168                         <a class="code" href="group__rprintf.html#ga1">rprintfChar</a>(<span class="charliteral">' '</span>);
00169                     }
00170                     <span class="comment">//rprintfu08(bufferGetFromFront(rxBuffer)); rprintfChar(' ');</span>
00171                     <span class="comment">//rprintfu08(bufferGetFromFront(rxBuffer)); rprintfChar(' ');</span>
00172 
00173                     <a class="code" href="group__rprintf.html#ga5">rprintfCRLF</a>();
00174                 }
00175                 <span class="comment">// done with this processing session</span>
00176                 foundpacket = TRUE;
00177                 <span class="keywordflow">break</span>;
00178             }
00179         }
00180     }
00181 
00182     <span class="keywordflow">if</span>(foundpacket)
00183     {
00184         <span class="comment">// switch on the packet type</span>
00185         <span class="keywordflow">switch</span>(TsipPacket[0])
00186         {
00187         <span class="keywordflow">case</span> TSIPTYPE_GPSTIME:          tsipProcessGPSTIME(TsipPacket); <span class="keywordflow">break</span>;
00188         <span class="keywordflow">case</span> TSIPTYPE_POSFIX_XYZ_SP:    tsipProcessPOSFIX_XYZ_SP(TsipPacket); <span class="keywordflow">break</span>;
00189         <span class="keywordflow">case</span> TSIPTYPE_VELFIX_XYZ:       tsipProcessVELFIX_XYZ(TsipPacket); <span class="keywordflow">break</span>;
00190 
00191         <span class="keywordflow">case</span> TSIPTYPE_POSFIX_LLA_SP:    tsipProcessPOSFIX_LLA_SP(TsipPacket); <span class="keywordflow">break</span>;
00192         <span class="keywordflow">case</span> TSIPTYPE_VELFIX_ENU:       tsipProcessVELFIX_ENU(TsipPacket); <span class="keywordflow">break</span>;
00193 
00194         <span class="keywordflow">case</span> TSIPTYPE_RAWDATA: <span class="keywordflow">break</span>;
00195         <span class="keywordflow">default</span>:
00196             <span class="comment">//if(debug) rprintf("Unhandled TSIP packet type: 0x%x\r\n",TsipPacket[0]);</span>
00197             <span class="keywordflow">break</span>;
00198         }
00199     }
00200 
00201     <span class="keywordflow">return</span> foundpacket;
00202 }
00203 
00204 <span class="keywordtype">void</span> tsipProcessGPSTIME(u08* packet)
00205 {
00206     <span class="comment">// NOTE: check endian-ness if porting to processors other than the AVR</span>
00207     GpsInfo.TimeOfWeek.b[3] = packet[1];
00208     GpsInfo.TimeOfWeek.b[2] = packet[2];
00209     GpsInfo.TimeOfWeek.b[1] = packet[3];
00210     GpsInfo.TimeOfWeek.b[0] = packet[4];
00211 
00212     GpsInfo.WeekNum = ((u16)packet[5]&lt;&lt;8)|((u16)packet[6]);
00213 
00214     GpsInfo.UtcOffset.b[3]  = packet[7];
00215     GpsInfo.UtcOffset.b[2]  = packet[8];
00216     GpsInfo.UtcOffset.b[1]  = packet[9];
00217     GpsInfo.UtcOffset.b[0]  = packet[10];
00218 }
00219 
00220 <span class="keywordtype">void</span> tsipProcessPOSFIX_XYZ_SP(u08* packet)
00221 {
00222     <span class="comment">// NOTE: check endian-ness if porting to processors other than the AVR</span>
00223     GpsInfo.PosECEF.x.b[3] = packet[1];
00224     GpsInfo.PosECEF.x.b[2] = packet[2];
00225     GpsInfo.PosECEF.x.b[1] = packet[3];
00226     GpsInfo.PosECEF.x.b[0] = packet[4];
00227 
00228     GpsInfo.PosECEF.y.b[3] = packet[5];
00229     GpsInfo.PosECEF.y.b[2] = packet[6];
00230     GpsInfo.PosECEF.y.b[1] = packet[7];
00231     GpsInfo.PosECEF.y.b[0] = packet[8];
00232 
00233     GpsInfo.PosECEF.z.b[3] = packet[9];
00234     GpsInfo.PosECEF.z.b[2] = packet[10];
00235     GpsInfo.PosECEF.z.b[1] = packet[11];
00236     GpsInfo.PosECEF.z.b[0] = packet[12];
00237 
00238     GpsInfo.PosECEF.TimeOfFix.b[3] = packet[13];
00239     GpsInfo.PosECEF.TimeOfFix.b[2] = packet[14];
00240     GpsInfo.PosECEF.TimeOfFix.b[1] = packet[15];
00241     GpsInfo.PosECEF.TimeOfFix.b[0] = packet[16];
00242 
00243     GpsInfo.PosECEF.updates++;
00244 
00245 <span class="comment">//  GpsInfo.TimeOfFix_ECEF.f = *((float*)&amp;packet[13]);</span>
00246 }
00247 
00248 <span class="keywordtype">void</span> tsipProcessVELFIX_XYZ(u08* packet)
00249 {
00250 }
00251 
00252 <span class="keywordtype">void</span> tsipProcessPOSFIX_LLA_SP(u08* packet)
00253 {
00254     <span class="comment">// NOTE: check endian-ness if porting to processors other than the AVR</span>
00255     GpsInfo.PosLLA.lat.b[3] = packet[1];
00256     GpsInfo.PosLLA.lat.b[2] = packet[2];
00257     GpsInfo.PosLLA.lat.b[1] = packet[3];
00258     GpsInfo.PosLLA.lat.b[0] = packet[4];
00259 
00260     GpsInfo.PosLLA.lon.b[3] = packet[5];
00261     GpsInfo.PosLLA.lon.b[2] = packet[6];
00262     GpsInfo.PosLLA.lon.b[1] = packet[7];
00263     GpsInfo.PosLLA.lon.b[0] = packet[8];
00264 
00265     GpsInfo.PosLLA.alt.b[3] = packet[9];
00266     GpsInfo.PosLLA.alt.b[2] = packet[10];
00267     GpsInfo.PosLLA.alt.b[1] = packet[11];
00268     GpsInfo.PosLLA.alt.b[0] = packet[12];
00269 
00270     GpsInfo.PosLLA.TimeOfFix.b[3] = packet[17];
00271     GpsInfo.PosLLA.TimeOfFix.b[2] = packet[18];
00272     GpsInfo.PosLLA.TimeOfFix.b[1] = packet[18];
00273     GpsInfo.PosLLA.TimeOfFix.b[0] = packet[20];
00274 
00275     GpsInfo.PosLLA.updates++;
00276 }
00277 
00278 <span class="keywordtype">void</span> tsipProcessVELFIX_ENU(u08* packet)
00279 {
00280     <span class="comment">// NOTE: check endian-ness if porting to processors other than the AVR</span>
00281     GpsInfo.VelENU.east.b[3] = packet[1];
00282     GpsInfo.VelENU.east.b[2] = packet[2];
00283     GpsInfo.VelENU.east.b[1] = packet[3];
00284     GpsInfo.VelENU.east.b[0] = packet[4];
00285 
00286     GpsInfo.VelENU.north.b[3] = packet[5];
00287     GpsInfo.VelENU.north.b[2] = packet[6];
00288     GpsInfo.VelENU.north.b[1] = packet[7];
00289     GpsInfo.VelENU.north.b[0] = packet[8];
00290 
00291     GpsInfo.VelENU.up.b[3] =    packet[9];
00292     GpsInfo.VelENU.up.b[2] =    packet[10];
00293     GpsInfo.VelENU.up.b[1] =    packet[11];
00294     GpsInfo.VelENU.up.b[0] =    packet[12];
00295 
00296     GpsInfo.VelENU.TimeOfFix.b[3] = packet[17];
00297     GpsInfo.VelENU.TimeOfFix.b[2] = packet[18];
00298     GpsInfo.VelENU.TimeOfFix.b[1] = packet[19];
00299     GpsInfo.VelENU.TimeOfFix.b[0] = packet[20];
00300 
00301     GpsInfo.VelENU.updates++;
00302 }
00303 
00304 <span class="keywordtype">void</span> tsipProcessRAWDATA(<a class="code" href="structstruct__cBuffer.html">cBuffer</a>* packet)
00305 {
00306 <span class="comment">/*</span>
00307 <span class="comment">    char oft = 1;</span>
00308 <span class="comment">    // process the data in TSIPdata</span>
00309 <span class="comment">    unsigned char SVnum = TSIPdata[oft];</span>
00310 <span class="comment">    unsigned __int32 SNR32 =        (TSIPdata[oft+5] &lt;&lt; 24) + (TSIPdata[oft+6] &lt;&lt; 16) + (TSIPdata[oft+7] &lt;&lt; 8) + (TSIPdata[oft+8]);</span>
00311 <span class="comment">    unsigned __int32 codephase32 =  (TSIPdata[oft+9] &lt;&lt; 24) + (TSIPdata[oft+10] &lt;&lt; 16) + (TSIPdata[oft+11] &lt;&lt; 8) + (TSIPdata[oft+12]);</span>
00312 <span class="comment">    unsigned __int32 doppler32 =    (TSIPdata[oft+13] &lt;&lt; 24) + (TSIPdata[oft+14] &lt;&lt; 16) + (TSIPdata[oft+15] &lt;&lt; 8) + (TSIPdata[oft+16]);</span>
00313 <span class="comment">    </span>
00314 <span class="comment">    unsigned __int64 meastimeH32 =  (TSIPdata[oft+17] &lt;&lt; 24) | (TSIPdata[oft+18] &lt;&lt; 16) | (TSIPdata[oft+19] &lt;&lt; 8) | (TSIPdata[oft+20]);</span>
00315 <span class="comment">    unsigned __int64 meastimeL32 =  (TSIPdata[oft+21] &lt;&lt; 24) | (TSIPdata[oft+22] &lt;&lt; 16) | (TSIPdata[oft+23] &lt;&lt; 8) | (TSIPdata[oft+24]);</span>
00316 <span class="comment">    unsigned __int64 meastime64 =   (meastimeH32 &lt;&lt; 32) | (meastimeL32);</span>
00317 <span class="comment">    </span>
00318 <span class="comment">    float SNR =         *((float*) &amp;SNR32);</span>
00319 <span class="comment">    float codephase =   *((float*) &amp;codephase32);</span>
00320 <span class="comment">    float doppler =     *((float*) &amp;doppler32);</span>
00321 <span class="comment">    double meastime =   *((double*) &amp;meastime64);</span>
00322 <span class="comment">    </span>
00323 <span class="comment">    // output to screen</span>
00324 <span class="comment">    printf("SV%2d SNR: %5.2f PH: %11.4f DOP: %11.4f TIME: %5.0I64f EPOCH: %7.2I64f\n",SVnum,SNR,codephase,doppler,meastime,meastime/1.5);</span>
00325 <span class="comment">    //printf("SV%2d  SNR: %5.2f  PH: %10.4f  DOP: %10.4f  TIME: %I64x\n",SVnum,SNR,codephase,doppler,meastime64);</span>
00326 <span class="comment"></span>
00327 <span class="comment">    // output to file</span>
00328 <span class="comment">    fprintf( logfile, "%2d  %5.2f  %11.4f  %11.4f  %5.0I64f  %7.2I64f\n",SVnum,SNR,codephase,doppler,meastime,meastime/1.5);</span>
00329 <span class="comment">*/</span>
00330 }
00331 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Sun Oct 29 03:41:07 2006 for Procyon AVRlib by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.2 </small></address>
</body>
</html>
