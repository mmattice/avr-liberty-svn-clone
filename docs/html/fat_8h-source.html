<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Procyon AVRlib: fat.h Source File</title>
<link href="dox.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.2 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>fat.h</h1><a href="fat_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*! \file fat.h \brief FAT16/32 file system driver. */</span>
00002 <span class="comment">//*****************************************************************************</span>
00003 <span class="comment">//</span>
00004 <span class="comment">// File Name    : 'fat.h'</span>
00005 <span class="comment">// Title        : FAT16/32 file system driver</span>
00006 <span class="comment">// Author       : Pascal Stang</span>
00007 <span class="comment">// Date         : 11/07/2000</span>
00008 <span class="comment">// Revised      : 12/12/2000</span>
00009 <span class="comment">// Version      : 0.3</span>
00010 <span class="comment">// Target MCU   : ATmega103 (should work for Atmel AVR Series)</span>
00011 <span class="comment">// Editor Tabs  : 4</span>
00012 <span class="comment">//</span>
00013 <span class="comment">// NOTE: This code is currently below version 1.0, and therefore is considered</span>
00014 <span class="comment">// to be lacking in some functionality or documentation, or may not be fully</span>
00015 <span class="comment">// tested.  Nonetheless, you can expect most functions to work.</span>
00016 <span class="comment">//</span><span class="comment"></span>
00017 <span class="comment">/// \ingroup general</span>
00018 <span class="comment">/// \defgroup fat FAT16/32 File System Interface (fat.c)</span>
00019 <span class="comment">/// \code #include "fat.h" \endcode</span>
00020 <span class="comment">/// \par Overview</span>
00021 <span class="comment">///     This FAT16/32 interface allows you to detect and mount FAT16/32</span>
00022 <span class="comment">///     partitions, browse directories and files, and read file data.</span>
00023 <span class="comment">///     The interface is designed to operate with the avrlib IDE/ATA driver.</span>
00024 <span class="comment">///     Reading FAT efficiently requires at least 512+ bytes of RAM so this</span>
00025 <span class="comment">///     interface may not be suitable for processors with less than 1K of RAM.</span>
00026 <span class="comment">///     This interface will properly follow a file's cluster chain so files</span>
00027 <span class="comment">///     need not be defragmented.</span>
00028 <span class="comment">///</span>
00029 <span class="comment">/// \note This code is based in part on work done by Jesper Hansen for his</span>
00030 <span class="comment">///     excellent YAMPP MP3 player project.</span>
00031 <span class="comment"></span><span class="comment">//</span>
00032 <span class="comment">// This code is distributed under the GNU Public License</span>
00033 <span class="comment">//      which can be found at http://www.gnu.org/licenses/gpl.txt</span>
00034 <span class="comment">//</span>
00035 <span class="comment">//*****************************************************************************</span>
00036 
00037 <span class="preprocessor">#ifndef FAT_H</span>
00038 <span class="preprocessor"></span><span class="preprocessor">#define FAT_H</span>
00039 <span class="preprocessor"></span>
00040 <span class="preprocessor">#include "<a class="code" href="global_8h.html">global.h</a>"</span>
00041 
00042 
00043 <span class="comment">// Some useful cluster numbers</span>
00044 <span class="preprocessor">#define MSDOSFSROOT     0               // cluster 0 means the root dir</span>
00045 <span class="preprocessor"></span><span class="preprocessor">#define CLUST_FREE      0               // cluster 0 also means a free cluster</span>
00046 <span class="preprocessor"></span><span class="preprocessor">#define MSDOSFSFREE     CLUST_FREE</span>
00047 <span class="preprocessor"></span><span class="preprocessor">#define CLUST_FIRST     2               // first legal cluster number</span>
00048 <span class="preprocessor"></span><span class="preprocessor">#define CLUST_RSRVD     0xfffffff6      // reserved cluster range</span>
00049 <span class="preprocessor"></span><span class="preprocessor">#define CLUST_BAD       0xfffffff7      // a cluster with a defect</span>
00050 <span class="preprocessor"></span><span class="preprocessor">#define CLUST_EOFS      0xfffffff8      // start of eof cluster range</span>
00051 <span class="preprocessor"></span><span class="preprocessor">#define CLUST_EOFE      0xffffffff      // end of eof cluster range</span>
00052 <span class="preprocessor"></span>
00053 <span class="preprocessor">#define FAT12_MASK      0x00000fff      // mask for 12 bit cluster numbers</span>
00054 <span class="preprocessor"></span><span class="preprocessor">#define FAT16_MASK      0x0000ffff      // mask for 16 bit cluster numbers</span>
00055 <span class="preprocessor"></span><span class="preprocessor">#define FAT32_MASK      0x0fffffff      // mask for FAT32 cluster numbers</span>
00056 <span class="preprocessor"></span>
00057 
00058 <span class="comment">// Partition Type used in the partition record</span>
00059 <span class="preprocessor">#define PART_TYPE_UNKNOWN       0x00</span>
00060 <span class="preprocessor"></span><span class="preprocessor">#define PART_TYPE_FAT12         0x01</span>
00061 <span class="preprocessor"></span><span class="preprocessor">#define PART_TYPE_XENIX         0x02</span>
00062 <span class="preprocessor"></span><span class="preprocessor">#define PART_TYPE_DOSFAT16      0x04</span>
00063 <span class="preprocessor"></span><span class="preprocessor">#define PART_TYPE_EXTDOS        0x05</span>
00064 <span class="preprocessor"></span><span class="preprocessor">#define PART_TYPE_FAT16         0x06</span>
00065 <span class="preprocessor"></span><span class="preprocessor">#define PART_TYPE_NTFS          0x07</span>
00066 <span class="preprocessor"></span><span class="preprocessor">#define PART_TYPE_FAT32         0x0B</span>
00067 <span class="preprocessor"></span><span class="preprocessor">#define PART_TYPE_FAT32LBA      0x0C</span>
00068 <span class="preprocessor"></span><span class="preprocessor">#define PART_TYPE_FAT16LBA      0x0E</span>
00069 <span class="preprocessor"></span><span class="preprocessor">#define PART_TYPE_EXTDOSLBA     0x0F</span>
00070 <span class="preprocessor"></span><span class="preprocessor">#define PART_TYPE_ONTRACK       0x33</span>
00071 <span class="preprocessor"></span><span class="preprocessor">#define PART_TYPE_NOVELL        0x40</span>
00072 <span class="preprocessor"></span><span class="preprocessor">#define PART_TYPE_PCIX          0x4B</span>
00073 <span class="preprocessor"></span><span class="preprocessor">#define PART_TYPE_PHOENIXSAVE   0xA0</span>
00074 <span class="preprocessor"></span><span class="preprocessor">#define PART_TYPE_CPM           0xDB</span>
00075 <span class="preprocessor"></span><span class="preprocessor">#define PART_TYPE_DBFS          0xE0</span>
00076 <span class="preprocessor"></span><span class="preprocessor">#define PART_TYPE_BBT           0xFF</span>
00077 <span class="preprocessor"></span>
00078 <span class="keyword">struct </span>partrecord <span class="comment">// length 16 bytes</span>
00079 {           
00080     BYTE    prIsActive;                 <span class="comment">// 0x80 indicates active partition</span>
00081     BYTE    prStartHead;                <span class="comment">// starting head for partition</span>
00082     WORD    prStartCylSect;             <span class="comment">// starting cylinder and sector</span>
00083     BYTE    prPartType;                 <span class="comment">// partition type (see above)</span>
00084     BYTE    prEndHead;                  <span class="comment">// ending head for this partition</span>
00085     WORD    prEndCylSect;               <span class="comment">// ending cylinder and sector</span>
00086     DWORD   prStartLBA;                 <span class="comment">// first LBA sector for this partition</span>
00087     DWORD   prSize;                     <span class="comment">// size of this partition (bytes or sectors ?)</span>
00088 };
00089 
00090         
00091 <span class="keyword">struct </span>partsector
00092 {
00093     CHAR    psPartCode[512-64-2];       <span class="comment">// pad so struct is 512b</span>
00094     BYTE    psPart[64];                 <span class="comment">// four partition records (64 bytes)</span>
00095     BYTE    psBootSectSig0;             <span class="comment">// two signature bytes (2 bytes)</span>
00096     BYTE    psBootSectSig1;
00097 <span class="preprocessor">#define BOOTSIG0        0x55</span>
00098 <span class="preprocessor"></span><span class="preprocessor">#define BOOTSIG1        0xaa</span>
00099 <span class="preprocessor"></span>};
00100 
00101 
00102 
00103 <span class="comment">// Format of a boot sector.  This is the first sector on a DOS floppy disk</span>
00104 <span class="comment">// or the first sector of a partition on a hard disk.  But, it is not the</span>
00105 <span class="comment">// first sector of a partitioned hard disk.</span>
00106 <span class="keyword">struct </span>bootsector33 {
00107     BYTE    bsJump[3];                  <span class="comment">// jump inst E9xxxx or EBxx90</span>
00108     CHAR    bsOemName[8];               <span class="comment">// OEM name and version</span>
00109     CHAR    bsBPB[19];                  <span class="comment">// BIOS parameter block</span>
00110     CHAR    bsDriveNumber;              <span class="comment">// drive number (0x80)</span>
00111     CHAR    bsBootCode[479];            <span class="comment">// pad so struct is 512b</span>
00112     BYTE    bsBootSectSig0;             <span class="comment">// boot sector signature byte 0x55</span>
00113     BYTE    bsBootSectSig1;             <span class="comment">// boot sector signature byte 0xAA</span>
00114 <span class="preprocessor">#define BOOTSIG0        0x55</span>
00115 <span class="preprocessor"></span><span class="preprocessor">#define BOOTSIG1        0xaa</span>
00116 <span class="preprocessor"></span>};
00117 
00118 <span class="keyword">struct </span>extboot {
00119     CHAR    exDriveNumber;              <span class="comment">// drive number (0x80)</span>
00120     CHAR    exReserved1;                <span class="comment">// reserved</span>
00121     CHAR    exBootSignature;            <span class="comment">// ext. boot signature (0x29)</span>
00122 <span class="preprocessor">#define EXBOOTSIG       0x29</span>
00123 <span class="preprocessor"></span>    CHAR    exVolumeID[4];              <span class="comment">// volume ID number</span>
00124     CHAR    exVolumeLabel[11];          <span class="comment">// volume label</span>
00125     CHAR    exFileSysType[8];           <span class="comment">// fs type (FAT12 or FAT16)</span>
00126 };
00127 
00128 <span class="keyword">struct </span>bootsector50 {
00129     BYTE    bsJump[3];                  <span class="comment">// jump inst E9xxxx or EBxx90</span>
00130     CHAR    bsOemName[8];               <span class="comment">// OEM name and version</span>
00131     CHAR    bsBPB[25];                  <span class="comment">// BIOS parameter block</span>
00132     CHAR    bsExt[26];                  <span class="comment">// Bootsector Extension</span>
00133     CHAR    bsBootCode[448];            <span class="comment">// pad so structure is 512b</span>
00134     BYTE    bsBootSectSig0;             <span class="comment">// boot sector signature byte 0x55 </span>
00135     BYTE    bsBootSectSig1;             <span class="comment">// boot sector signature byte 0xAA</span>
00136 <span class="preprocessor">#define BOOTSIG0        0x55</span>
00137 <span class="preprocessor"></span><span class="preprocessor">#define BOOTSIG1        0xaa</span>
00138 <span class="preprocessor"></span>};
00139 
00140 <span class="keyword">struct </span>bootsector710 {
00141     BYTE    bsJump[3];                  <span class="comment">// jump inst E9xxxx or EBxx90</span>
00142     CHAR    bsOEMName[8];               <span class="comment">// OEM name and version</span>
00143     CHAR    bsBPB[53];                  <span class="comment">// BIOS parameter block</span>
00144     CHAR    bsExt[26];                  <span class="comment">// Bootsector Extension</span>
00145     CHAR    bsBootCode[418];            <span class="comment">// pad so structure is 512b</span>
00146     BYTE    bsBootSectSig2;             <span class="comment">// 2 &amp; 3 are only defined for FAT32?</span>
00147     BYTE    bsBootSectSig3;
00148     BYTE    bsBootSectSig0;             <span class="comment">// boot sector signature byte 0x55</span>
00149     BYTE    bsBootSectSig1;             <span class="comment">// boot sector signature byte 0xAA</span>
00150 <span class="preprocessor">#define BOOTSIG0        0x55</span>
00151 <span class="preprocessor"></span><span class="preprocessor">#define BOOTSIG1        0xaa</span>
00152 <span class="preprocessor"></span><span class="preprocessor">#define BOOTSIG2        0</span>
00153 <span class="preprocessor"></span><span class="preprocessor">#define BOOTSIG3        0</span>
00154 <span class="preprocessor"></span>};
00155 
00156 
00157 <span class="comment">/***************************************************************/</span>
00158 <span class="comment">/***************************************************************/</span>
00159 
00160 <span class="comment">// BIOS Parameter Block (BPB) for DOS 3.3</span>
00161 <span class="keyword">struct </span>bpb33 {
00162         WORD    bpbBytesPerSec; <span class="comment">// bytes per sector</span>
00163         BYTE    bpbSecPerClust; <span class="comment">// sectors per cluster</span>
00164         WORD    bpbResSectors;  <span class="comment">// number of reserved sectors</span>
00165         BYTE    bpbFATs;        <span class="comment">// number of FATs</span>
00166         WORD    bpbRootDirEnts; <span class="comment">// number of root directory entries</span>
00167         WORD    bpbSectors;     <span class="comment">// total number of sectors</span>
00168         BYTE    bpbMedia;       <span class="comment">// media descriptor</span>
00169         WORD    bpbFATsecs;     <span class="comment">// number of sectors per FAT</span>
00170         WORD    bpbSecPerTrack; <span class="comment">// sectors per track</span>
00171         WORD    bpbHeads;       <span class="comment">// number of heads</span>
00172         WORD    bpbHiddenSecs;  <span class="comment">// number of hidden sectors</span>
00173 };
00174 
00175 <span class="comment">// BPB for DOS 5.0</span>
00176 <span class="comment">// The difference is bpbHiddenSecs is a short for DOS 3.3,</span>
00177 <span class="comment">// and bpbHugeSectors is not present in the DOS 3.3 bpb.</span>
00178 <span class="keyword">struct </span>bpb50 {
00179         WORD    bpbBytesPerSec; <span class="comment">// bytes per sector</span>
00180         BYTE    bpbSecPerClust; <span class="comment">// sectors per cluster</span>
00181         WORD    bpbResSectors;  <span class="comment">// number of reserved sectors</span>
00182         BYTE    bpbFATs;        <span class="comment">// number of FATs</span>
00183         WORD    bpbRootDirEnts; <span class="comment">// number of root directory entries</span>
00184         WORD    bpbSectors;     <span class="comment">// total number of sectors</span>
00185         BYTE    bpbMedia;       <span class="comment">// media descriptor</span>
00186         WORD    bpbFATsecs;     <span class="comment">// number of sectors per FAT</span>
00187         WORD    bpbSecPerTrack; <span class="comment">// sectors per track</span>
00188         WORD    bpbHeads;       <span class="comment">// number of heads</span>
00189         DWORD   bpbHiddenSecs;  <span class="comment">// # of hidden sectors</span>
00190 <span class="comment">// 3.3 compat ends here</span>
00191         DWORD   bpbHugeSectors; <span class="comment">// # of sectors if bpbSectors == 0</span>
00192 };
00193 
00194 <span class="comment">// BPB for DOS 7.10 (FAT32)</span>
00195 <span class="comment">// This one has a few extensions to bpb50.</span>
00196 <span class="keyword">struct </span>bpb710 {
00197         WORD    bpbBytesPerSec; <span class="comment">// bytes per sector</span>
00198         BYTE    bpbSecPerClust; <span class="comment">// sectors per cluster</span>
00199         WORD    bpbResSectors;  <span class="comment">// number of reserved sectors</span>
00200         BYTE    bpbFATs;        <span class="comment">// number of FATs</span>
00201         WORD    bpbRootDirEnts; <span class="comment">// number of root directory entries</span>
00202         WORD    bpbSectors;     <span class="comment">// total number of sectors</span>
00203         BYTE    bpbMedia;       <span class="comment">// media descriptor</span>
00204         WORD    bpbFATsecs;     <span class="comment">// number of sectors per FAT</span>
00205         WORD    bpbSecPerTrack; <span class="comment">// sectors per track</span>
00206         WORD    bpbHeads;       <span class="comment">// number of heads</span>
00207         DWORD   bpbHiddenSecs;  <span class="comment">// # of hidden sectors</span>
00208 <span class="comment">// 3.3 compat ends here</span>
00209         DWORD   bpbHugeSectors; <span class="comment">// # of sectors if bpbSectors == 0</span>
00210 <span class="comment">// 5.0 compat ends here</span>
00211         DWORD     bpbBigFATsecs;<span class="comment">// like bpbFATsecs for FAT32</span>
00212         WORD      bpbExtFlags;  <span class="comment">// extended flags:</span>
00213 <span class="preprocessor">#define FATNUM    0xf           // mask for numbering active FAT</span>
00214 <span class="preprocessor"></span><span class="preprocessor">#define FATMIRROR 0x80          // FAT is mirrored (like it always was)</span>
00215 <span class="preprocessor"></span>        WORD      bpbFSVers;    <span class="comment">// filesystem version</span>
00216 <span class="preprocessor">#define FSVERS    0             // currently only 0 is understood</span>
00217 <span class="preprocessor"></span>        DWORD     bpbRootClust; <span class="comment">// start cluster for root directory</span>
00218         WORD      bpbFSInfo;    <span class="comment">// filesystem info structure sector</span>
00219         WORD      bpbBackup;    <span class="comment">// backup boot sector</span>
00220         <span class="comment">// There is a 12 byte filler here, but we ignore it</span>
00221 };
00222 
00223 
00224 
00225 
00226 <span class="comment">// ***************************************************************</span>
00227 <span class="comment">// * byte versions of the above structs                          *</span>
00228 <span class="comment">// ***************************************************************</span>
00229 
00230 
00231 <span class="comment">// BIOS Parameter Block (BPB) for DOS 3.3</span>
00232 <span class="keyword">struct </span>byte_bpb33 {
00233         CHAR bpbBytesPerSec[2];     <span class="comment">// bytes per sector</span>
00234         CHAR bpbSecPerClust;        <span class="comment">// sectors per cluster</span>
00235         CHAR bpbResSectors[2];      <span class="comment">// number of reserved sectors</span>
00236         CHAR bpbFATs;               <span class="comment">// number of FATs</span>
00237         CHAR bpbRootDirEnts[2];     <span class="comment">// number of root directory entries</span>
00238         CHAR bpbSectors[2];         <span class="comment">// total number of sectors</span>
00239         CHAR bpbMedia;              <span class="comment">// media descriptor</span>
00240         CHAR bpbFATsecs[2];         <span class="comment">// number of sectors per FAT</span>
00241         CHAR bpbSecPerTrack[2];     <span class="comment">// sectors per track</span>
00242         CHAR bpbHeads[2];           <span class="comment">// number of heads</span>
00243         CHAR bpbHiddenSecs[2];      <span class="comment">// number of hidden sectors</span>
00244 };
00245 
00246 <span class="comment">// BPB for DOS 5.0</span>
00247 <span class="comment">// The difference is bpbHiddenSecs is a short for DOS 3.3,</span>
00248 <span class="comment">// and bpbHugeSectors is not in the 3.3 bpb.</span>
00249 <span class="keyword">struct </span>byte_bpb50 {
00250         CHAR bpbBytesPerSec[2];     <span class="comment">// bytes per sector</span>
00251         CHAR bpbSecPerClust;        <span class="comment">// sectors per cluster</span>
00252         CHAR bpbResSectors[2];      <span class="comment">// number of reserved sectors</span>
00253         CHAR bpbFATs;               <span class="comment">// number of FATs</span>
00254         CHAR bpbRootDirEnts[2];     <span class="comment">// number of root directory entries</span>
00255         CHAR bpbSectors[2];         <span class="comment">// total number of sectors</span>
00256         CHAR bpbMedia;              <span class="comment">// media descriptor</span>
00257         CHAR bpbFATsecs[2];         <span class="comment">// number of sectors per FAT</span>
00258         CHAR bpbSecPerTrack[2];     <span class="comment">// sectors per track</span>
00259         CHAR bpbHeads[2];           <span class="comment">// number of heads</span>
00260         CHAR bpbHiddenSecs[4];      <span class="comment">// number of hidden sectors</span>
00261         CHAR bpbHugeSectors[4];     <span class="comment">// # of sectors if bpbSectors == 0</span>
00262 };
00263 
00264 <span class="comment">// BPB for DOS 7.10 (FAT32).</span>
00265 <span class="comment">// This one has a few extensions to bpb50.</span>
00266 <span class="keyword">struct </span>byte_bpb710 {
00267         BYTE bpbBytesPerSec[2];     <span class="comment">// bytes per sector</span>
00268         BYTE bpbSecPerClust;        <span class="comment">// sectors per cluster</span>
00269         BYTE bpbResSectors[2];      <span class="comment">// number of reserved sectors</span>
00270         BYTE bpbFATs;               <span class="comment">// number of FATs</span>
00271         BYTE bpbRootDirEnts[2];     <span class="comment">// number of root directory entries</span>
00272         BYTE bpbSectors[2];         <span class="comment">// total number of sectors</span>
00273         BYTE bpbMedia;              <span class="comment">// media descriptor</span>
00274         BYTE bpbFATsecs[2];         <span class="comment">// number of sectors per FAT</span>
00275         BYTE bpbSecPerTrack[2];     <span class="comment">// sectors per track</span>
00276         BYTE bpbHeads[2];           <span class="comment">// number of heads</span>
00277         BYTE bpbHiddenSecs[4];      <span class="comment">// # of hidden sectors</span>
00278         BYTE bpbHugeSectors[4];     <span class="comment">// # of sectors if bpbSectors == 0</span>
00279         BYTE bpbBigFATsecs[4];      <span class="comment">// like bpbFATsecs for FAT32</span>
00280         BYTE bpbExtFlags[2];        <span class="comment">// extended flags:</span>
00281         BYTE bpbFSVers[2];          <span class="comment">// filesystem version</span>
00282         BYTE bpbRootClust[4];       <span class="comment">// start cluster for root directory</span>
00283         BYTE bpbFSInfo[2];          <span class="comment">// filesystem info structure sector</span>
00284         BYTE bpbBackup[2];          <span class="comment">// backup boot sector</span>
00285         <span class="comment">// There is a 12 byte filler here, but we ignore it</span>
00286 };
00287 
00288 <span class="comment">// FAT32 FSInfo block.</span>
00289 <span class="keyword">struct </span>fsinfo {
00290         BYTE fsisig1[4];
00291         BYTE fsifill1[480];
00292         BYTE fsisig2[4];
00293         BYTE fsinfree[4];
00294         BYTE fsinxtfree[4];
00295         BYTE fsifill2[12];
00296         BYTE fsisig3[4];
00297         BYTE fsifill3[508];
00298         BYTE fsisig4[4];
00299 };
00300 
00301 
00302 <span class="comment">/***************************************************************/</span>
00303 <span class="comment">/***************************************************************/</span>
00304 
00305 
00306 <span class="comment">// Structure of a dos directory entry.</span>
00307 <span class="keyword">struct </span>direntry {
00308         BYTE        deName[8];      <span class="comment">// filename, blank filled</span>
00309 <span class="preprocessor">#define SLOT_EMPTY      0x00            // slot has never been used</span>
00310 <span class="preprocessor"></span><span class="preprocessor">#define SLOT_E5         0x05            // the real value is 0xE5</span>
00311 <span class="preprocessor"></span><span class="preprocessor">#define SLOT_DELETED    0xE5            // file in this slot deleted</span>
00312 <span class="preprocessor"></span>        BYTE        deExtension[3]; <span class="comment">// extension, blank filled</span>
00313         BYTE        deAttributes;   <span class="comment">// file attributes</span>
00314 <span class="preprocessor">#define ATTR_NORMAL     0x00            // normal file</span>
00315 <span class="preprocessor"></span><span class="preprocessor">#define ATTR_READONLY   0x01            // file is readonly</span>
00316 <span class="preprocessor"></span><span class="preprocessor">#define ATTR_HIDDEN     0x02            // file is hidden</span>
00317 <span class="preprocessor"></span><span class="preprocessor">#define ATTR_SYSTEM     0x04            // file is a system file</span>
00318 <span class="preprocessor"></span><span class="preprocessor">#define ATTR_VOLUME     0x08            // entry is a volume label</span>
00319 <span class="preprocessor"></span><span class="preprocessor">#define ATTR_LONG_FILENAME  0x0F        // this is a long filename entry                </span>
00320 <span class="preprocessor"></span><span class="preprocessor">#define ATTR_DIRECTORY  0x10            // entry is a directory name</span>
00321 <span class="preprocessor"></span><span class="preprocessor">#define ATTR_ARCHIVE    0x20            // file is new or modified</span>
00322 <span class="preprocessor"></span>        BYTE        deLowerCase;    <span class="comment">// NT VFAT lower case flags  (set to zero)</span>
00323 <span class="preprocessor">#define LCASE_BASE      0x08            // filename base in lower case</span>
00324 <span class="preprocessor"></span><span class="preprocessor">#define LCASE_EXT       0x10            // filename extension in lower case</span>
00325 <span class="preprocessor"></span>        BYTE        deCHundredth;   <span class="comment">// hundredth of seconds in CTime</span>
00326         BYTE        deCTime[2];     <span class="comment">// create time</span>
00327         BYTE        deCDate[2];     <span class="comment">// create date</span>
00328         BYTE        deADate[2];     <span class="comment">// access date</span>
00329         WORD        deHighClust;    <span class="comment">// high bytes of cluster number</span>
00330         BYTE        deMTime[2];     <span class="comment">// last update time</span>
00331         BYTE        deMDate[2];     <span class="comment">// last update date</span>
00332         WORD        deStartCluster; <span class="comment">// starting cluster of file</span>
00333         DWORD       deFileSize;     <span class="comment">// size of file in bytes</span>
00334 };
00335 
00336 <span class="comment">// number of directory entries in one sector</span>
00337 <span class="preprocessor">#define DIRENTRIES_PER_SECTOR   0x10</span>
00338 <span class="preprocessor"></span>
00339 <span class="comment">// Structure of a Win95 long name directory entry</span>
00340 <span class="keyword">struct </span>winentry {
00341         BYTE        weCnt;          <span class="comment">// </span>
00342 <span class="preprocessor">#define WIN_LAST        0x40</span>
00343 <span class="preprocessor"></span><span class="preprocessor">#define WIN_CNT         0x3f</span>
00344 <span class="preprocessor"></span>        BYTE        wePart1[10];
00345         BYTE        weAttributes;
00346 <span class="preprocessor">#define ATTR_WIN95      0x0f</span>
00347 <span class="preprocessor"></span>        BYTE        weReserved1;
00348         BYTE        weChksum;
00349         BYTE        wePart2[12];
00350         WORD        weReserved2;
00351         BYTE        wePart3[4];
00352 };
00353 
00354 <span class="preprocessor">#define WIN_ENTRY_CHARS 13      // Number of chars per winentry</span>
00355 <span class="preprocessor"></span>
00356 <span class="comment">// Maximum filename length in Win95</span>
00357 <span class="comment">// Note: Must be &lt; sizeof(dirent.d_name)</span>
00358 <span class="preprocessor">#define WIN_MAXLEN      255</span>
00359 <span class="preprocessor"></span>
00360 <span class="comment">// This is the format of the contents of the deTime field in the direntry</span>
00361 <span class="comment">// structure.</span>
00362 <span class="comment">// We don't use bitfields because we don't know how compilers for</span>
00363 <span class="comment">// arbitrary machines will lay them out.</span>
00364 <span class="preprocessor">#define DT_2SECONDS_MASK        0x1F    // seconds divided by 2</span>
00365 <span class="preprocessor"></span><span class="preprocessor">#define DT_2SECONDS_SHIFT       0</span>
00366 <span class="preprocessor"></span><span class="preprocessor">#define DT_MINUTES_MASK         0x7E0   // minutes</span>
00367 <span class="preprocessor"></span><span class="preprocessor">#define DT_MINUTES_SHIFT        5</span>
00368 <span class="preprocessor"></span><span class="preprocessor">#define DT_HOURS_MASK           0xF800  // hours</span>
00369 <span class="preprocessor"></span><span class="preprocessor">#define DT_HOURS_SHIFT          11</span>
00370 <span class="preprocessor"></span>
00371 <span class="comment">// This is the format of the contents of the deDate field in the direntry</span>
00372 <span class="comment">// structure.</span>
00373 <span class="preprocessor">#define DD_DAY_MASK             0x1F    // day of month</span>
00374 <span class="preprocessor"></span><span class="preprocessor">#define DD_DAY_SHIFT            0</span>
00375 <span class="preprocessor"></span><span class="preprocessor">#define DD_MONTH_MASK           0x1E0   // month</span>
00376 <span class="preprocessor"></span><span class="preprocessor">#define DD_MONTH_SHIFT          5</span>
00377 <span class="preprocessor"></span><span class="preprocessor">#define DD_YEAR_MASK            0xFE00  // year - 1980</span>
00378 <span class="preprocessor"></span><span class="preprocessor">#define DD_YEAR_SHIFT           9</span>
00379 <span class="preprocessor"></span>
00380 <span class="comment">// Stuctures</span>
00381 <span class="keyword">struct </span>FileInfoStruct
00382 {
00383     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> StartCluster;         <span class="comment">//&lt; file starting cluster for last file accessed</span>
00384     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> Size;                 <span class="comment">//&lt; file size for last file accessed</span>
00385     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> Attr;                 <span class="comment">//&lt; file attr for last file accessed</span>
00386     <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> CreateTime;          <span class="comment">//&lt; file creation time for last file accessed</span>
00387     <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> CreateDate;          <span class="comment">//&lt; file creation date for last file accessed</span>
00388 };
00389 
00390 <span class="comment">// Prototypes</span>
00391 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> fatInit( <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> device);
00392 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> fatClusterSize(<span class="keywordtype">void</span>);
00393 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> fatGetDirEntry(<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> entry);
00394 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> fatChangeDirectory(<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> entry);
00395 <span class="keywordtype">void</span> fatPrintDirEntry(<span class="keywordtype">void</span>);
00396 <span class="keywordtype">void</span> fatDumpDirSlot(<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> entry);
00397 <span class="keyword">struct </span>FileInfoStruct* fatGetFileInfo(<span class="keywordtype">void</span>);
00398 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fatGetFilesize(<span class="keywordtype">void</span>);
00399 <span class="keywordtype">char</span>* fatGetFilename(<span class="keywordtype">void</span>);
00400 <span class="keywordtype">char</span>* fatGetDirname(<span class="keywordtype">void</span>);
00401 <span class="keywordtype">void</span> fatLoadCluster(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> cluster, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *buffer);
00402 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fatNextCluster(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> cluster);
00403 
00404 <span class="preprocessor">#endif</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Sun Oct 29 03:41:06 2006 for Procyon AVRlib by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.2 </small></address>
</body>
</html>
