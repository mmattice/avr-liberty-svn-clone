<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Procyon AVRlib: spiflash.c Source File</title>
<link href="dox.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.2 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>spiflash.c</h1><a href="spiflash_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*! \file spiflash.c \brief SPI Flash Memory Driver (M25Pxx/AT25Fxxx/etc). */</span>
00002 <span class="comment">//*****************************************************************************</span>
00003 <span class="comment">//</span>
00004 <span class="comment">// File Name    : 'spiflash.c'</span>
00005 <span class="comment">// Title        : SPI Flash Memory Driver (M25Pxx/AT25Fxxx/etc)</span>
00006 <span class="comment">// Author       : Pascal Stang - Copyright (C) 2006</span>
00007 <span class="comment">// Created      : 2006-04-15</span>
00008 <span class="comment">// Revised      : 2006-07-02</span>
00009 <span class="comment">// Version      : 0.1</span>
00010 <span class="comment">// Target MCU   : AVR processors</span>
00011 <span class="comment">// Editor Tabs  : 4</span>
00012 <span class="comment">//</span>
00013 <span class="comment">// NOTE: This code is currently below version 1.0, and therefore is considered</span>
00014 <span class="comment">// to be lacking in some functionality or documentation, or may not be fully</span>
00015 <span class="comment">// tested.  Nonetheless, you can expect most functions to work.</span>
00016 <span class="comment">//</span>
00017 <span class="comment">//*****************************************************************************</span>
00018 
00019 <span class="comment">// system includes</span>
00020 <span class="preprocessor">#include "avr/io.h"</span>
00021 <span class="preprocessor">#include "<a class="code" href="global_8h.html">global.h</a>"</span>
00022 
00023 <span class="comment">// library includes</span>
00024 <span class="preprocessor">#include "<a class="code" href="spi_8h.html">spi.h</a>"</span>
00025 <span class="preprocessor">#include "<a class="code" href="spiflash_8h.html">spiflash.h</a>"</span>
00026 
00027 <span class="preprocessor">#define SPIFLASH_CONFIG_CS      DDRB  |= (1&lt;&lt;0)</span>
00028 <span class="preprocessor"></span><span class="preprocessor">#define SPIFLASH_ASSERT_CS      PORTB &amp;= (1&lt;&lt;0)</span>
00029 <span class="preprocessor"></span><span class="preprocessor">#define SPIFLASH_RELEASE_CS     PORTB |= (1&lt;&lt;0)</span>
00030 <span class="preprocessor"></span>
00031 <span class="comment">// functions</span>
00032 <span class="keywordtype">void</span> spiflashInit(<span class="keywordtype">void</span>)
00033 {
00034     <span class="comment">// initialize spi</span>
00035     spiInit();
00036     <span class="comment">// initialize chip select</span>
00037     SPIFLASH_RELEASE_CS;
00038     SPIFLASH_CONFIG_CS;
00039 }
00040 
00041 <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> spiflashGetID(<span class="keywordtype">void</span>)
00042 {
00043     <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> id;
00044 
00045     SPIFLASH_ASSERT_CS;
00046     spiByte(0, SPIFLASH_CMD_RDID, 0);
00047     <span class="keywordtype">id</span>  = spiByte(0, 0x00, 0)&lt;&lt;8;
00048     <span class="keywordtype">id</span> |= spiByte(0, 0x00, 1);
00049     SPIFLASH_RELEASE_CS;
00050 
00051     <span class="keywordflow">return</span> id;
00052 }
00053 
00054 <span class="keywordtype">void</span> spiflashChipErase(<span class="keywordtype">void</span>)
00055 {
00056     <span class="comment">// enable write</span>
00057     SPIFLASH_ASSERT_CS;
00058     spiByte(0, SPIFLASH_CMD_WREN, 1);
00059     SPIFLASH_RELEASE_CS;
00060 
00061     <span class="comment">// clock out dummy byte to waste time</span>
00062     spiByte(0, 0x00, 1);
00063 
00064     <span class="comment">// do chip erase</span>
00065     SPIFLASH_ASSERT_CS;
00066     spiByte(0, SPIFLASH_CMD_CHIPERASE, 1);
00067     SPIFLASH_RELEASE_CS;
00068 
00069     <span class="comment">// clock out dummy byte to waste time</span>
00070     spiByte(0, 0x00, 1);
00071 
00072     <span class="comment">// wait until write is done</span>
00073     SPIFLASH_ASSERT_CS;
00074     spiByte(0, SPIFLASH_CMD_RDSR, 0);
00075     <span class="keywordflow">while</span>(spiByte(0, 0x00, 0) &amp; SPIFLASH_STATUS_BUSY);
00076     SPIFLASH_RELEASE_CS;
00077 }
00078 
00079 <span class="keywordtype">void</span> spiflashRead(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> addr, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> nbytes, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *data)
00080 {
00081     <span class="comment">// begin read</span>
00082     SPIFLASH_ASSERT_CS;
00083     <span class="comment">// issue read command</span>
00084     spiByte(0, SPIFLASH_CMD_READ, 0);
00085     <span class="comment">// send address</span>
00086     spiByte(0, addr&gt;&gt;16, 0);
00087     spiByte(0, addr&gt;&gt;8, 0);
00088     spiByte(0, addr&gt;&gt;0, 0);
00089     <span class="comment">// read data</span>
00090     <span class="keywordflow">while</span>(nbytes--)
00091         *data++ = spiByte(0, 0x00, 0);
00092     <span class="comment">// end read</span>
00093     SPIFLASH_RELEASE_CS;
00094 }
00095 
00096 <span class="keywordtype">void</span> spiflashWrite(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> addr, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> nbytes, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *data)
00097 {
00098     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> page;
00099     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;
00100     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pagelen;
00101 
00102     <span class="comment">// loop through pages to be programmed</span>
00103     <span class="keywordflow">for</span>(page=0; page&lt;((nbytes+SPIFLASH_PAGESIZE-1)&gt;&gt;8); page++)
00104     {
00105         <span class="comment">// program this page</span>
00106 
00107         <span class="comment">// enable write</span>
00108         SPIFLASH_ASSERT_CS;
00109         spiByte(0, SPIFLASH_CMD_WREN, 1);
00110         SPIFLASH_RELEASE_CS;
00111         
00112         <span class="comment">// clock out dummy byte to waste time</span>
00113         spiByte(0, 0x00, 1);
00114 
00115         <span class="comment">// begin write</span>
00116         SPIFLASH_ASSERT_CS;
00117         <span class="comment">// issue write command</span>
00118         spiByte(0, SPIFLASH_CMD_PAGEPROG, 0);
00119         <span class="comment">// send address</span>
00120         spiByte(0, addr&gt;&gt;16, 0);
00121         spiByte(0, addr&gt;&gt;8, 0);
00122         spiByte(0, addr&gt;&gt;0, 0);
00123         <span class="comment">// program exactly the number of bytes requested</span>
00124         <span class="keywordflow">if</span>( ((page&lt;&lt;8)+SPIFLASH_PAGESIZE) &lt;= nbytes)
00125             pagelen = SPIFLASH_PAGESIZE;
00126         <span class="keywordflow">else</span>
00127             pagelen = nbytes-(page&lt;&lt;8);
00128         <span class="comment">// transfer data</span>
00129         <span class="keywordflow">for</span>(i=0; i&lt;pagelen; i++)
00130             spiByte(0, *data++, 0);
00131         <span class="comment">// end write</span>
00132         SPIFLASH_RELEASE_CS;
00133 
00134         <span class="comment">// clock out dummy byte to waste time</span>
00135         spiByte(0, 0x00, 1);
00136 
00137         <span class="comment">// wait until write is done</span>
00138         SPIFLASH_ASSERT_CS;
00139         spiByte(0, SPIFLASH_CMD_RDSR, 0);
00140         <span class="keywordflow">while</span>(spiByte(0, 0x00, 0) &amp; SPIFLASH_STATUS_BUSY);
00141         SPIFLASH_RELEASE_CS;
00142 
00143         <span class="comment">// clock out dummy byte to waste time</span>
00144         spiByte(0, 0x00, 1);
00145     }
00146 }
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Sun Oct 29 03:41:07 2006 for Procyon AVRlib by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.2 </small></address>
</body>
</html>
