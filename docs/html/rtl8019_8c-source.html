<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Procyon AVRlib: net/rtl8019.c Source File</title>
<link href="dox.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.2 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<div class="nav">
<a class="el" href="dir_000001.html">net</a></div>
<h1>rtl8019.c</h1><a href="rtl8019_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*! \file rtl8019.c \brief Realtek RTL8019AS Ethernet Interface Driver. */</span>
00002 <span class="comment">//*****************************************************************************</span>
00003 <span class="comment">//</span>
00004 <span class="comment">// File Name    : 'rtl8019.c'</span>
00005 <span class="comment">// Title        : Realtek RTL8019AS Ethernet Interface Driver</span>
00006 <span class="comment">// Author       : Pascal Stang</span>
00007 <span class="comment">// Created      : 7/6/2004</span>
00008 <span class="comment">// Revised      : 10/1/2005</span>
00009 <span class="comment">// Version      : 0.1</span>
00010 <span class="comment">// Target MCU   : Atmel AVR series</span>
00011 <span class="comment">// Editor Tabs  : 4</span>
00012 <span class="comment">//</span>
00013 <span class="comment">// Based in part on code by Louis Beaudoin (www.embedded-creations.com).</span>
00014 <span class="comment">// Thanks to Adam Dunkels and Louis Beaudoin for providing the initial</span>
00015 <span class="comment">// structure in which to write this driver.</span>
00016 <span class="comment">//*****************************************************************************</span>
00017 
00018 <span class="preprocessor">#include "<a class="code" href="global_8h.html">global.h</a>"</span>
00019 <span class="preprocessor">#include "<a class="code" href="timer_8h.html">timer.h</a>"</span>
00020 <span class="preprocessor">#include "<a class="code" href="rprintf_8h.html">rprintf.h</a>"</span>
00021 
00022 <span class="preprocessor">#include "<a class="code" href="rtl8019_8h.html">rtl8019.h</a>"</span>
00023 
00024 <span class="comment">// include configuration</span>
00025 <span class="preprocessor">#include "<a class="code" href="rtl8019conf_8h.html">rtl8019conf.h</a>"</span>
00026 
00027 <span class="comment">// pointers to locations in the RTL8019 receive buffer</span>
00028 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> NextPage;              <span class="comment">// page pointer to next Rx packet</span>
00029 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> CurrentRetreiveAddress; <span class="comment">// DMA address for read Rx packet location</span>
00030 
00031 
<a name="l00032"></a><a class="code" href="group__nic.html#ga0">00032</a> <span class="keywordtype">void</span> <a class="code" href="group__nic.html#ga0">nicInit</a>(<span class="keywordtype">void</span>)
00033 {
00034     rtl8019Init();
00035 }
00036 
<a name="l00037"></a><a class="code" href="group__nic.html#ga1">00037</a> <span class="keywordtype">void</span> <a class="code" href="group__nic.html#ga1">nicSend</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> len, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* packet)
00038 {
00039     rtl8019BeginPacketSend(len);
00040     rtl8019SendPacketData(packet, len);
00041     rtl8019EndPacketSend();
00042 }
00043 
<a name="l00044"></a><a class="code" href="group__nic.html#ga2">00044</a> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="group__nic.html#ga2">nicPoll</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxlen, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* packet)
00045 {
00046     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> packetLength;
00047     
00048     packetLength = rtl8019BeginPacketRetreive();
00049 
00050     <span class="comment">// if there's no packet or an error - exit without ending the operation</span>
00051     <span class="keywordflow">if</span>( !packetLength )
00052         <span class="keywordflow">return</span> 0;
00053 
00054     <span class="comment">// drop anything too big for the buffer</span>
00055     <span class="keywordflow">if</span>( packetLength &gt; maxlen )
00056     {
00057         rtl8019EndPacketRetreive();
00058         <span class="keywordflow">return</span> 0;
00059     }
00060     
00061     <span class="comment">// copy the packet data into the packet buffer</span>
00062     rtl8019RetreivePacketData( packet, packetLength );
00063     rtl8019EndPacketRetreive();
00064         
00065     <span class="keywordflow">return</span> packetLength;
00066 }
00067 
00068 <span class="keywordtype">void</span> nicGetMacAddress(u08* macaddr)
00069 {
00070     u08 tempCR;
00071     <span class="comment">// switch register pages</span>
00072     tempCR = rtl8019Read(CR);
00073     rtl8019Write(CR,tempCR|PS0);
00074     <span class="comment">// read MAC address registers</span>
00075     *macaddr++ = rtl8019Read(PAR0);
00076     *macaddr++ = rtl8019Read(PAR1);
00077     *macaddr++ = rtl8019Read(PAR2);
00078     *macaddr++ = rtl8019Read(PAR3);
00079     *macaddr++ = rtl8019Read(PAR4);
00080     *macaddr++ = rtl8019Read(PAR5);
00081     <span class="comment">// switch register pages back</span>
00082     rtl8019Write(CR,tempCR);
00083 }
00084 
00085 <span class="keywordtype">void</span> nicSetMacAddress(u08* macaddr)
00086 {
00087     u08 tempCR;
00088     <span class="comment">// switch register pages</span>
00089     tempCR = rtl8019Read(CR);
00090     rtl8019Write(CR,tempCR|PS0);
00091     <span class="comment">// write MAC address registers</span>
00092     rtl8019Write(PAR0, *macaddr++);
00093     rtl8019Write(PAR1, *macaddr++);
00094     rtl8019Write(PAR2, *macaddr++);
00095     rtl8019Write(PAR3, *macaddr++);
00096     rtl8019Write(PAR4, *macaddr++);
00097     rtl8019Write(PAR5, *macaddr++);
00098     <span class="comment">// switch register pages back</span>
00099     rtl8019Write(CR,tempCR);
00100 }
00101 
<a name="l00102"></a><a class="code" href="group__nic.html#ga5">00102</a> <span class="keywordtype">void</span> <a class="code" href="group__nic.html#ga5">nicRegDump</a>(<span class="keywordtype">void</span>)
00103 {
00104     rtl8019RegDump();
00105 }
00106 
00107 
00108 <span class="keywordtype">void</span> rtl8019SetupPorts(<span class="keywordtype">void</span>)
00109 {
00110 <span class="preprocessor">#if NIC_CONNECTION == MEMORY_MAPPED</span>
00111 <span class="preprocessor"></span>    <span class="comment">// enable external SRAM interface - no wait states</span>
00112     sbi(MCUCR, SRE);
00113 <span class="comment">//  sbi(MCUCR, SRW10);</span>
00114 <span class="comment">//  sbi(XMCRA, SRW00);</span>
00115 <span class="comment">//  sbi(XMCRA, SRW01);</span>
00116 <span class="comment">//  sbi(XMCRA, SRW11);</span>
00117 <span class="preprocessor">#else</span>
00118 <span class="preprocessor"></span>    <span class="comment">// make the address port output</span>
00119     RTL8019_ADDRESS_DDR |= RTL8019_ADDRESS_MASK;
00120     <span class="comment">// make the data port input with pull-ups</span>
00121     RTL8019_DATA_PORT = 0xFF;
00122 
00123     <span class="comment">// initialize the control port read and write pins to de-asserted</span>
00124     RTL8019_CONTROL_DDR |= (1&lt;&lt;RTL8019_CONTROL_READPIN);
00125     RTL8019_CONTROL_DDR |= (1&lt;&lt;RTL8019_CONTROL_WRITEPIN);
00126     <span class="comment">// set the read and write pins to output</span>
00127     RTL8019_CONTROL_PORT |= (1&lt;&lt;RTL8019_CONTROL_READPIN);
00128     RTL8019_CONTROL_PORT |= (1&lt;&lt;RTL8019_CONTROL_WRITEPIN);
00129 <span class="preprocessor">#endif</span>
00130 <span class="preprocessor"></span>    <span class="comment">// set reset pin to output</span>
00131     sbi(RTL8019_RESET_DDR, RTL8019_RESET_PIN);
00132 }
00133 
00134 
00135 <span class="preprocessor">#if NIC_CONNECTION == MEMORY_MAPPED</span>
00136 <span class="preprocessor"></span><span class="keyword">inline</span> <span class="keywordtype">void</span> rtl8019Write(u08 address, u08 data)
00137 {
00138     *(<span class="keyword">volatile</span> u08*)(RTL8019_MEMORY_MAPPED_OFFSET + address) = data;
00139 }
00140 <span class="preprocessor">#else</span>
00141 <span class="preprocessor"></span><span class="keywordtype">void</span> rtl8019Write(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> address, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> data)
00142 {
00143     <span class="comment">// assert the address</span>
00144     RTL8019_ADDRESS_PORT = address | (RTL8019_ADDRESS_PORT&amp;~RTL8019_ADDRESS_MASK);
00145     <span class="comment">// set data bus as output and place data on bus</span>
00146     RTL8019_DATA_DDR = 0xFF;
00147     RTL8019_DATA_PORT = data;
00148     <span class="comment">// clock write pin</span>
00149     cbi(RTL8019_CONTROL_PORT, RTL8019_CONTROL_WRITEPIN);
00150     nop();
00151     nop();
00152     sbi(RTL8019_CONTROL_PORT, RTL8019_CONTROL_WRITEPIN);
00153     <span class="comment">// set data port back to input with pullups enabled</span>
00154     RTL8019_DATA_DDR = 0x00;
00155     RTL8019_DATA_PORT = 0xFF;
00156 }
00157 <span class="preprocessor">#endif</span>
00158 <span class="preprocessor"></span>
00159 
00160 <span class="preprocessor">#if NIC_CONNECTION == MEMORY_MAPPED</span>
00161 <span class="preprocessor"></span><span class="keyword">inline</span> u08 ax88796Read(u08 address)
00162 {
00163     <span class="keywordflow">return</span> *(<span class="keyword">volatile</span> u08*)(RTL8019_MEMORY_MAPPED_OFFSET + address);
00164 }
00165 <span class="preprocessor">#else</span>
00166 <span class="preprocessor"></span><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> rtl8019Read(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> address)
00167 {
00168     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> data;
00169    
00170     <span class="comment">// assert the address</span>
00171     RTL8019_ADDRESS_PORT = address | (RTL8019_ADDRESS_PORT&amp;~RTL8019_ADDRESS_MASK);
00172     <span class="comment">// assert read</span>
00173     cbi(RTL8019_CONTROL_PORT, RTL8019_CONTROL_READPIN);
00174     nop();
00175     nop();
00176     <span class="comment">// read in the data</span>
00177     data = RTL8019_DATA_PIN;
00178     <span class="comment">// negate read</span>
00179     sbi(RTL8019_CONTROL_PORT, RTL8019_CONTROL_READPIN);
00180     <span class="comment">// return data</span>
00181     <span class="keywordflow">return</span> data;
00182 }
00183 <span class="preprocessor">#endif                       </span>
00184 <span class="preprocessor"></span>
00185 
00186 <span class="keywordtype">void</span> rtl8019Init(<span class="keywordtype">void</span>)
00187 {
00188     <span class="comment">// setup I/O ports</span>
00189     rtl8019SetupPorts();
00190     
00191     <span class="comment">// do a hard reset</span>
00192     sbi(RTL8019_RESET_PORT, RTL8019_RESET_PIN);
00193     delay_ms(10);
00194     cbi(RTL8019_RESET_PORT, RTL8019_RESET_PIN);
00195 
00196     <span class="comment">// clear interrupt state</span>
00197     rtl8019Write( ISR, rtl8019Read(ISR) );
00198     delay_ms(50);
00199 
00200     <span class="comment">// switch to page 3 to load config registers</span>
00201     rtl8019Write(CR, (PS0|PS1|RD2|STOP));
00202 
00203     <span class="comment">// disable EEPROM write protect of config registers</span>
00204     rtl8019Write(RTL_EECR, (EEM1|EEM0));
00205 
00206     <span class="comment">// set network type to 10 Base-T link test</span>
00207     rtl8019Write(CONFIG2, 0x20);
00208 
00209     <span class="comment">// disable powerdown and sleep</span>
00210     rtl8019Write(CONFIG3, 0);
00211     delay_ms(255);
00212 
00213     <span class="comment">// reenable EEPROM write protect</span>
00214     rtl8019Write(RTL_EECR, 0);
00215 
00216     <span class="comment">// go back to page 0, stop NIC, abort DMA</span>
00217     rtl8019Write(CR, (RD2|STOP));
00218     delay_ms(2);                    <span class="comment">// wait for traffic to complete</span>
00219     rtl8019Write(DCR, DCR_INIT);
00220     rtl8019Write(RBCR0,0x00);
00221     rtl8019Write(RBCR1,0x00);
00222     rtl8019Write(RCR, AB);
00223     rtl8019Write(TPSR, TXSTART_INIT);
00224     rtl8019Write(TCR, LB0);
00225     rtl8019Write(PSTART, RXSTART_INIT);
00226     rtl8019Write(BNRY, RXSTART_INIT);
00227     rtl8019Write(PSTOP, RXSTOP_INIT);
00228     rtl8019Write(CR, (PS0|RD2|STOP));   <span class="comment">// switch to page 1</span>
00229     delay_ms(2);
00230     rtl8019Write(CPR, RXSTART_INIT);
00231     
00232     <span class="comment">// set MAC address</span>
00233     rtl8019Write(PAR0, RTL8019_MAC0);
00234     rtl8019Write(PAR1, RTL8019_MAC1);
00235     rtl8019Write(PAR2, RTL8019_MAC2);
00236     rtl8019Write(PAR3, RTL8019_MAC3);
00237     rtl8019Write(PAR4, RTL8019_MAC4);
00238     rtl8019Write(PAR5, RTL8019_MAC5);
00239     
00240     <span class="comment">// initialize sequence per NE2000 spec</span>
00241     rtl8019Write(CR, (RD2|STOP));
00242     rtl8019Write(DCR, DCR_INIT);
00243     rtl8019Write(CR, (RD2|START));
00244     rtl8019Write(ISR,0xFF);         <span class="comment">// clear all interrupts</span>
00245     rtl8019Write(IMR, IMR_INIT);
00246     rtl8019Write(TCR, TCR_INIT);
00247     
00248     rtl8019Write(CR, (RD2|START));  <span class="comment">// start the NIC</span>
00249 }
00250 
00251 
00252 <span class="keywordtype">void</span> rtl8019BeginPacketSend(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> packetLength)
00253 {
00254     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sendPacketLength;
00255     sendPacketLength = (packetLength&gt;=ETHERNET_MIN_PACKET_LENGTH)?
00256                         (packetLength):ETHERNET_MIN_PACKET_LENGTH;
00257     
00258     <span class="comment">//start the NIC</span>
00259     rtl8019Write(CR, (RD2|START));
00260     
00261     <span class="comment">// still transmitting a packet - wait for it to finish</span>
00262     <span class="keywordflow">while</span>( rtl8019Read(CR) &amp; TXP );
00263 
00264     <span class="comment">// load beginning page for transmit buffer</span>
00265     rtl8019Write(TPSR,TXSTART_INIT);
00266     
00267     <span class="comment">// set start address for remote DMA operation</span>
00268     rtl8019Write(RSAR0,0x00);
00269     rtl8019Write(RSAR1,0x40);
00270     
00271     <span class="comment">// clear the packet stored interrupt</span>
00272     rtl8019Write(ISR,PTX);
00273 
00274     <span class="comment">// load data byte count for remote DMA</span>
00275     rtl8019Write(RBCR0, (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)(packetLength));
00276     rtl8019Write(RBCR1, (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)(packetLength&gt;&gt;8));
00277 
00278     rtl8019Write(TBCR0, (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)(sendPacketLength));
00279     rtl8019Write(TBCR1, (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)((sendPacketLength)&gt;&gt;8));
00280     
00281     <span class="comment">// do remote write operation</span>
00282     rtl8019Write(CR,(RD1|START));
00283 }
00284 
00285 
00286 <span class="keywordtype">void</span> rtl8019SendPacketData(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *localBuffer, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> length)
00287 {
00288     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;
00289     
00290     <span class="comment">// write data to DMA port</span>
00291     <span class="keywordflow">for</span>(i=0;i&lt;length;i++)
00292         rtl8019Write(RDMAPORT, localBuffer[i]);
00293 }
00294 
00295 
00296 <span class="keywordtype">void</span> rtl8019EndPacketSend(<span class="keywordtype">void</span>)
00297 {
00298     <span class="comment">//send the contents of the transmit buffer onto the network</span>
00299     rtl8019Write(CR,(RD2|TXP));
00300     <span class="comment">// clear the remote DMA interrupt</span>
00301     rtl8019Write(ISR, RDC);
00302 }
00303 
00304 
00305 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> rtl8019BeginPacketRetreive(<span class="keywordtype">void</span>)
00306 {
00307     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> i;
00308     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> bnry;
00309     
00310     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> pageheader[4];
00311     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> rxlen;
00312     
00313     <span class="comment">// check for and handle an overflow</span>
00314     rtl8019ProcessInterrupt();
00315     
00316     <span class="comment">// read CPR from page 1</span>
00317     rtl8019Write(CR,(PS0|RD2|START));
00318     i = rtl8019Read(CPR);
00319     
00320     <span class="comment">// return to page 0</span>
00321     rtl8019Write(CR,(RD2|START));
00322     
00323     <span class="comment">// read the boundary register - pointing to the beginning of the packet</span>
00324     bnry = rtl8019Read(BNRY) ;
00325     
00326     <span class="comment">// return if there is no packet in the buffer</span>
00327     <span class="keywordflow">if</span>( bnry == i )
00328         <span class="keywordflow">return</span> 0;
00329 
00330     <span class="comment">// clear the packet received interrupt flag</span>
00331     rtl8019Write(ISR, PRX);
00332     
00333     <span class="comment">// if boundary pointer is invalid</span>
00334     <span class="keywordflow">if</span>( (bnry &gt;= RXSTOP_INIT) || (bnry &lt; RXSTART_INIT) )
00335     {
00336         <span class="comment">// reset the contents of the buffer and exit</span>
00337         rtl8019Write(BNRY, RXSTART_INIT);
00338         rtl8019Write(CR, (PS0|RD2|START));
00339         rtl8019Write(CPR, RXSTART_INIT);
00340         rtl8019Write(CR, (RD2|START));
00341         <span class="keywordflow">return</span> 0;
00342     }
00343 
00344     <span class="comment">// initiate DMA to transfer the RTL8019 packet header</span>
00345     rtl8019Write(RBCR0, 4);
00346     rtl8019Write(RBCR1, 0);
00347     rtl8019Write(RSAR0, 0);
00348     rtl8019Write(RSAR1, bnry);
00349     rtl8019Write(CR, (RD0|START));
00350     <span class="comment">// transfer packet header</span>
00351     <span class="keywordflow">for</span>(i=0;i&lt;4;i++)
00352         pageheader[i] = rtl8019Read(RDMAPORT);
00353     <span class="comment">// end the DMA operation</span>
00354     rtl8019Write(CR, (RD2|START));
00355     <span class="comment">// wait for remote DMA complete</span>
00356     <span class="keywordflow">for</span>(i = 0; i &lt; 20; i++)
00357         <span class="keywordflow">if</span>(rtl8019Read(ISR) &amp; RDC)
00358             <span class="keywordflow">break</span>;
00359     rtl8019Write(ISR, RDC);
00360 
00361     rxlen = (pageheader[PKTHEADER_PKTLENH]&lt;&lt;8) + pageheader[PKTHEADER_PKTLENL];
00362     NextPage = pageheader[PKTHEADER_NEXTPAGE];
00363     
00364     CurrentRetreiveAddress = (bnry&lt;&lt;8) + 4;
00365     
00366     <span class="comment">// if the NextPage pointer is invalid, the packet is not ready yet - exit</span>
00367     <span class="keywordflow">if</span>( (NextPage &gt;= RXSTOP_INIT) || (NextPage &lt; RXSTART_INIT) )
00368         <span class="keywordflow">return</span> 0;
00369     
00370     <span class="keywordflow">return</span> rxlen-4;
00371 }
00372 
00373 
00374 <span class="keywordtype">void</span> rtl8019RetreivePacketData(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> * localBuffer, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> length)
00375 {
00376     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;
00377     
00378     <span class="comment">// initiate DMA to transfer the data</span>
00379     rtl8019Write(RBCR0, (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)length);
00380     rtl8019Write(RBCR1, (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)(length&gt;&gt;8));
00381     rtl8019Write(RSAR0, (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)CurrentRetreiveAddress);
00382     rtl8019Write(RSAR1, (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)(CurrentRetreiveAddress&gt;&gt;8));
00383     rtl8019Write(CR, (RD0|START));
00384     <span class="comment">// transfer packet data</span>
00385     <span class="keywordflow">for</span>(i=0;i&lt;length;i++)
00386         localBuffer[i] = rtl8019Read(RDMAPORT);
00387     <span class="comment">// end the DMA operation</span>
00388     rtl8019Write(CR, (RD2|START));
00389     <span class="comment">// wait for remote DMA complete</span>
00390     <span class="keywordflow">for</span>(i=0; i&lt;20; i++)
00391         <span class="keywordflow">if</span>(rtl8019Read(ISR) &amp; RDC)
00392             <span class="keywordflow">break</span>;
00393     rtl8019Write(ISR, RDC);
00394     <span class="comment">// keep track of current address</span>
00395     CurrentRetreiveAddress += length;
00396     <span class="keywordflow">if</span>( CurrentRetreiveAddress &gt;= 0x6000 )
00397         CurrentRetreiveAddress = CurrentRetreiveAddress - (0x6000-0x4600) ;
00398 }
00399 
00400 
00401 <span class="keywordtype">void</span> rtl8019EndPacketRetreive(<span class="keywordtype">void</span>)
00402 {
00403     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> i;
00404 
00405     <span class="comment">// end the DMA operation</span>
00406     rtl8019Write(CR, (RD2|START));
00407     <span class="comment">// wait for remote DMA complete</span>
00408     <span class="keywordflow">for</span>(i=0; i&lt;20; i++)
00409         <span class="keywordflow">if</span>(rtl8019Read(ISR) &amp; RDC)
00410             <span class="keywordflow">break</span>;
00411     rtl8019Write(ISR, RDC);
00412 
00413     <span class="comment">// set the boundary register to point to the start of the next packet</span>
00414     rtl8019Write(BNRY, NextPage);
00415 }
00416 
00417 
00418 <span class="keywordtype">void</span> rtl8019ProcessInterrupt(<span class="keywordtype">void</span>)
00419 {
00420     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> byte = rtl8019Read(ISR);
00421     
00422     <span class="keywordflow">if</span>( byte &amp; OVW )
00423         rtl8019ReceiveOverflowRecover();
00424 }
00425 
00426 <span class="keywordtype">void</span> rtl8019ReceiveOverflowRecover(<span class="keywordtype">void</span>)
00427 {
00428     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> data_L, resend;   
00429 
00430     data_L = rtl8019Read(CR);
00431     rtl8019Write(CR, 0x21);
00432     delay_ms(2);
00433     rtl8019Write(RBCR0, 0x00);
00434     rtl8019Write(RBCR1, 0x00);
00435     <span class="keywordflow">if</span>(!(data_L &amp; 0x04))
00436         resend = 0;
00437     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(data_L &amp; 0x04)
00438     {
00439         data_L = rtl8019Read(ISR);
00440         <span class="keywordflow">if</span>((data_L &amp; 0x02) || (data_L &amp; 0x08))
00441             resend = 0;
00442         <span class="keywordflow">else</span>
00443             resend = 1;
00444     }
00445     
00446     rtl8019Write(TCR, 0x02);
00447     rtl8019Write(CR, 0x22);
00448     rtl8019Write(BNRY, RXSTART_INIT);
00449     rtl8019Write(CR, 0x62);
00450     rtl8019Write(CPR, RXSTART_INIT);
00451     rtl8019Write(CR, 0x22);
00452     rtl8019Write(ISR, 0x10);
00453     rtl8019Write(TCR, TCR_INIT);
00454     
00455     <span class="keywordflow">if</span>(resend)
00456         rtl8019Write(CR, 0x26);
00457 
00458     rtl8019Write(ISR, 0xFF);
00459 }
00460 
00461 
00462 <span class="keywordtype">void</span> rtl8019RegDump(<span class="keywordtype">void</span>)
00463 {
00464 <span class="comment">//  unsigned char result;</span>
00465 <span class="comment">//  result = rtl8019Read(TR);</span>
00466     
00467 <span class="comment">//  rprintf("Media State: ");</span>
00468 <span class="comment">//  if(!(result &amp; AUTOD))</span>
00469 <span class="comment">//          rprintf("Autonegotiation\r\n");</span>
00470 <span class="comment">//  else if(result &amp; RST_B)</span>
00471 <span class="comment">//          rprintf("PHY in Reset   \r\n");</span>
00472 <span class="comment">//  else if(!(result &amp; RST_10B))</span>
00473 <span class="comment">//      rprintf("10BASE-T       \r\n");</span>
00474 <span class="comment">//  else if(!(result &amp; RST_TXB))</span>
00475 <span class="comment">//      rprintf("100BASE-T      \r\n");</span>
00476                 
00477     <span class="comment">//rprintf("TR regsiter      : %x\r\n",result);</span>
00478     <span class="comment">//result = read_mii(0x10,0);</span>
00479     <span class="comment">//rprintf("MII regsiter 0x10: %x\r\n",result);</span>
00480 
00481     rprintf(<span class="stringliteral">"Page0: CR  BNRY PSR PST ISR TSR RSR MMR TR  GPI\r\n"</span>);
00482     <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">"       "</span>);
00483     <a class="code" href="group__rprintf.html#ga7">rprintfu08</a>(rtl8019Read(CR));
00484     <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">"  "</span>);
00485     <a class="code" href="group__rprintf.html#ga7">rprintfu08</a>(rtl8019Read(BNRY));
00486     <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">"   "</span>);
00487     <a class="code" href="group__rprintf.html#ga7">rprintfu08</a>(rtl8019Read(PSTART));
00488     <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">"  "</span>);
00489     <a class="code" href="group__rprintf.html#ga7">rprintfu08</a>(rtl8019Read(PSTOP));
00490     <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">"  "</span>);
00491     <a class="code" href="group__rprintf.html#ga7">rprintfu08</a>(rtl8019Read(ISR));
00492     <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">"  "</span>);
00493     <a class="code" href="group__rprintf.html#ga7">rprintfu08</a>(rtl8019Read(TSR));
00494     <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">"  "</span>);
00495     <a class="code" href="group__rprintf.html#ga7">rprintfu08</a>(rtl8019Read(RSR));
00496     <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">"  "</span>);
00497 <span class="comment">//  rprintfu08(rtl8019Read(MEMR));</span>
00498     <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">"  "</span>);
00499 <span class="comment">//  rprintfu08(rtl8019Read(TR));</span>
00500     <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">"  "</span>);
00501 <span class="comment">//  rprintfu08(rtl8019Read(GPI));</span>
00502     <a class="code" href="group__rprintf.html#ga5">rprintfCRLF</a>();
00503 
00504     rtl8019Write(CR,rtl8019Read(CR)|PS0);
00505 
00506     rprintf(<span class="stringliteral">"Page1: CR  PAR    CPR\r\n"</span>);
00507     <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">"       "</span>);
00508     <a class="code" href="group__rprintf.html#ga7">rprintfu08</a>(rtl8019Read(CR));
00509     <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">"  "</span>);
00510     <a class="code" href="group__rprintf.html#ga1">rprintfChar</a>(rtl8019Read(PAR0));
00511     <a class="code" href="group__rprintf.html#ga1">rprintfChar</a>(rtl8019Read(PAR1));
00512     <a class="code" href="group__rprintf.html#ga1">rprintfChar</a>(rtl8019Read(PAR2));
00513     <a class="code" href="group__rprintf.html#ga1">rprintfChar</a>(rtl8019Read(PAR3));
00514     <a class="code" href="group__rprintf.html#ga1">rprintfChar</a>(rtl8019Read(PAR4));
00515     <a class="code" href="group__rprintf.html#ga1">rprintfChar</a>(rtl8019Read(PAR5));
00516     <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">" "</span>);
00517     <a class="code" href="group__rprintf.html#ga7">rprintfu08</a>(rtl8019Read(CPR));
00518     
00519     rtl8019Write(CR,rtl8019Read(CR)&amp;~PS0);
00520 
00521     delay_ms(25);
00522 }
00523 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Sun Oct 29 03:41:07 2006 for Procyon AVRlib by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.2 </small></address>
</body>
</html>
