<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Procyon AVRlib: encoder.c Source File</title>
<link href="dox.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.2 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>encoder.c</h1><a href="encoder_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*! \file encoder.c \brief Quadrature Encoder reader/driver. */</span>
00002 <span class="comment">//*****************************************************************************</span>
00003 <span class="comment">//</span>
00004 <span class="comment">// File Name    : 'encoder.c'</span>
00005 <span class="comment">// Title        : Quadrature Encoder reader/driver</span>
00006 <span class="comment">// Author       : Pascal Stang - Copyright (C) 2003-2004</span>
00007 <span class="comment">// Created      : 2003.01.26</span>
00008 <span class="comment">// Revised      : 2004.06.25</span>
00009 <span class="comment">// Version      : 0.3</span>
00010 <span class="comment">// Target MCU   : Atmel AVR Series</span>
00011 <span class="comment">// Editor Tabs  : 4</span>
00012 <span class="comment">//</span>
00013 <span class="comment">// NOTE: This code is currently below version 1.0, and therefore is considered</span>
00014 <span class="comment">// to be lacking in some functionality or documentation, or may not be fully</span>
00015 <span class="comment">// tested.  Nonetheless, you can expect most functions to work.</span>
00016 <span class="comment">//</span>
00017 <span class="comment">// This code is distributed under the GNU Public License</span>
00018 <span class="comment">//      which can be found at http://www.gnu.org/licenses/gpl.txt</span>
00019 <span class="comment">//</span>
00020 <span class="comment">//*****************************************************************************</span>
00021 
00022 <span class="preprocessor">#include &lt;avr/io.h&gt;</span>
00023 <span class="preprocessor">#include &lt;avr/interrupt.h&gt;</span>
00024 
00025 <span class="preprocessor">#include "<a class="code" href="global_8h.html">global.h</a>"</span>
00026 <span class="preprocessor">#include "<a class="code" href="encoder_8h.html">encoder.h</a>"</span>
00027 
00028 <span class="comment">// Program ROM constants</span>
00029 
00030 <span class="comment">// Global variables</span>
00031 <span class="keyword">volatile</span> <a class="code" href="structstruct__EncoderState.html">EncoderStateType</a> EncoderState[NUM_ENCODERS];
00032 
00033 <span class="comment">// Functions</span>
00034 
00035 <span class="comment">// encoderInit() initializes hardware and encoder position readings</span>
00036 <span class="comment">//      Run this init routine once before using any other encoder functions.</span>
<a name="l00037"></a><a class="code" href="encoder_8h.html#a2">00037</a> <span class="keywordtype">void</span> <a class="code" href="encoder_8c.html#a1">encoderInit</a>(<span class="keywordtype">void</span>)
00038 {
00039     u08 i;
00040 
00041     <span class="comment">// initialize/clear encoder data</span>
00042     <span class="keywordflow">for</span>(i=0; i&lt;NUM_ENCODERS; i++)
00043     {
00044         EncoderState[i].<a class="code" href="structstruct__EncoderState.html#o0">position</a> = 0;
00045         <span class="comment">//EncoderState[i].velocity = 0;     // NOT CURRENTLY USED</span>
00046     }
00047 
00048     <span class="comment">// configure direction and interrupt I/O pins:</span>
00049     <span class="comment">// - for input</span>
00050     <span class="comment">// - apply pullup resistors</span>
00051     <span class="comment">// - any-edge interrupt triggering</span>
00052     <span class="comment">// - enable interrupt</span>
00053 
00054 <span class="preprocessor">    #ifdef ENC0_SIGNAL</span>
00055 <span class="preprocessor"></span>        <span class="comment">// set interrupt pins to input and apply pullup resistor</span>
00056         cbi(ENC0_PHASEA_DDR, ENC0_PHASEA_PIN);
00057         sbi(ENC0_PHASEA_PORT, ENC0_PHASEA_PIN);
00058         <span class="comment">// set encoder direction pin for input and apply pullup resistor</span>
00059         cbi(ENC0_PHASEB_DDR, ENC0_PHASEB_PIN);
00060         sbi(ENC0_PHASEB_PORT, ENC0_PHASEB_PIN);
00061         <span class="comment">// configure interrupts for any-edge triggering</span>
00062         sbi(ENC0_ICR, ENC0_ISCX0);
00063         cbi(ENC0_ICR, ENC0_ISCX1);
00064         <span class="comment">// enable interrupts</span>
00065         sbi(<a class="code" href="encoder_8h.html#a0">IMSK</a>, ENC0_INT);    <span class="comment">// ISMK is auto-defined in encoder.h</span>
00066 <span class="preprocessor">    #endif</span>
00067 <span class="preprocessor"></span><span class="preprocessor">    #ifdef ENC1_SIGNAL</span>
00068 <span class="preprocessor"></span>        <span class="comment">// set interrupt pins to input and apply pullup resistor</span>
00069         cbi(ENC1_PHASEA_DDR, ENC1_PHASEA_PIN);
00070         sbi(ENC1_PHASEA_PORT, ENC1_PHASEA_PIN);
00071         <span class="comment">// set encoder direction pin for input and apply pullup resistor</span>
00072         cbi(ENC1_PHASEB_DDR, ENC1_PHASEB_PIN);
00073         sbi(ENC1_PHASEB_PORT, ENC1_PHASEB_PIN);
00074         <span class="comment">// configure interrupts for any-edge triggering</span>
00075         sbi(ENC1_ICR, ENC1_ISCX0);
00076         cbi(ENC1_ICR, ENC1_ISCX1);
00077         <span class="comment">// enable interrupts</span>
00078         sbi(<a class="code" href="encoder_8h.html#a0">IMSK</a>, ENC1_INT);    <span class="comment">// ISMK is auto-defined in encoder.h</span>
00079 <span class="preprocessor">    #endif</span>
00080 <span class="preprocessor"></span><span class="preprocessor">    #ifdef ENC2_SIGNAL</span>
00081 <span class="preprocessor"></span>        <span class="comment">// set interrupt pins to input and apply pullup resistor</span>
00082         cbi(ENC2_PHASEA_DDR, ENC2_PHASEA_PIN);
00083         sbi(ENC2_PHASEA_PORT, ENC2_PHASEA_PIN);
00084         <span class="comment">// set encoder direction pin for input and apply pullup resistor</span>
00085         cbi(ENC2_PHASEB_DDR, ENC2_PHASEB_PIN);
00086         sbi(ENC2_PHASEB_PORT, ENC2_PHASEB_PIN);
00087         <span class="comment">// configure interrupts for any-edge triggering</span>
00088         sbi(ENC2_ICR, ENC2_ISCX0);
00089         cbi(ENC2_ICR, ENC2_ISCX1);
00090         <span class="comment">// enable interrupts</span>
00091         sbi(<a class="code" href="encoder_8h.html#a0">IMSK</a>, ENC2_INT);    <span class="comment">// ISMK is auto-defined in encoder.h</span>
00092 <span class="preprocessor">    #endif</span>
00093 <span class="preprocessor"></span><span class="preprocessor">    #ifdef ENC3_SIGNAL</span>
00094 <span class="preprocessor"></span>        <span class="comment">// set interrupt pins to input and apply pullup resistor</span>
00095         cbi(ENC3_PHASEA_DDR, ENC3_PHASEA_PIN);
00096         sbi(ENC3_PHASEA_PORT, ENC3_PHASEA_PIN);
00097         <span class="comment">// set encoder direction pin for input and apply pullup resistor</span>
00098         cbi(ENC3_PHASEB_DDR, ENC3_PHASEB_PIN);
00099         sbi(ENC3_PHASEB_PORT, ENC3_PHASEB_PIN);
00100         <span class="comment">// configure interrupts for any-edge triggering</span>
00101         sbi(ENC3_ICR, ENC3_ISCX0);
00102         cbi(ENC3_ICR, ENC3_ISCX1);
00103         <span class="comment">// enable interrupts</span>
00104         sbi(<a class="code" href="encoder_8h.html#a0">IMSK</a>, ENC3_INT);    <span class="comment">// ISMK is auto-defined in encoder.h</span>
00105 <span class="preprocessor">    #endif</span>
00106 <span class="preprocessor"></span>    
00107     <span class="comment">// enable global interrupts</span>
00108     sei();
00109 }
00110 
00111 <span class="comment">// encoderOff() disables hardware and stops encoder position updates</span>
<a name="l00112"></a><a class="code" href="encoder_8h.html#a3">00112</a> <span class="keywordtype">void</span> <a class="code" href="encoder_8c.html#a2">encoderOff</a>(<span class="keywordtype">void</span>)
00113 {
00114     <span class="comment">// disable encoder interrupts</span>
00115 <span class="preprocessor">    #ifdef ENC0_SIGNAL</span>
00116 <span class="preprocessor"></span>        <span class="comment">// disable interrupts</span>
00117         sbi(<a class="code" href="encoder_8h.html#a0">IMSK</a>, INT0);    <span class="comment">// ISMK is auto-defined in encoder.h</span>
00118 <span class="preprocessor">    #endif</span>
00119 <span class="preprocessor"></span><span class="preprocessor">    #ifdef ENC1_SIGNAL</span>
00120 <span class="preprocessor"></span>        <span class="comment">// disable interrupts</span>
00121         sbi(<a class="code" href="encoder_8h.html#a0">IMSK</a>, INT1);    <span class="comment">// ISMK is auto-defined in encoder.h</span>
00122 <span class="preprocessor">    #endif</span>
00123 <span class="preprocessor"></span><span class="preprocessor">    #ifdef ENC2_SIGNAL</span>
00124 <span class="preprocessor"></span>        <span class="comment">// disable interrupts</span>
00125         sbi(<a class="code" href="encoder_8h.html#a0">IMSK</a>, INT2);    <span class="comment">// ISMK is auto-defined in encoder.h</span>
00126 <span class="preprocessor">    #endif</span>
00127 <span class="preprocessor"></span><span class="preprocessor">    #ifdef ENC3_SIGNAL</span>
00128 <span class="preprocessor"></span>        <span class="comment">// disable interrupts</span>
00129         sbi(<a class="code" href="encoder_8h.html#a0">IMSK</a>, INT3);    <span class="comment">// ISMK is auto-defined in encoder.h</span>
00130 <span class="preprocessor">    #endif</span>
00131 <span class="preprocessor"></span>}
00132 
00133 <span class="comment">// encoderGetPosition() reads the current position of the encoder </span>
<a name="l00134"></a><a class="code" href="encoder_8h.html#a4">00134</a> s32 <a class="code" href="encoder_8c.html#a3">encoderGetPosition</a>(u08 encoderNum)
00135 {
00136     <span class="comment">// sanity check</span>
00137     <span class="keywordflow">if</span>(encoderNum &lt; NUM_ENCODERS)
00138         <span class="keywordflow">return</span> EncoderState[encoderNum].<a class="code" href="structstruct__EncoderState.html#o0">position</a>;
00139     <span class="keywordflow">else</span>
00140         <span class="keywordflow">return</span> 0;
00141 }
00142 
00143 <span class="comment">// encoderSetPosition() sets the current position of the encoder</span>
<a name="l00144"></a><a class="code" href="encoder_8h.html#a5">00144</a> <span class="keywordtype">void</span> <a class="code" href="encoder_8c.html#a4">encoderSetPosition</a>(u08 encoderNum, s32 position)
00145 {
00146     <span class="comment">// sanity check</span>
00147     <span class="keywordflow">if</span>(encoderNum &lt; NUM_ENCODERS)
00148         EncoderState[encoderNum].<a class="code" href="structstruct__EncoderState.html#o0">position</a> = position;
00149     <span class="comment">// else do nothing</span>
00150 }
00151 
00152 <span class="preprocessor">#ifdef ENC0_SIGNAL</span>
00153 <span class="preprocessor"></span><span class="comment">//! Encoder 0 interrupt handler</span>
00154 <span class="comment"></span><a class="code" href="a2d_8c.html#a10">SIGNAL</a>(ENC0_SIGNAL)
00155 {
00156     <span class="comment">// encoder has generated a pulse</span>
00157     <span class="comment">// check the relative phase of the input channels</span>
00158     <span class="comment">// and update position accordingly</span>
00159     <span class="keywordflow">if</span>( ((inb(ENC0_PHASEA_PORTIN) &amp; (1&lt;&lt;ENC0_PHASEA_PIN)) == 0) ^
00160         ((inb(ENC0_PHASEB_PORTIN) &amp; (1&lt;&lt;ENC0_PHASEB_PIN)) == 0) )
00161     {
00162         EncoderState[0].<a class="code" href="structstruct__EncoderState.html#o0">position</a>++;
00163     }
00164     <span class="keywordflow">else</span>
00165     {
00166         EncoderState[0].<a class="code" href="structstruct__EncoderState.html#o0">position</a>--;
00167     }
00168 }
00169 <span class="preprocessor">#endif</span>
00170 <span class="preprocessor"></span>
00171 <span class="preprocessor">#ifdef ENC1_SIGNAL</span>
00172 <span class="preprocessor"></span><span class="comment">//! Encoder 1 interrupt handler</span>
00173 <span class="comment"></span><a class="code" href="a2d_8c.html#a10">SIGNAL</a>(ENC1_SIGNAL)
00174 {
00175     <span class="comment">// encoder has generated a pulse</span>
00176     <span class="comment">// check the relative phase of the input channels</span>
00177     <span class="comment">// and update position accordingly</span>
00178     <span class="keywordflow">if</span>( ((inb(ENC1_PHASEA_PORTIN) &amp; (1&lt;&lt;ENC1_PHASEA_PIN)) == 0) ^
00179         ((inb(ENC1_PHASEB_PORTIN) &amp; (1&lt;&lt;ENC1_PHASEB_PIN)) == 0) )
00180     {
00181         EncoderState[1].<a class="code" href="structstruct__EncoderState.html#o0">position</a>++;
00182     }
00183     <span class="keywordflow">else</span>
00184     {
00185         EncoderState[1].<a class="code" href="structstruct__EncoderState.html#o0">position</a>--;
00186     }
00187 }
00188 <span class="preprocessor">#endif</span>
00189 <span class="preprocessor"></span>
00190 <span class="preprocessor">#ifdef ENC2_SIGNAL</span>
00191 <span class="preprocessor"></span><span class="comment">//! Encoder 2 interrupt handler</span>
00192 <span class="comment"></span><a class="code" href="a2d_8c.html#a10">SIGNAL</a>(ENC2_SIGNAL)
00193 {
00194     <span class="comment">// encoder has generated a pulse</span>
00195     <span class="comment">// check the relative phase of the input channels</span>
00196     <span class="comment">// and update position accordingly</span>
00197     <span class="keywordflow">if</span>( ((inb(ENC2_PHASEA_PORTIN) &amp; (1&lt;&lt;ENC2_PHASEA_PIN)) == 0) ^
00198         ((inb(ENC2_PHASEB_PORTIN) &amp; (1&lt;&lt;ENC2_PHASEB_PIN)) == 0) )
00199     {
00200         EncoderState[2].<a class="code" href="structstruct__EncoderState.html#o0">position</a>++;
00201     }
00202     <span class="keywordflow">else</span>
00203     {
00204         EncoderState[2].<a class="code" href="structstruct__EncoderState.html#o0">position</a>--;
00205     }
00206 }
00207 <span class="preprocessor">#endif</span>
00208 <span class="preprocessor"></span>
00209 <span class="preprocessor">#ifdef ENC3_SIGNAL</span>
00210 <span class="preprocessor"></span><span class="comment">//! Encoder 3 interrupt handler</span>
00211 <span class="comment"></span><a class="code" href="a2d_8c.html#a10">SIGNAL</a>(ENC3_SIGNAL)
00212 {
00213     <span class="comment">// encoder has generated a pulse</span>
00214     <span class="comment">// check the relative phase of the input channels</span>
00215     <span class="comment">// and update position accordingly</span>
00216     <span class="keywordflow">if</span>( ((inb(ENC3_PHASEA_PORTIN) &amp; (1&lt;&lt;ENC3_PHASEA_PIN)) == 0) ^
00217         ((inb(ENC3_PHASEB_PORTIN) &amp; (1&lt;&lt;ENC3_PHASEB_PIN)) == 0) )
00218     {
00219         EncoderState[3].<a class="code" href="structstruct__EncoderState.html#o0">position</a>++;
00220     }
00221     <span class="keywordflow">else</span>
00222     {
00223         EncoderState[3].<a class="code" href="structstruct__EncoderState.html#o0">position</a>--;
00224     }
00225 }
00226 <span class="preprocessor">#endif</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Sun Oct 29 03:41:06 2006 for Procyon AVRlib by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.2 </small></address>
</body>
</html>
