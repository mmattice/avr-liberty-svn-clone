<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Procyon AVRlib: ata.c Source File</title>
<link href="dox.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.2 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>ata.c</h1><a href="ata_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*! \file ata.c \brief IDE-ATA hard disk interface driver. */</span>
00002 <span class="comment">//*****************************************************************************</span>
00003 <span class="comment">//</span>
00004 <span class="comment">// File Name    : 'ata.c'</span>
00005 <span class="comment">// Title        : IDE-ATA interface driver for hard disks</span>
00006 <span class="comment">// Author       : Pascal Stang</span>
00007 <span class="comment">// Date         : 11/22/2000</span>
00008 <span class="comment">// Revised      : 4/19/2003</span>
00009 <span class="comment">// Version      : 0.3</span>
00010 <span class="comment">// Target MCU   : Atmel AVR Series</span>
00011 <span class="comment">// Editor Tabs  : 4</span>
00012 <span class="comment">//</span>
00013 <span class="comment">// NOTE: This code is currently below version 1.0, and therefore is considered</span>
00014 <span class="comment">// to be lacking in some functionality or documentation, or may not be fully</span>
00015 <span class="comment">// tested.  Nonetheless, you can expect most functions to work.</span>
00016 <span class="comment">//</span>
00017 <span class="comment">// This code is distributed under the GNU Public License</span>
00018 <span class="comment">//      which can be found at http://www.gnu.org/licenses/gpl.txt</span>
00019 <span class="comment">//</span>
00020 <span class="comment">//*****************************************************************************</span>
00021 
00022 <span class="preprocessor">#ifndef WIN32</span>
00023 <span class="preprocessor"></span><span class="preprocessor">    #include &lt;avr/io.h&gt;</span>
00024 <span class="preprocessor">    #include &lt;avr/interrupt.h&gt;</span>
00025 <span class="preprocessor">    #include &lt;avr/pgmspace.h&gt;</span>
00026 <span class="comment">//  #include &lt;stdio.h&gt;</span>
00027 <span class="preprocessor">#endif</span>
00028 <span class="preprocessor"></span><span class="preprocessor">#include "<a class="code" href="global_8h.html">global.h</a>"</span>
00029 <span class="preprocessor">#include "<a class="code" href="timer_8h.html">timer.h</a>"</span>
00030 <span class="preprocessor">#include "<a class="code" href="rprintf_8h.html">rprintf.h</a>"</span>
00031 
00032 <span class="preprocessor">#include "<a class="code" href="ata_8h.html">ata.h</a>"</span>
00033 
00034 <span class="comment">//#define DEBUG_ATA 1</span>
00035 
00036 <span class="comment">// global variables</span>
00037 
00038 <span class="comment">// drive information</span>
00039 typeDriveInfo ataDriveInfo;
00040 
00041 
00042 <span class="keywordtype">void</span> ataInit(<span class="keywordtype">void</span>)
00043 {
00044 
00045 }
00046 
00047 <span class="keywordtype">void</span> ataDriveInit(<span class="keywordtype">void</span>)
00048 {
00049     u08 i;
00050     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* buffer = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*) SECTOR_BUFFER_ADDR;
00051 
00052     <span class="comment">// read drive identity</span>
00053     <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">"\r\nScanning IDE interface...\r\n"</span>);
00054     <span class="comment">// Wait for drive to be ready</span>
00055     ataStatusWait(ATA_SR_BSY, ATA_SR_BSY);
00056     <span class="comment">// issue identify command</span>
00057     ataWriteByte(ATA_REG_CMDSTATUS1, 0xEC);
00058     <span class="comment">// wait for drive to request data transfer</span>
00059     ataStatusWait(ATA_SR_DRQ, ATA_SR_DRQ);
00060     <a class="code" href="group__timer.html#ga10">timerPause</a>(200);
00061     <span class="comment">// read in the data</span>
00062     ataReadDataBuffer(buffer, 512);
00063 
00064     <span class="comment">// set local drive info parameters</span>
00065     ataDriveInfo.cylinders =        *( ((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>*) buffer) + ATA_IDENT_CYLINDERS );
00066     ataDriveInfo.heads =            *( ((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>*) buffer) + ATA_IDENT_HEADS );
00067     ataDriveInfo.sectors =          *( ((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>*) buffer) + ATA_IDENT_SECTORS );
00068     ataDriveInfo.LBAsupport =       *( ((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>*) buffer) + ATA_IDENT_FIELDVALID );
00069     ataDriveInfo.sizeinsectors =    *( (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>*) (buffer + ATA_IDENT_LBASECTORS*2) );
00070     <span class="comment">// copy model string</span>
00071     <span class="keywordflow">for</span>(i=0; i&lt;40; i+=2)
00072     {
00073         <span class="comment">// correct for byte order</span>
00074         ataDriveInfo.model[i  ] = buffer[(ATA_IDENT_MODEL*2) + i + 1];
00075         ataDriveInfo.model[i+1] = buffer[(ATA_IDENT_MODEL*2) + i    ];
00076     }
00077     <span class="comment">// terminate string</span>
00078     ataDriveInfo.model[40] = 0;
00079 
00080     <span class="comment">// process and print info</span>
00081     <span class="keywordflow">if</span>(ataDriveInfo.LBAsupport)
00082     {
00083         <span class="comment">// LBA support</span>
00084         rprintf(<span class="stringliteral">"Drive 0: %dMB "</span>, ataDriveInfo.sizeinsectors/(1000000/512) );
00085         rprintf(<span class="stringliteral">"LBA mode -- MODEL: "</span>);
00086     }
00087     <span class="keywordflow">else</span>
00088     {
00089         <span class="comment">// CHS, no LBA support</span>
00090         <span class="comment">// calculate drive size</span>
00091         ataDriveInfo.sizeinsectors = (<span class="keywordtype">unsigned</span> long) ataDriveInfo.cylinders*
00092                                                 ataDriveInfo.heads*ataDriveInfo.sectors;
00093         rprintf(<span class="stringliteral">"Drive 0: %dMB "</span>, ataDriveInfo.sizeinsectors/(1000000/512) );
00094         rprintf(<span class="stringliteral">"CHS mode C=%d H=%d S=%d -- MODEL: "</span>, ataDriveInfo.cylinders, ataDriveInfo.heads, ataDriveInfo.sectors );
00095     }
00096     <span class="comment">// print model information  </span>
00097     <a class="code" href="group__rprintf.html#ga2">rprintfStr</a>(ataDriveInfo.model); <a class="code" href="group__rprintf.html#ga5">rprintfCRLF</a>();
00098 
00099     <span class="comment">// initialize local disk parameters</span>
00100     <span class="comment">//ataDriveInfo.cylinders = ATA_DISKPARM_CLYS;</span>
00101     <span class="comment">//ataDriveInfo.heads = ATA_DISKPARM_HEADS;</span>
00102     <span class="comment">//ataDriveInfo.sectors = ATA_DISKPARM_SECTORS;</span>
00103 
00104 }
00105 
00106 <span class="keywordtype">void</span> ataDiskErr(<span class="keywordtype">void</span>)
00107 {
00108     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> b;
00109 
00110     b = ataReadByte(ATA_REG_ERROR); 
00111     <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">"ATA Error: "</span>); 
00112     <a class="code" href="group__rprintf.html#ga7">rprintfu08</a>(b); 
00113     <a class="code" href="group__rprintf.html#ga5">rprintfCRLF</a>();
00114 }
00115 
00116 <span class="keywordtype">void</span> ataSetDrivePowerMode(u08 DriveNo, u08 mode, u08 timeout)
00117 {
00118     <span class="comment">// select drive</span>
00119     ataDriveSelect(DriveNo);
00120     <span class="comment">// Wait for drive to be ready</span>
00121     ataStatusWait(ATA_SR_BSY, ATA_SR_BSY);
00122 
00123     <span class="comment">// set mode</span>
00124     <span class="keywordflow">switch</span>(mode)
00125     {
00126     <span class="keywordflow">case</span> ATA_DISKMODE_SPINDOWN:     ataWriteByte(ATA_REG_CMDSTATUS1, ATA_CMD_SPINDOWN); <span class="keywordflow">break</span>;
00127     <span class="keywordflow">case</span> ATA_DISKMODE_SPINUP:       ataWriteByte(ATA_REG_CMDSTATUS1, ATA_CMD_SPINUP); <span class="keywordflow">break</span>;
00128     <span class="keywordflow">case</span> ATA_DISKMODE_SETTIMEOUT:
00129         ataWriteByte(ATA_REG_SECCOUNT, timeout);
00130         ataWriteByte(ATA_REG_CMDSTATUS1, ATA_CMD_IDLE_5SU);
00131         <span class="keywordflow">break</span>;
00132     <span class="keywordflow">case</span> ATA_DISKMODE_SLEEP:        ataWriteByte(ATA_REG_CMDSTATUS1, ATA_CMD_SLEEP); <span class="keywordflow">break</span>;
00133     <span class="keywordflow">default</span>:
00134         <span class="keywordflow">break</span>;
00135     }
00136 }
00137 
00138 <span class="keywordtype">void</span> ataPrintSector( u08 *Buffer)
00139 {
00140     u08 i;
00141     u16 j;
00142     u08 *buf;
00143     u08 s;
00144 
00145     buf = Buffer;
00146     
00147     <span class="comment">// print the low order address indicies</span>
00148     <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">"     00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F  0123456789ABCDEF\r\n"</span>);
00149     <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">"     -----------------------------------------------  ---- ASCII -----\r\n"</span>);
00150     
00151     <span class="comment">// print the data</span>
00152     <span class="keywordflow">for</span>(j=0; j&lt;0x20; j++)
00153     {
00154         <span class="comment">// print the high order address index for this line</span>
00155         <a class="code" href="group__rprintf.html#ga8">rprintfu16</a>(j&lt;&lt;4);
00156         <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">" "</span>);
00157 
00158         <span class="comment">// print the hex data</span>
00159         <span class="keywordflow">for</span>(i=0; i&lt;0x10; i++)
00160         {
00161             <a class="code" href="group__rprintf.html#ga7">rprintfu08</a>(buf[(j&lt;&lt;4)+i]);
00162             <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">" "</span>);
00163         }
00164         
00165         <span class="comment">// leave some space</span>
00166         <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">" "</span>);
00167 
00168         <span class="comment">// print the ascii data</span>
00169         <span class="keywordflow">for</span>(i=0; i&lt;0x10; i++)
00170         {
00171             s = buf[(j&lt;&lt;4)+i]; 
00172             <span class="comment">// make sure character is printable</span>
00173             <span class="keywordflow">if</span>(s &gt;= 0x20)
00174             {
00175                 <a class="code" href="group__rprintf.html#ga1">rprintfChar</a>(s);
00176             }
00177             <span class="keywordflow">else</span>
00178             {
00179                 <a class="code" href="group__rprintf.html#ga1">rprintfChar</a>(0x20);
00180             }
00181 
00182         }
00183         <a class="code" href="group__rprintf.html#ga5">rprintfCRLF</a>();
00184     }
00185 }
00186 
00187 <span class="keywordtype">void</span> ataReadDataBuffer(u08 *Buffer, u16 numBytes)
00188 {
00189     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;
00190 
00191     <span class="comment">//sbi(MCUCR, SRW);          // enable RAM waitstate</span>
00192 
00193     <span class="comment">// read data from drive</span>
00194     <span class="keywordflow">for</span> (i=0; i&lt;(numBytes/16); i++)
00195     {
00196         <span class="comment">// optimize by reading 16 bytes in-line before looping</span>
00197         *Buffer++ = *((<span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*) ATA_REG_BASE + ATA_REG_DATAL);
00198         *Buffer++ = *((<span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*) ATA_REG_BASE + ATA_REG_DATAH);
00199         *Buffer++ = *((<span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*) ATA_REG_BASE + ATA_REG_DATAL);
00200         *Buffer++ = *((<span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*) ATA_REG_BASE + ATA_REG_DATAH);
00201         *Buffer++ = *((<span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*) ATA_REG_BASE + ATA_REG_DATAL);
00202         *Buffer++ = *((<span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*) ATA_REG_BASE + ATA_REG_DATAH);
00203         *Buffer++ = *((<span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*) ATA_REG_BASE + ATA_REG_DATAL);
00204         *Buffer++ = *((<span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*) ATA_REG_BASE + ATA_REG_DATAH);
00205         *Buffer++ = *((<span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*) ATA_REG_BASE + ATA_REG_DATAL);
00206         *Buffer++ = *((<span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*) ATA_REG_BASE + ATA_REG_DATAH);
00207         *Buffer++ = *((<span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*) ATA_REG_BASE + ATA_REG_DATAL);
00208         *Buffer++ = *((<span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*) ATA_REG_BASE + ATA_REG_DATAH);
00209         *Buffer++ = *((<span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*) ATA_REG_BASE + ATA_REG_DATAL);
00210         *Buffer++ = *((<span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*) ATA_REG_BASE + ATA_REG_DATAH);
00211         *Buffer++ = *((<span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*) ATA_REG_BASE + ATA_REG_DATAL);
00212         *Buffer++ = *((<span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*) ATA_REG_BASE + ATA_REG_DATAH);
00213     }
00214     <span class="comment">//cbi(MCUCR, SRW);          // disable RAM waitstate</span>
00215     
00216 }
00217 
00218 <span class="keywordtype">void</span> ataWriteDataBuffer(u08 *Buffer, u16 numBytes)
00219 {
00220     <span class="keyword">register</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> temp;
00221     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;
00222 
00223     <span class="comment">//sbi(MCUCR, SRW);          // enable RAM waitstate</span>
00224 
00225     <span class="comment">// write data to drive</span>
00226     <span class="keywordflow">for</span> (i=0; i&lt;(numBytes/16); i++)     
00227     {
00228         <span class="comment">// optimize by writing 16 bytes in-line before looping</span>
00229         <span class="comment">// keep byte order correct by using temp register</span>
00230         temp = *Buffer++;
00231         *((<span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*) ATA_REG_BASE + ATA_REG_DATAH) = *Buffer++;
00232         *((<span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*) ATA_REG_BASE + ATA_REG_DATAL) = temp;
00233         temp = *Buffer++;
00234         *((<span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*) ATA_REG_BASE + ATA_REG_DATAH) = *Buffer++;
00235         *((<span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*) ATA_REG_BASE + ATA_REG_DATAL) = temp;
00236         temp = *Buffer++;
00237         *((<span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*) ATA_REG_BASE + ATA_REG_DATAH) = *Buffer++;
00238         *((<span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*) ATA_REG_BASE + ATA_REG_DATAL) = temp;
00239         temp = *Buffer++;
00240         *((<span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*) ATA_REG_BASE + ATA_REG_DATAH) = *Buffer++;
00241         *((<span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*) ATA_REG_BASE + ATA_REG_DATAL) = temp;
00242         temp = *Buffer++;
00243         *((<span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*) ATA_REG_BASE + ATA_REG_DATAH) = *Buffer++;
00244         *((<span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*) ATA_REG_BASE + ATA_REG_DATAL) = temp;
00245         temp = *Buffer++;
00246         *((<span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*) ATA_REG_BASE + ATA_REG_DATAH) = *Buffer++;
00247         *((<span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*) ATA_REG_BASE + ATA_REG_DATAL) = temp;
00248         temp = *Buffer++;
00249         *((<span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*) ATA_REG_BASE + ATA_REG_DATAH) = *Buffer++;
00250         *((<span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*) ATA_REG_BASE + ATA_REG_DATAL) = temp;
00251         temp = *Buffer++;
00252         *((<span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*) ATA_REG_BASE + ATA_REG_DATAH) = *Buffer++;
00253         *((<span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*) ATA_REG_BASE + ATA_REG_DATAL) = temp;
00254     }
00255     <span class="comment">//cbi(MCUCR, SRW);          // disable RAM waitstate</span>
00256 
00257 }
00258 
00259 u08 ataStatusWait(u08 mask, u08 waitStatus)
00260 {
00261     <span class="keyword">register</span> u08 status;
00262 
00263     delay(100);
00264 
00265     <span class="comment">// wait for desired status</span>
00266     <span class="keywordflow">while</span>( ((status = ataReadByte(ATA_REG_CMDSTATUS1)) &amp; mask) == waitStatus );
00267 
00268     <span class="keywordflow">return</span> status;
00269 }
00270 
00271 
00272 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> ataReadSectorsCHS(    <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> Drive, 
00273                                             <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> Head, 
00274                                             <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> Track,
00275                                             <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> Sector,
00276                                             <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numsectors,
00277                                             <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *Buffer)
00278 {
00279     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> temp;
00280 
00281     <span class="comment">// Wait for drive to be ready</span>
00282     temp = ataStatusWait(ATA_SR_BSY, ATA_SR_BSY);
00283 
00284     <span class="comment">// Prepare parameters...</span>
00285     ataWriteByte(ATA_REG_HDDEVSEL, 0xA0+(Drive ? 0x10:00)+Head); <span class="comment">// CHS mode/Drive/Head</span>
00286     ataWriteByte(ATA_REG_CYLHI, Track&gt;&gt;8);          <span class="comment">// MSB of track</span>
00287     ataWriteByte(ATA_REG_CYLLO, Track);             <span class="comment">// LSB of track</span>
00288     ataWriteByte(ATA_REG_STARTSEC, Sector);     <span class="comment">// sector</span>
00289     ataWriteByte(ATA_REG_SECCOUNT, numsectors); <span class="comment">// # of sectors</span>
00290 
00291     <span class="comment">// Issue read sector command...</span>
00292     ataWriteByte(ATA_REG_CMDSTATUS1, 0x21);
00293 
00294     <span class="comment">// Wait for drive to be ready</span>
00295     temp = ataStatusWait(ATA_SR_BSY, ATA_SR_BSY);
00296 
00297     <span class="keywordflow">if</span> (temp &amp; ATA_SR_ERR)
00298     {
00299         <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">"RD ERR\r\n"</span>);
00300         <span class="keywordflow">return</span> 1;
00301     }
00302 
00303     <span class="comment">// Wait for drive to request data transfer</span>
00304     ataStatusWait(ATA_SR_DRQ, 0);
00305 
00306     <span class="comment">// read data from drive</span>
00307     ataReadDataBuffer(Buffer, 512*numsectors);
00308 
00309     <span class="comment">// Return the error bit from the status register...</span>
00310     temp = ataReadByte(ATA_REG_CMDSTATUS1); <span class="comment">// read status register</span>
00311 
00312     <span class="keywordflow">return</span> (temp &amp; ATA_SR_ERR) ? 1:0;
00313 }
00314 
00315 
00316 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> ataWriteSectorsCHS(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> Drive, 
00317                                             <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> Head, 
00318                                             <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> Track,
00319                                             <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> Sector,
00320                                             <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numsectors,
00321                                             <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *Buffer)
00322 {
00323     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> temp;
00324 
00325     <span class="comment">// Wait for drive to be ready</span>
00326     temp = ataStatusWait(ATA_SR_BSY, ATA_SR_BSY);
00327 
00328     <span class="comment">// Prepare parameters...</span>
00329     ataWriteByte(ATA_REG_HDDEVSEL, 0xA0+(Drive ? 0x10:00)+Head); <span class="comment">// CHS mode/Drive/Head</span>
00330     ataWriteByte(ATA_REG_CYLHI, Track&gt;&gt;8);          <span class="comment">// MSB of track</span>
00331     ataWriteByte(ATA_REG_CYLLO, Track);             <span class="comment">// LSB of track</span>
00332     ataWriteByte(ATA_REG_STARTSEC, Sector);     <span class="comment">// sector</span>
00333     ataWriteByte(ATA_REG_SECCOUNT, numsectors); <span class="comment">// # of sectors</span>
00334 
00335     <span class="comment">// Issue write sector command</span>
00336     ataWriteByte(ATA_REG_CMDSTATUS1, 0x31);
00337 
00338     <span class="comment">//delay(100);</span>
00339 
00340     <span class="comment">// Wait for drive to request data transfer</span>
00341     ataStatusWait(ATA_SR_DRQ, 0);
00342 
00343     <span class="comment">// write data to drive</span>
00344     ataWriteDataBuffer(Buffer, 512*numsectors);
00345     
00346     <span class="comment">// Wait for drive to finish write</span>
00347     temp = ataStatusWait(ATA_SR_BSY, ATA_SR_BSY);
00348 
00349     <span class="comment">// check for errors</span>
00350     <span class="keywordflow">if</span> (temp &amp; ATA_SR_ERR)
00351     {
00352         <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">"WR ERR\r\n"</span>);
00353         <span class="keywordflow">return</span> 1;
00354     }
00355 
00356     <span class="comment">// Return the error bit from the status register...</span>
00357     <span class="keywordflow">return</span> (temp &amp; ATA_SR_ERR) ? 1:0;
00358 }
00359 
00360 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> ataReadSectorsLBA(    <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> Drive, 
00361                                             <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> lba,
00362                                             <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numsectors,
00363                                     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *Buffer)
00364 {
00365     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cyl, head, sect;
00366     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> temp;
00367 
00368 <span class="preprocessor">#ifdef DEBUG_ATA</span>
00369 <span class="preprocessor"></span>    <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">"ATA LBA read "</span>);
00370     <a class="code" href="group__rprintf.html#ga9">rprintfu32</a>(lba); <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">" "</span>);
00371     <a class="code" href="group__rprintf.html#ga8">rprintfu16</a>(numsectors); <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">" "</span>);
00372     <a class="code" href="group__rprintf.html#ga8">rprintfu16</a>((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)Buffer); 
00373     <a class="code" href="group__rprintf.html#ga5">rprintfCRLF</a>();
00374 <span class="preprocessor">#endif</span>
00375 <span class="preprocessor"></span>
00376     sect = (int) ( lba &amp; 0x000000ffL );
00377     lba = lba &gt;&gt; 8;
00378     cyl = (int) ( lba &amp; 0x0000ffff );
00379     lba = lba &gt;&gt; 16;
00380     head = ( (int) ( lba &amp; 0x0fL ) ) | ATA_HEAD_USE_LBA;
00381 
00382     temp = ataReadSectorsCHS( Drive, head, cyl, sect, numsectors, Buffer );
00383 
00384     <span class="keywordflow">if</span>(temp)
00385         ataDiskErr();
00386     <span class="keywordflow">return</span> temp;
00387 }
00388 
00389 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> ataWriteSectorsLBA(   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> Drive, 
00390                                                 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> lba,
00391                                                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numsectors,
00392                                         <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *Buffer)
00393 {
00394     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cyl, head, sect;
00395     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> temp;
00396 
00397 <span class="preprocessor">#ifdef DEBUG_ATA</span>
00398 <span class="preprocessor"></span>    <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">"ATA LBA write "</span>);
00399     <a class="code" href="group__rprintf.html#ga9">rprintfu32</a>(lba); <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">" "</span>);
00400     <a class="code" href="group__rprintf.html#ga8">rprintfu16</a>(numsectors); <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">" "</span>);
00401     <a class="code" href="group__rprintf.html#ga8">rprintfu16</a>((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)Buffer); 
00402     <a class="code" href="group__rprintf.html#ga5">rprintfCRLF</a>();
00403 <span class="preprocessor">#endif</span>
00404 <span class="preprocessor"></span>
00405     sect = (int) ( lba &amp; 0x000000ffL );
00406     lba = lba &gt;&gt; 8;
00407     cyl = (int) ( lba &amp; 0x0000ffff );
00408     lba = lba &gt;&gt; 16;
00409     head = ( (int) ( lba &amp; 0x0fL ) ) | ATA_HEAD_USE_LBA;
00410 
00411     temp = ataWriteSectorsCHS( Drive, head, cyl, sect, numsectors, Buffer );
00412 
00413     <span class="keywordflow">if</span>(temp)
00414         ataDiskErr();
00415     <span class="keywordflow">return</span> temp;
00416 }                                   
00417 
00418 
00419 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> ataReadSectors(   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> Drive, 
00420                                         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> lba,
00421                                         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numsectors,
00422                                 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *Buffer)
00423 {
00424     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cyl, head, sect;
00425     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> temp;
00426 
00427     <span class="comment">// check if drive supports native LBA mode</span>
00428     <span class="keywordflow">if</span>(ataDriveInfo.LBAsupport)
00429     {
00430         <span class="comment">// drive supports using native LBA</span>
00431         temp = ataReadSectorsLBA(Drive, lba, numsectors, Buffer);
00432     }
00433     <span class="keywordflow">else</span>
00434     {
00435         <span class="comment">// drive required CHS access</span>
00436 <span class="preprocessor">        #ifdef DEBUG_ATA</span>
00437 <span class="preprocessor"></span>            <span class="comment">// do this defore destroying lba</span>
00438             <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">"ATA LBA for CHS read: "</span>);
00439             <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">"LBA="</span>); <a class="code" href="group__rprintf.html#ga9">rprintfu32</a>(lba); <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">" "</span>);
00440 <span class="preprocessor">        #endif</span>
00441 <span class="preprocessor"></span>
00442         <span class="comment">// convert LBA to pseudo CHS</span>
00443         <span class="comment">// remember to offset the sector count by one</span>
00444         sect = (u08) (lba % ataDriveInfo.sectors)+1;
00445         lba = lba / ataDriveInfo.sectors;
00446         head = (u08) (lba % ataDriveInfo.heads);
00447         lba = lba / ataDriveInfo.heads;
00448         cyl = (u16) lba;
00449 
00450 <span class="preprocessor">        #ifdef DEBUG_ATA</span>
00451 <span class="preprocessor"></span>            <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">"C:H:S="</span>);
00452             <a class="code" href="group__rprintf.html#ga8">rprintfu16</a>(cyl); <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">":"</span>);
00453             <a class="code" href="group__rprintf.html#ga7">rprintfu08</a>(head); <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">":"</span>);
00454             <a class="code" href="group__rprintf.html#ga7">rprintfu08</a>(sect); <a class="code" href="group__rprintf.html#ga5">rprintfCRLF</a>();
00455 <span class="preprocessor">        #endif</span>
00456 <span class="preprocessor"></span>
00457         temp = ataReadSectorsCHS( Drive, head, cyl, sect, numsectors, Buffer );
00458     }
00459 
00460     <span class="keywordflow">if</span>(temp)
00461         ataDiskErr();
00462     <span class="keywordflow">return</span> temp;
00463 }
00464 
00465 
00466 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> ataWriteSectors(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> Drive, 
00467                                         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> lba,
00468                                         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numsectors,
00469                                 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *Buffer)
00470 {
00471     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cyl, head, sect;
00472     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> temp;
00473 
00474     <span class="comment">// check if drive supports native LBA mode</span>
00475     <span class="keywordflow">if</span>(ataDriveInfo.LBAsupport)
00476     {
00477         <span class="comment">// drive supports using native LBA</span>
00478         temp = ataWriteSectorsLBA(Drive, lba, numsectors, Buffer);
00479     }
00480     <span class="keywordflow">else</span>
00481     {
00482         <span class="comment">// drive required CHS access</span>
00483 <span class="preprocessor">        #ifdef DEBUG_ATA</span>
00484 <span class="preprocessor"></span>            <span class="comment">// do this defore destroying lba</span>
00485             <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">"ATA LBA for CHS write: "</span>);
00486             <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">"LBA="</span>); <a class="code" href="group__rprintf.html#ga9">rprintfu32</a>(lba); <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">" "</span>);
00487 <span class="preprocessor">        #endif</span>
00488 <span class="preprocessor"></span>
00489         <span class="comment">// convert LBA to pseudo CHS</span>
00490         <span class="comment">// remember to offset the sector count by one</span>
00491         sect = (u08) (lba % ataDriveInfo.sectors)+1;
00492         lba = lba / ataDriveInfo.sectors;
00493         head = (u08) (lba % ataDriveInfo.heads);
00494         lba = lba / ataDriveInfo.heads;
00495         cyl = (u16) lba;
00496 
00497 <span class="preprocessor">        #ifdef DEBUG_ATA</span>
00498 <span class="preprocessor"></span>            <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">"C:H:S="</span>);
00499             <a class="code" href="group__rprintf.html#ga8">rprintfu16</a>(cyl); <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">":"</span>);
00500             <a class="code" href="group__rprintf.html#ga7">rprintfu08</a>(head); <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">":"</span>);
00501             <a class="code" href="group__rprintf.html#ga7">rprintfu08</a>(sect); <a class="code" href="group__rprintf.html#ga5">rprintfCRLF</a>();
00502 <span class="preprocessor">        #endif</span>
00503 <span class="preprocessor"></span>
00504         temp = ataWriteSectorsCHS( Drive, head, cyl, sect, numsectors, Buffer );
00505     }
00506 
00507     <span class="keywordflow">if</span>(temp)
00508         ataDiskErr();
00509     <span class="keywordflow">return</span> temp;
00510 }                                   
00511 
00512 <span class="keywordtype">void</span> ataDriveSelect(u08 DriveNo)
00513 {
00514     ataWriteByte(ATA_REG_HDDEVSEL, 0xA0+(DriveNo ? 0x10:00)); <span class="comment">// Drive selection</span>
00515 }
00516  
00517 <span class="comment">//----------------------------------------------------------------------------</span>
00518 <span class="comment">// Set drive mode (STANDBY, IDLE)</span>
00519 <span class="comment">//----------------------------------------------------------------------------</span>
00520 <span class="comment">/*#define STANDBY 0</span>
00521 <span class="comment">#define IDLE    1</span>
00522 <span class="comment">#define SLEEP   2 </span>
00523 <span class="comment">*/</span> 
00524 
00525 <span class="comment">/*</span>
00526 <span class="comment">unsigned char SetMode(unsigned char DriveNo, unsigned char Mode, unsigned char PwrDown) </span>
00527 <span class="comment">{</span>
00528 <span class="comment">  WriteBYTE(CMD, 6, 0xA0 + (DriveNo ? 0x10:0x00)); // Select drive</span>
00529 <span class="comment">  WriteBYTE(CMD, 2, (PwrDown ? 0x01:0x00)); // Enable automatic power down</span>
00530 <span class="comment">  switch (Mode) </span>
00531 <span class="comment">  {</span>
00532 <span class="comment">    case STANDBY: WriteBYTE(CMD,7, 0xE2); break;</span>
00533 <span class="comment">    case IDLE:    WriteBYTE(CMD,7, 0xE3); break;</span>
00534 <span class="comment">    // NOTE: To recover from sleep, either issue a soft or hardware reset !</span>
00535 <span class="comment">    // (But not on all drives, f.ex seagate ST3655A it's not nessecary to reset</span>
00536 <span class="comment">    // but only to go in Idle mode, But on a Conner CFA170A it's nessecary with</span>
00537 <span class="comment">    // a reset)</span>
00538 <span class="comment">    case SLEEP:   WriteBYTE(CMD,7, 0xE6); break;</span>
00539 <span class="comment">  }</span>
00540 <span class="comment">  Timer10mSec=10000;</span>
00541 <span class="comment">  while ((ReadBYTE(CMD,7) &amp; 0xC0)!=0x40 &amp;&amp; Timer10mSec); // Wait for DRDY &amp; NOT BUSY </span>
00542 <span class="comment">  if (Timer10mSec==0) return 0xFF;                       //   or timeout</span>
00543 <span class="comment"> </span>
00544 <span class="comment">  // Return the error register...</span>
00545 <span class="comment">  return ReadBYTE(CMD, 1);</span>
00546 <span class="comment">}</span>
00547 <span class="comment"></span>
00548 <span class="comment">*/</span>
00549 
00550 u08 ataReadByte(u08 reg)
00551 {
00552     <span class="keyword">register</span> u08 ret;
00553     <span class="comment">//sbi(MCUCR, SRW);          // enable RAM waitstate</span>
00554     ret = *((<span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*) ATA_REG_BASE + reg);
00555     <span class="comment">//cbi(MCUCR, SRW);          // disable RAM waitstate</span>
00556     <span class="keywordflow">return</span> ret;
00557 }
00558 
00559 <span class="keywordtype">void</span> ataWriteByte(u08 reg, u08 data)
00560 {
00561     <span class="comment">//sbi(MCUCR, SRW);          // enable RAM waitstate</span>
00562     *((<span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*) ATA_REG_BASE + reg) = data;
00563     <span class="comment">//cbi(MCUCR, SRW);          // disable RAM waitstate</span>
00564 }
00565 
00566  
00567 <span class="keywordtype">void</span> ataShowRegisters(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> DriveNo) 
00568 { 
00569     ataWriteByte(ATA_REG_HDDEVSEL, 0xA0 + (DriveNo ? 0x10:0x00)); <span class="comment">// Select drive</span>
00570     
00571     <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">"R0: DATALOW  = 0x"</span>);   <a class="code" href="group__rprintf.html#ga7">rprintfu08</a>(ataReadByte(ATA_REG_DATAL    ));     <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">" \r\n"</span>);
00572     <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">"R1: ERROR    = 0x"</span>);   <a class="code" href="group__rprintf.html#ga7">rprintfu08</a>(ataReadByte(ATA_REG_ERROR    ));     <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">" \r\n"</span>);
00573     <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">"R2: SECT CNT = 0x"</span>);   <a class="code" href="group__rprintf.html#ga7">rprintfu08</a>(ataReadByte(ATA_REG_SECCOUNT));      <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">" \r\n"</span>);
00574     <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">"R3: SECT NUM = 0x"</span>);   <a class="code" href="group__rprintf.html#ga7">rprintfu08</a>(ataReadByte(ATA_REG_STARTSEC));      <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">" \r\n"</span>);
00575     <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">"R4: CYL LOW  = 0x"</span>);   <a class="code" href="group__rprintf.html#ga7">rprintfu08</a>(ataReadByte(ATA_REG_CYLLO    ));     <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">" \r\n"</span>);
00576     <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">"R5: CYL HIGH = 0x"</span>);   <a class="code" href="group__rprintf.html#ga7">rprintfu08</a>(ataReadByte(ATA_REG_CYLHI    ));     <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">" \r\n"</span>);
00577     <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">"R6: HEAD/DEV = 0x"</span>);   <a class="code" href="group__rprintf.html#ga7">rprintfu08</a>(ataReadByte(ATA_REG_HDDEVSEL));      <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">" \r\n"</span>);
00578     <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">"R7: CMD/STA  = 0x"</span>);   <a class="code" href="group__rprintf.html#ga7">rprintfu08</a>(ataReadByte(ATA_REG_CMDSTATUS1));    <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">"\r\n"</span>);
00579 } 
00580 
00581 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> ataSWReset(<span class="keywordtype">void</span>)
00582 {
00583     ataWriteByte(ATA_REG_HDDEVSEL, 0x06);   <span class="comment">// SRST and nIEN bits</span>
00584     delay(10);  <span class="comment">// 10uS delay</span>
00585     ataWriteByte(ATA_REG_HDDEVSEL, 0x02);   <span class="comment">// nIEN bits</span>
00586     delay(10);  <span class="comment">// 10 uS delay</span>
00587    
00588    <span class="keywordflow">while</span>( (ataReadByte(ATA_REG_CMDSTATUS1) &amp; 0xC0) != 0x40 ); <span class="comment">// Wait for DRDY and not BSY</span>
00589     
00590     <span class="keywordflow">return</span> ataReadByte(ATA_REG_CMDSTATUS1) + ataReadByte(ATA_REG_ERROR);
00591 }
00592 
00593 <span class="comment">/*</span>
00594 <span class="comment">unsigned char ATA_Idle(unsigned char Drive)</span>
00595 <span class="comment">{</span>
00596 <span class="comment"></span>
00597 <span class="comment">  WriteBYTE(CMD, 6, 0xA0 + (Drive ? 0x10:0x00)); // Select drive</span>
00598 <span class="comment">  WriteBYTE(CMD,7, 0xE1);</span>
00599 <span class="comment"></span>
00600 <span class="comment">  while ((ReadBYTE(CMD,7) &amp; 0xC0)!=0x40); // Wait for DRDY &amp; NOT BUSY </span>
00601 <span class="comment"></span>
00602 <span class="comment">  // Return the error register...</span>
00603 <span class="comment">  return ReadBYTE(CMD, 1);</span>
00604 <span class="comment">}</span>
00605 <span class="comment">*/</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Sun Oct 29 03:41:06 2006 for Procyon AVRlib by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.2 </small></address>
</body>
</html>
