<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Procyon AVRlib: servo.c Source File</title>
<link href="dox.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.2 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>servo.c</h1><a href="servo_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*! \file servo.c \brief Interrupt-driven RC Servo function library. */</span>
00002 <span class="comment">//*****************************************************************************</span>
00003 <span class="comment">//</span>
00004 <span class="comment">// File Name    : 'servo.c'</span>
00005 <span class="comment">// Title        : Interrupt-driven RC Servo function library</span>
00006 <span class="comment">// Author       : Pascal Stang - Copyright (C) 2002</span>
00007 <span class="comment">// Created      : 7/31/2002</span>
00008 <span class="comment">// Revised      : 8/02/2002</span>
00009 <span class="comment">// Version      : 1.0</span>
00010 <span class="comment">// Target MCU   : Atmel AVR Series</span>
00011 <span class="comment">// Editor Tabs  : 4</span>
00012 <span class="comment">//</span>
00013 <span class="comment">// This code is distributed under the GNU Public License</span>
00014 <span class="comment">//      which can be found at http://www.gnu.org/licenses/gpl.txt</span>
00015 <span class="comment">//</span>
00016 <span class="comment">//*****************************************************************************</span>
00017 
00018 <span class="preprocessor">#ifndef WIN32</span>
00019 <span class="preprocessor"></span><span class="preprocessor">    #include &lt;avr/io.h&gt;</span>
00020 <span class="preprocessor">#endif</span>
00021 <span class="preprocessor"></span>
00022 <span class="preprocessor">#include "<a class="code" href="global_8h.html">global.h</a>"</span>
00023 <span class="preprocessor">#include "<a class="code" href="servo_8h.html">servo.h</a>"</span>
00024 
00025 <span class="comment">// Program ROM constants</span>
00026 
00027 <span class="comment">// Global variables</span>
00028 <span class="comment">// servo channel registers</span>
00029 u16 ServoPosTics;
00030 u16 ServoPeriodTics;
00031 u08 ServoChannel;
00032 ServoChannelType ServoChannels[SERVO_NUM_CHANNELS];
00033 
00034 <span class="comment">// functions</span>
00035 <span class="comment"></span>
00036 <span class="comment">//! initializes software PWM system</span>
<a name="l00037"></a><a class="code" href="servo_8h.html#a1">00037</a> <span class="comment"></span><span class="keywordtype">void</span> <a class="code" href="servo_8c.html#a4">servoInit</a>(<span class="keywordtype">void</span>)
00038 {
00039     u08 channel;
00040     <span class="comment">// disble the timer1 output compare A interrupt</span>
00041     cbi(TIMSK, OCIE1A);
00042     <span class="comment">// set the prescaler for timer1</span>
00043     <a class="code" href="group__timer.html#ga6">timer1SetPrescaler</a>(<a class="code" href="group__timer.html#ga19">TIMER_CLK_DIV256</a>);
00044     <span class="comment">// attach the software PWM service routine to timer1 output compare A</span>
00045     <a class="code" href="group__timer.html#ga8">timerAttach</a>(TIMER1OUTCOMPAREA_INT, servoService);
00046     <span class="comment">// enable and clear channels</span>
00047     <span class="keywordflow">for</span>(channel=0; channel&lt;SERVO_NUM_CHANNELS; channel++)
00048     {
00049         <span class="comment">// set minimum position as default</span>
00050         ServoChannels[channel].duty = SERVO_MIN;
00051         <span class="comment">// set default port and pins assignments</span>
00052         ServoChannels[channel].port = _SFR_IO_ADDR(SERVO_DEFAULT_PORT);
00053         <span class="comment">//ServoChannels[channel].port = (unsigned char)&amp;SERVO_DEFAULT_PORT;</span>
00054         ServoChannels[channel].pin = (1&lt;&lt;channel);
00055         <span class="comment">// set channel pin to output</span>
00056         <span class="comment">// THIS IS OBSOLETED BY THE DYNAMIC CHANNEL TO PORT,PIN ASSIGNMENTS</span>
00057         <span class="comment">//outb(SERVODDR, inb(SERVODDR) | (1&lt;&lt;channel));</span>
00058     }
00059     <span class="comment">// set PosTics</span>
00060     ServoPosTics = 0;
00061     <span class="comment">// set PeriodTics</span>
00062     ServoPeriodTics = SERVO_MAX*9;
00063     <span class="comment">// set initial interrupt time</span>
00064     u16 OCValue;
00065     <span class="comment">// read in current value of output compare register OCR1A</span>
00066     OCValue =  inb(OCR1AL);     <span class="comment">// read low byte of OCR1A</span>
00067     OCValue += inb(OCR1AH)&lt;&lt;8;  <span class="comment">// read high byte of OCR1A</span>
00068     <span class="comment">// increment OCR1A value by nextTics</span>
00069     OCValue += ServoPeriodTics; 
00070     <span class="comment">// set future output compare time to this new value</span>
00071     outb(OCR1AH, (OCValue&gt;&gt;8));         <span class="comment">// write high byte</span>
00072     outb(OCR1AL, (OCValue &amp; 0x00FF));   <span class="comment">// write low byte</span>
00073     <span class="comment">// enable the timer1 output compare A interrupt</span>
00074     sbi(TIMSK, OCIE1A);
00075 }
00076 <span class="comment"></span>
00077 <span class="comment">//! turns off software PWM system</span>
<a name="l00078"></a><a class="code" href="servo_8h.html#a2">00078</a> <span class="comment"></span><span class="keywordtype">void</span> <a class="code" href="servo_8c.html#a5">servoOff</a>(<span class="keywordtype">void</span>)
00079 {
00080     <span class="comment">// disable the timer1 output compare A interrupt</span>
00081     cbi(TIMSK, OCIE1A);
00082     <span class="comment">// detach the service routine</span>
00083     <a class="code" href="group__timer.html#ga9">timerDetach</a>(TIMER1OUTCOMPAREA_INT);
00084 }
00085 <span class="comment"></span>
00086 <span class="comment">//! set port and I/O pin for channel</span>
<a name="l00087"></a><a class="code" href="servo_8h.html#a3">00087</a> <span class="comment"></span><span class="keywordtype">void</span> <a class="code" href="servo_8c.html#a6">servoSetChannelIO</a>(u08 channel, u08 port, u08 pin)
00088 {
00089     ServoChannels[channel].port = port;
00090     ServoChannels[channel].pin = (1&lt;&lt;(pin&amp;0x07));
00091 }
00092 <span class="comment"></span>
00093 <span class="comment">//! set servo position on channel</span>
<a name="l00094"></a><a class="code" href="servo_8h.html#a4">00094</a> <span class="comment"></span><span class="keywordtype">void</span> <a class="code" href="servo_8c.html#a7">servoSetPosition</a>(u08 channel, u08 position)
00095 {
00096     <span class="comment">// input should be between 0 and SERVO_POSITION_MAX</span>
00097     u16 pos_scaled;
00098     <span class="comment">// calculate scaled position</span>
00099     pos_scaled = ((u16)position*(SERVO_MAX-SERVO_MIN)/SERVO_POSITION_MAX)+SERVO_MIN;
00100     <span class="comment">// set position</span>
00101     <a class="code" href="servo_8c.html#a9">servoSetPositionRaw</a>(channel, pos_scaled);
00102 }
00103 <span class="comment"></span>
00104 <span class="comment">//! get servo position on channel</span>
<a name="l00105"></a><a class="code" href="servo_8h.html#a5">00105</a> <span class="comment"></span>u08 <a class="code" href="servo_8c.html#a8">servoGetPosition</a>(u08 channel)
00106 {
00107     <span class="keywordflow">return</span> (u08)( ((<a class="code" href="servo_8c.html#a10">servoGetPositionRaw</a>(channel)-SERVO_MIN)*SERVO_POSITION_MAX)/(SERVO_MAX-SERVO_MIN) );
00108 }
00109 <span class="comment"></span>
00110 <span class="comment">//! set servo position on channel (raw unscaled format)</span>
<a name="l00111"></a><a class="code" href="servo_8h.html#a6">00111</a> <span class="comment"></span><span class="keywordtype">void</span> <a class="code" href="servo_8c.html#a9">servoSetPositionRaw</a>(u08 channel, u16 position)
00112 {
00113     <span class="comment">// bind to limits</span>
00114     position = MAX(position, SERVO_MIN);
00115     position = MIN(position, SERVO_MAX);
00116     <span class="comment">// set position</span>
00117     ServoChannels[channel].duty = position;
00118 }
00119 <span class="comment"></span>
00120 <span class="comment">//! get servo position on channel (raw unscaled format)</span>
<a name="l00121"></a><a class="code" href="servo_8h.html#a7">00121</a> <span class="comment"></span>u16 <a class="code" href="servo_8c.html#a10">servoGetPositionRaw</a>(u08 channel)
00122 {
00123     <span class="keywordflow">return</span> ServoChannels[channel].duty;
00124 }
00125 
00126 <span class="keywordtype">void</span> servoService(<span class="keywordtype">void</span>)
00127 {
00128     u16 nextTics;
00129 
00130     <span class="keywordflow">if</span>(ServoChannel &lt; SERVO_NUM_CHANNELS)
00131     {
00132         <span class="comment">// turn off current channel</span>
00133         outb(_SFR_IO8(ServoChannels[ServoChannel].port), inb(_SFR_IO8(ServoChannels[ServoChannel].port)) &amp; ~(ServoChannels[ServoChannel].pin));
00134     }
00135     
00136     <span class="comment">// next channel</span>
00137     ServoChannel++;
00138 
00139     <span class="keywordflow">if</span>(ServoChannel != SERVO_NUM_CHANNELS)
00140     {
00141         <span class="comment">// loop to channel 0 if needed</span>
00142         <span class="keywordflow">if</span>(ServoChannel &gt; SERVO_NUM_CHANNELS)   ServoChannel = 0;
00143         <span class="comment">// turn on new channel</span>
00144         outb(_SFR_IO8(ServoChannels[ServoChannel].port), inb(_SFR_IO8(ServoChannels[ServoChannel].port)) | (ServoChannels[ServoChannel].pin));
00145         <span class="comment">// schedule turn off time</span>
00146         nextTics = ServoChannels[ServoChannel].duty;
00147     }
00148     <span class="keywordflow">else</span> <span class="comment">//(Channel == SERVO_NUM_CHANNELS)</span>
00149     {
00150         <span class="comment">// ***we could save time by precalculating this</span>
00151         <span class="comment">// schedule end-of-period</span>
00152         nextTics = ServoPeriodTics-ServoPosTics;
00153     }
00154 
00155     <span class="comment">// schedule next interrupt</span>
00156     u16 OCValue;
00157     <span class="comment">// read in current value of output compare register OCR1A</span>
00158     OCValue =  inb(OCR1AL);     <span class="comment">// read low byte of OCR1A</span>
00159     OCValue += inb(OCR1AH)&lt;&lt;8;  <span class="comment">// read high byte of OCR1A</span>
00160     <span class="comment">// increment OCR1A value by nextTics</span>
00161     OCValue += nextTics;
00162 <span class="comment">//  OCR1A+=nextTics;</span>
00163     <span class="comment">// set future output compare time to this new value</span>
00164     outb(OCR1AH, (OCValue&gt;&gt;8));         <span class="comment">// write high byte</span>
00165     outb(OCR1AL, (OCValue &amp; 0x00FF));   <span class="comment">// write low byte</span>
00166     <span class="comment">// set our new tic position</span>
00167     ServoPosTics += nextTics;
00168     <span class="keywordflow">if</span>(ServoPosTics &gt;= ServoPeriodTics) ServoPosTics = 0;
00169 }
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Sun Oct 29 03:41:07 2006 for Procyon AVRlib by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.2 </small></address>
</body>
</html>
