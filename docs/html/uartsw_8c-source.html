<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Procyon AVRlib: uartsw.c Source File</title>
<link href="dox.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.2 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>uartsw.c</h1><a href="uartsw_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*! \file uartsw.c \brief Software Interrupt-driven UART Driver. */</span>
00002 <span class="comment">//*****************************************************************************</span>
00003 <span class="comment">//</span>
00004 <span class="comment">// File Name    : 'uartsw.c'</span>
00005 <span class="comment">// Title        : Software Interrupt-driven UART Driver</span>
00006 <span class="comment">// Author       : Pascal Stang - Copyright (C) 2002-2004</span>
00007 <span class="comment">// Created      : 7/20/2002</span>
00008 <span class="comment">// Revised      : 4/27/2004</span>
00009 <span class="comment">// Version      : 0.1</span>
00010 <span class="comment">// Target MCU   : Atmel AVR Series (intended for the ATmega16 and ATmega32)</span>
00011 <span class="comment">// Editor Tabs  : 4</span>
00012 <span class="comment">//</span>
00013 <span class="comment">// This code is distributed under the GNU Public License</span>
00014 <span class="comment">//      which can be found at http://www.gnu.org/licenses/gpl.txt</span>
00015 <span class="comment">//</span>
00016 <span class="comment">//*****************************************************************************</span>
00017 
00018 <span class="preprocessor">#include &lt;avr/io.h&gt;</span>
00019 <span class="preprocessor">#include &lt;avr/interrupt.h&gt;</span>
00020 
00021 <span class="preprocessor">#include "<a class="code" href="global_8h.html">global.h</a>"</span>
00022 <span class="preprocessor">#include "<a class="code" href="timer_8h.html">timer.h</a>"</span>
00023 <span class="preprocessor">#include "<a class="code" href="uartsw_8h.html">uartsw.h</a>"</span>
00024 
00025 <span class="comment">// Program ROM constants</span>
00026 
00027 <span class="comment">// Global variables</span>
00028 
00029 <span class="comment">// uartsw transmit status and data variables</span>
00030 <span class="keyword">static</span> <span class="keyword">volatile</span> u08 UartswTxBusy;
00031 <span class="keyword">static</span> <span class="keyword">volatile</span> u08 UartswTxData;
00032 <span class="keyword">static</span> <span class="keyword">volatile</span> u08 UartswTxBitNum;
00033 
00034 <span class="comment">// baud rate common to transmit and receive</span>
00035 <span class="keyword">static</span> <span class="keyword">volatile</span> u16 UartswBaudRateDiv;
00036 
00037 <span class="comment">// uartsw receive status and data variables</span>
00038 <span class="keyword">static</span> <span class="keyword">volatile</span> u08 UartswRxBusy;
00039 <span class="keyword">static</span> <span class="keyword">volatile</span> u08 UartswRxData;
00040 <span class="keyword">static</span> <span class="keyword">volatile</span> u08 UartswRxBitNum;
00041 <span class="comment">// receive buffer</span>
00042 <span class="keyword">static</span> <a class="code" href="structstruct__cBuffer.html">cBuffer</a> uartswRxBuffer;               <span class="comment">///&lt; uartsw receive buffer</span>
00043 <span class="comment"></span><span class="comment">// automatically allocate space in ram for each buffer</span>
00044 <span class="keyword">static</span> <span class="keywordtype">char</span> uartswRxData[<a class="code" href="uartsw2conf_8h.html#a0">UARTSW_RX_BUFFER_SIZE</a>];
00045 
00046 <span class="comment">// functions</span>
00047 <span class="comment"></span>
00048 <span class="comment">//! enable and initialize the software uart</span>
<a name="l00049"></a><a class="code" href="uartsw2_8h.html#a0">00049</a> <span class="comment"></span><span class="keywordtype">void</span> <a class="code" href="uartsw_8c.html#a9">uartswInit</a>(<span class="keywordtype">void</span>)
00050 {
00051     <span class="comment">// initialize the buffers</span>
00052     <a class="code" href="uartsw_8c.html#a10">uartswInitBuffers</a>();
00053     <span class="comment">// initialize the ports</span>
00054     sbi(<a class="code" href="uartsw2conf_8h.html#a3">UARTSW_TX_DDR</a>, <a class="code" href="uartsw2conf_8h.html#a4">UARTSW_TX_PIN</a>);
00055     cbi(<a class="code" href="uartsw2conf_8h.html#a6">UARTSW_RX_DDR</a>, <a class="code" href="uartsw2conf_8h.html#a8">UARTSW_RX_PIN</a>);
00056     cbi(<a class="code" href="uartsw2conf_8h.html#a5">UARTSW_RX_PORT</a>, <a class="code" href="uartsw2conf_8h.html#a8">UARTSW_RX_PIN</a>);
00057     <span class="comment">// initialize baud rate</span>
00058     <a class="code" href="uartsw_8c.html#a12">uartswSetBaudRate</a>(9600);
00059 
00060     <span class="comment">// setup the transmitter</span>
00061     UartswTxBusy = FALSE;
00062     <span class="comment">// disable OC1A interrupt</span>
00063     cbi(TIMSK, OCIE1A);
00064     <span class="comment">// attach TxBit service routine to OC1A</span>
00065     <a class="code" href="group__timer.html#ga8">timerAttach</a>(TIMER1OUTCOMPAREA_INT, <a class="code" href="uartsw_8c.html#a16">uartswTxBitService</a>);
00066 
00067     <span class="comment">// setup the receiver</span>
00068     UartswRxBusy = FALSE;
00069     <span class="comment">// disable OC1B interrupt</span>
00070     cbi(TIMSK, OCIE1B);
00071     <span class="comment">// attach RxBit service routine to OC1B</span>
00072     <a class="code" href="group__timer.html#ga8">timerAttach</a>(TIMER1OUTCOMPAREB_INT, <a class="code" href="uartsw_8c.html#a17">uartswRxBitService</a>);
00073     <span class="comment">// attach RxBit service routine to ICP</span>
00074     <a class="code" href="group__timer.html#ga8">timerAttach</a>(TIMER1INPUTCAPTURE_INT, <a class="code" href="uartsw_8c.html#a17">uartswRxBitService</a>);
00075 <span class="preprocessor">    #ifdef UARTSW_INVERT </span>
00076 <span class="preprocessor"></span>    <span class="comment">// trigger on rising edge </span>
00077     sbi(TCCR1B, ICES1); 
00078 <span class="preprocessor">    #else </span>
00079 <span class="preprocessor"></span>    <span class="comment">// trigger on falling edge </span>
00080     cbi(TCCR1B, ICES1); 
00081 <span class="preprocessor">    #endif  </span>
00082 <span class="preprocessor"></span>    <span class="comment">// enable ICP interrupt</span>
00083     sbi(TIMSK, TICIE1);
00084 
00085     <span class="comment">// turn on interrupts</span>
00086     sei();
00087 }
00088 <span class="comment"></span>
00089 <span class="comment">//! create and initialize the uart buffers</span>
<a name="l00090"></a><a class="code" href="uartsw2_8h.html#a1">00090</a> <span class="comment"></span><span class="keywordtype">void</span> <a class="code" href="uartsw_8c.html#a10">uartswInitBuffers</a>(<span class="keywordtype">void</span>)
00091 {
00092     <span class="comment">// initialize the UART receive buffer</span>
00093     <a class="code" href="group__buffer.html#ga1">bufferInit</a>(&amp;uartswRxBuffer, uartswRxData, <a class="code" href="uartsw2conf_8h.html#a0">UARTSW_RX_BUFFER_SIZE</a>);
00094 }
00095 <span class="comment"></span>
00096 <span class="comment">//! turns off software UART</span>
<a name="l00097"></a><a class="code" href="uartsw2_8h.html#a2">00097</a> <span class="comment"></span><span class="keywordtype">void</span> <a class="code" href="uartsw_8c.html#a11">uartswOff</a>(<span class="keywordtype">void</span>)
00098 {
00099     <span class="comment">// disable interrupts</span>
00100     cbi(TIMSK, OCIE1A);
00101     cbi(TIMSK, OCIE1B);
00102     cbi(TIMSK, TICIE1);
00103     <span class="comment">// detach the service routines</span>
00104     <a class="code" href="group__timer.html#ga9">timerDetach</a>(TIMER1OUTCOMPAREA_INT);
00105     <a class="code" href="group__timer.html#ga9">timerDetach</a>(TIMER1OUTCOMPAREB_INT);
00106     <a class="code" href="group__timer.html#ga9">timerDetach</a>(TIMER1INPUTCAPTURE_INT);
00107 }
00108 
<a name="l00109"></a><a class="code" href="uartsw2_8h.html#a4">00109</a> <span class="keywordtype">void</span> <a class="code" href="uartsw_8c.html#a12">uartswSetBaudRate</a>(u32 baudrate)
00110 {
00111     <span class="comment">// set timer prescaler</span>
00112     <a class="code" href="group__timer.html#ga6">timer1SetPrescaler</a>(<a class="code" href="group__timer.html#ga16">TIMER_CLK_DIV1</a>);
00113     <span class="comment">// calculate division factor for requested baud rate, and set it</span>
00114     UartswBaudRateDiv = (u16)((F_CPU+(baudrate/2L))/(baudrate*1L));
00115 }
00116 <span class="comment"></span>
00117 <span class="comment">//! returns the receive buffer structure </span>
<a name="l00118"></a><a class="code" href="uartsw2_8h.html#a3">00118</a> <span class="comment"></span><a class="code" href="structstruct__cBuffer.html">cBuffer</a>* <a class="code" href="uartsw_8c.html#a13">uartswGetRxBuffer</a>(<span class="keywordtype">void</span>)
00119 {
00120     <span class="comment">// return rx buffer pointer</span>
00121     <span class="keywordflow">return</span> &amp;uartswRxBuffer;
00122 }
00123 
<a name="l00124"></a><a class="code" href="uartsw2_8h.html#a5">00124</a> <span class="keywordtype">void</span> <a class="code" href="uartsw_8c.html#a14">uartswSendByte</a>(u08 data)
00125 {
00126     <span class="comment">// wait until uart is ready</span>
00127     <span class="keywordflow">while</span>(UartswTxBusy);
00128     <span class="comment">// set busy flag</span>
00129     UartswTxBusy = TRUE;
00130     <span class="comment">// save data</span>
00131     UartswTxData = data;
00132     <span class="comment">// set number of bits (+1 for stop bit)</span>
00133     UartswTxBitNum = 9;
00134     
00135     <span class="comment">// set the start bit</span>
00136 <span class="preprocessor">    #ifdef UARTSW_INVERT</span>
00137 <span class="preprocessor"></span>    sbi(<a class="code" href="uartsw2conf_8h.html#a2">UARTSW_TX_PORT</a>, <a class="code" href="uartsw2conf_8h.html#a4">UARTSW_TX_PIN</a>);
00138 <span class="preprocessor">    #else</span>
00139 <span class="preprocessor"></span>    cbi(<a class="code" href="uartsw2conf_8h.html#a2">UARTSW_TX_PORT</a>, <a class="code" href="uartsw2conf_8h.html#a4">UARTSW_TX_PIN</a>);
00140 <span class="preprocessor">    #endif</span>
00141 <span class="preprocessor"></span>
00142     <span class="comment">// schedule the next bit</span>
00143     outw(OCR1A, inw(TCNT1) + UartswBaudRateDiv);
00144     <span class="comment">// enable OC1A interrupt</span>
00145     sbi(TIMSK, OCIE1A);
00146 }
00147 <span class="comment"></span>
00148 <span class="comment">//! gets a byte (if available) from the uart receive buffer</span>
<a name="l00149"></a><a class="code" href="uartsw2_8h.html#a6">00149</a> <span class="comment"></span>u08 <a class="code" href="uartsw_8c.html#a15">uartswReceiveByte</a>(u08* rxData)
00150 {
00151     <span class="comment">// make sure we have a receive buffer</span>
00152     <span class="keywordflow">if</span>(uartswRxBuffer.<a class="code" href="structstruct__cBuffer.html#o1">size</a>)
00153     {
00154         <span class="comment">// make sure we have data</span>
00155         <span class="keywordflow">if</span>(uartswRxBuffer.<a class="code" href="structstruct__cBuffer.html#o2">datalength</a>)
00156         {
00157             <span class="comment">// get byte from beginning of buffer</span>
00158             *rxData = <a class="code" href="group__buffer.html#ga2">bufferGetFromFront</a>(&amp;uartswRxBuffer);
00159             <span class="keywordflow">return</span> TRUE;
00160         }
00161         <span class="keywordflow">else</span>
00162         {
00163             <span class="comment">// no data</span>
00164             <span class="keywordflow">return</span> FALSE;
00165         }
00166     }
00167     <span class="keywordflow">else</span>
00168     {
00169         <span class="comment">// no buffer</span>
00170         <span class="keywordflow">return</span> FALSE;
00171     }
00172 }
00173 
<a name="l00174"></a><a class="code" href="uartsw2_8h.html#a7">00174</a> <span class="keywordtype">void</span> <a class="code" href="uartsw_8c.html#a16">uartswTxBitService</a>(<span class="keywordtype">void</span>)
00175 {
00176     <span class="keywordflow">if</span>(UartswTxBitNum)
00177     {
00178         <span class="comment">// there are bits still waiting to be transmitted</span>
00179         <span class="keywordflow">if</span>(UartswTxBitNum &gt; 1)
00180         {
00181             <span class="comment">// transmit data bits (inverted, LSB first)</span>
00182 <span class="preprocessor">            #ifdef UARTSW_INVERT</span>
00183 <span class="preprocessor"></span>            <span class="keywordflow">if</span>( !(UartswTxData &amp; 0x01) )
00184 <span class="preprocessor">            #else</span>
00185 <span class="preprocessor"></span>            <span class="keywordflow">if</span>( (UartswTxData &amp; 0x01) )
00186 <span class="preprocessor">            #endif</span>
00187 <span class="preprocessor"></span>                sbi(<a class="code" href="uartsw2conf_8h.html#a2">UARTSW_TX_PORT</a>, <a class="code" href="uartsw2conf_8h.html#a4">UARTSW_TX_PIN</a>);
00188             <span class="keywordflow">else</span>
00189                 cbi(<a class="code" href="uartsw2conf_8h.html#a2">UARTSW_TX_PORT</a>, <a class="code" href="uartsw2conf_8h.html#a4">UARTSW_TX_PIN</a>);
00190             <span class="comment">// shift bits down</span>
00191             UartswTxData = UartswTxData&gt;&gt;1;
00192         }
00193         <span class="keywordflow">else</span>
00194         {
00195             <span class="comment">// transmit stop bit</span>
00196 <span class="preprocessor">            #ifdef UARTSW_INVERT</span>
00197 <span class="preprocessor"></span>            cbi(<a class="code" href="uartsw2conf_8h.html#a2">UARTSW_TX_PORT</a>, <a class="code" href="uartsw2conf_8h.html#a4">UARTSW_TX_PIN</a>);
00198 <span class="preprocessor">            #else</span>
00199 <span class="preprocessor"></span>            sbi(<a class="code" href="uartsw2conf_8h.html#a2">UARTSW_TX_PORT</a>, <a class="code" href="uartsw2conf_8h.html#a4">UARTSW_TX_PIN</a>);
00200 <span class="preprocessor">            #endif</span>
00201 <span class="preprocessor"></span>        }
00202         <span class="comment">// schedule the next bit</span>
00203         outw(OCR1A, inw(OCR1A) + UartswBaudRateDiv);
00204         <span class="comment">// count down</span>
00205         UartswTxBitNum--;
00206     }
00207     <span class="keywordflow">else</span>
00208     {
00209         <span class="comment">// transmission is done</span>
00210         <span class="comment">// clear busy flag</span>
00211         UartswTxBusy = FALSE;
00212     }
00213 }
00214 
<a name="l00215"></a><a class="code" href="uartsw2_8h.html#a8">00215</a> <span class="keywordtype">void</span> <a class="code" href="uartsw_8c.html#a17">uartswRxBitService</a>(<span class="keywordtype">void</span>)
00216 {
00217     <span class="comment">// this function runs on either:</span>
00218     <span class="comment">// - a rising edge interrupt</span>
00219     <span class="comment">// - OC1B</span>
00220     <span class="keywordflow">if</span>(!UartswRxBusy)
00221     {
00222         <span class="comment">// this is a start bit</span>
00223         <span class="comment">// disable ICP interrupt</span>
00224         cbi(TIMSK, TICIE1);
00225         <span class="comment">// schedule data bit sampling 1.5 bit periods from now</span>
00226         outw(OCR1B, inw(TCNT1) + UartswBaudRateDiv + UartswBaudRateDiv/2);
00227         <span class="comment">// clear OC1B interrupt flag</span>
00228         sbi(TIFR, OCF1B);
00229         <span class="comment">// enable OC1B interrupt</span>
00230         sbi(TIMSK, OCIE1B);
00231         <span class="comment">// set start bit flag</span>
00232         UartswRxBusy = TRUE;
00233         <span class="comment">// reset bit counter</span>
00234         UartswRxBitNum = 0;
00235         <span class="comment">// reset data</span>
00236         UartswRxData = 0;
00237     }
00238     <span class="keywordflow">else</span>
00239     {
00240         <span class="comment">// start bit has already been received</span>
00241         <span class="comment">// we're in the data bits</span>
00242         
00243         <span class="comment">// shift data byte to make room for new bit</span>
00244         UartswRxData = UartswRxData&gt;&gt;1;
00245 
00246         <span class="comment">// sample the data line</span>
00247 <span class="preprocessor">        #ifdef UARTSW_INVERT</span>
00248 <span class="preprocessor"></span>        <span class="keywordflow">if</span>( !(inb(<a class="code" href="uartsw2conf_8h.html#a7">UARTSW_RX_PORTIN</a>) &amp; (1&lt;&lt;<a class="code" href="uartsw2conf_8h.html#a8">UARTSW_RX_PIN</a>)) )
00249 <span class="preprocessor">        #else</span>
00250 <span class="preprocessor"></span>        <span class="keywordflow">if</span>( (inb(<a class="code" href="uartsw2conf_8h.html#a7">UARTSW_RX_PORTIN</a>) &amp; (1&lt;&lt;<a class="code" href="uartsw2conf_8h.html#a8">UARTSW_RX_PIN</a>)) )
00251 <span class="preprocessor">        #endif</span>
00252 <span class="preprocessor"></span>        {
00253             <span class="comment">// serial line is marking</span>
00254             <span class="comment">// record '1' bit</span>
00255             UartswRxData |= 0x80;
00256         }
00257 
00258         <span class="comment">// increment bit counter</span>
00259         UartswRxBitNum++;
00260         <span class="comment">// schedule next bit sample</span>
00261         outw(OCR1B, inw(OCR1B) + UartswBaudRateDiv);
00262 
00263         <span class="comment">// check if we have a full byte</span>
00264         <span class="keywordflow">if</span>(UartswRxBitNum &gt;= 8)
00265         {
00266             <span class="comment">// save data in receive buffer</span>
00267             <a class="code" href="group__buffer.html#ga5">bufferAddToEnd</a>(&amp;uartswRxBuffer, UartswRxData);
00268             <span class="comment">// disable OC1B interrupt</span>
00269             cbi(TIMSK, OCIE1B);
00270             <span class="comment">// clear ICP interrupt flag</span>
00271             sbi(TIFR, ICF1);
00272             <span class="comment">// enable ICP interrupt</span>
00273             sbi(TIMSK, TICIE1);
00274             <span class="comment">// clear start bit flag</span>
00275             UartswRxBusy = FALSE;
00276         }
00277     }
00278 }
00279 
00280 <span class="comment">/*</span>
00281 <span class="comment">void uartswRxBitService(void)</span>
00282 <span class="comment">{</span>
00283 <span class="comment">    u16 thisBitTime;</span>
00284 <span class="comment">    u08 bitperiods;</span>
00285 <span class="comment">    u08 i;</span>
00286 <span class="comment"></span>
00287 <span class="comment">    // bit transition was detected</span>
00288 <span class="comment">    // record bit's edge time</span>
00289 <span class="comment">    thisBitTime = inw(ICR1);</span>
00290 <span class="comment"></span>
00291 <span class="comment">    cbi(PORTB, 0);</span>
00292 <span class="comment"></span>
00293 <span class="comment">    if(!UartswRxStartBit)</span>
00294 <span class="comment">    {</span>
00295 <span class="comment">        // this is a start bit</span>
00296 <span class="comment">        // switch to falling-edge trigger</span>
00297 <span class="comment">        cbi(TCCR1B, ICES1);</span>
00298 <span class="comment">        // record bit time</span>
00299 <span class="comment">        UartswRxBitTime = thisBitTime;</span>
00300 <span class="comment">        // set start bit flag</span>
00301 <span class="comment">        UartswRxStartBit = TRUE;</span>
00302 <span class="comment">        // reset bit counter</span>
00303 <span class="comment">        UartswRxBitNum = 0;</span>
00304 <span class="comment">        // reset data</span>
00305 <span class="comment">        UartswRxData = 0;</span>
00306 <span class="comment">    }</span>
00307 <span class="comment">    else</span>
00308 <span class="comment">    {</span>
00309 <span class="comment">        // start bit has already been received</span>
00310 <span class="comment">        // we're in the data bits</span>
00311 <span class="comment">        </span>
00312 <span class="comment">        // how many bit periods since last edge?</span>
00313 <span class="comment">        bitperiods = (thisBitTime - UartswRxBitTime + UartswBaudRateDiv/2)/UartswBaudRateDiv;</span>
00314 <span class="comment">        // set last edge time</span>
00315 <span class="comment">        UartswRxBitTime = thisBitTime;</span>
00316 <span class="comment"></span>
00317 <span class="comment">        if(bitperiods &gt; 10)</span>
00318 <span class="comment">        {</span>
00319 <span class="comment">            // switch to trigger on rising edge</span>
00320 <span class="comment">            sbi(TCCR1B, ICES1);</span>
00321 <span class="comment">            // clear start bit flag</span>
00322 <span class="comment">            UartswRxStartBit = FALSE;</span>
00323 <span class="comment">        }</span>
00324 <span class="comment">        else</span>
00325 <span class="comment">        {</span>
00326 <span class="comment"></span>
00327 <span class="comment"></span>
00328 <span class="comment">        if( inb(TCCR1B) &amp; (1&lt;&lt;ICES1) )</span>
00329 <span class="comment">        {</span>
00330 <span class="comment">            // just triggered on a rising edge</span>
00331 <span class="comment">            // previous bits were zero</span>
00332 <span class="comment">            // shift in the data (data bits are inverted)</span>
00333 <span class="comment">            for(i=0; i&lt;bitperiods; i++)</span>
00334 <span class="comment">            {</span>
00335 <span class="comment">                UartswRxData = UartswRxData&lt;&lt;1;</span>
00336 <span class="comment">                UartswRxData |= 0x01;</span>
00337 <span class="comment">            }</span>
00338 <span class="comment">            // switch to trigger on falling edge</span>
00339 <span class="comment">            cbi(TCCR1B, ICES1);</span>
00340 <span class="comment">        }</span>
00341 <span class="comment">        else</span>
00342 <span class="comment">        {</span>
00343 <span class="comment">            // just triggered on a falling edge</span>
00344 <span class="comment">            // previous bits were one</span>
00345 <span class="comment">            // shift in the data (data bits are inverted)</span>
00346 <span class="comment">            for(i=0; i&lt;bitperiods; i++)</span>
00347 <span class="comment">            {</span>
00348 <span class="comment">                UartswRxData = UartswRxData&lt;&lt;1;</span>
00349 <span class="comment">            }</span>
00350 <span class="comment">            // switch to trigger on rising edge</span>
00351 <span class="comment">            sbi(TCCR1B, ICES1);</span>
00352 <span class="comment">        }</span>
00353 <span class="comment">        </span>
00354 <span class="comment">        // increment bit counter</span>
00355 <span class="comment">        UartswRxBitNum += bitperiods;</span>
00356 <span class="comment">        </span>
00357 <span class="comment">        // check if we have a full byte + start bit</span>
00358 <span class="comment">        if(bitperiods &gt; 8)</span>
00359 <span class="comment">        {</span>
00360 <span class="comment">            // save data in receive buffer</span>
00361 <span class="comment">            bufferAddToEnd(&amp;uartswRxBuffer, UartswRxData);</span>
00362 <span class="comment">            // switch to trigger on rising edge</span>
00363 <span class="comment">            sbi(TCCR1B, ICES1);</span>
00364 <span class="comment">            // clear start bit flag</span>
00365 <span class="comment">            UartswRxStartBit = FALSE;</span>
00366 <span class="comment">        }</span>
00367 <span class="comment">        }</span>
00368 <span class="comment">    }</span>
00369 <span class="comment"></span>
00370 <span class="comment">    // turn off debug LEDs</span>
00371 <span class="comment">    delay(10);</span>
00372 <span class="comment">    sbi(PORTB, 0);</span>
00373 <span class="comment">    sbi(PORTB, 1);</span>
00374 <span class="comment">}</span>
00375 <span class="comment">*/</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Sun Oct 29 03:41:08 2006 for Procyon AVRlib by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.2 </small></address>
</body>
</html>
