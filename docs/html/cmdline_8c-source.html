<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Procyon AVRlib: cmdline.c Source File</title>
<link href="dox.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.2 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>cmdline.c</h1><a href="cmdline_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*! \file cmdline.c \brief Command-Line Interface Library. */</span>
00002 <span class="comment">//*****************************************************************************</span>
00003 <span class="comment">//</span>
00004 <span class="comment">// File Name    : 'cmdline.c'</span>
00005 <span class="comment">// Title        : Command-Line Interface Library</span>
00006 <span class="comment">// Author       : Pascal Stang - Copyright (C) 2003</span>
00007 <span class="comment">// Created      : 2003.07.16</span>
00008 <span class="comment">// Revised      : 2003.07.23</span>
00009 <span class="comment">// Version      : 0.1</span>
00010 <span class="comment">// Target MCU   : Atmel AVR Series</span>
00011 <span class="comment">// Editor Tabs  : 4</span>
00012 <span class="comment">//</span>
00013 <span class="comment">// NOTE: This code is currently below version 1.0, and therefore is considered</span>
00014 <span class="comment">// to be lacking in some functionality or documentation, or may not be fully</span>
00015 <span class="comment">// tested.  Nonetheless, you can expect most functions to work.</span>
00016 <span class="comment">//</span>
00017 <span class="comment">// This code is distributed under the GNU Public License</span>
00018 <span class="comment">//      which can be found at http://www.gnu.org/licenses/gpl.txt</span>
00019 <span class="comment">//</span>
00020 <span class="comment">//*****************************************************************************</span>
00021 
00022 <span class="comment">//----- Include Files ---------------------------------------------------------</span>
00023 <span class="preprocessor">#include &lt;avr/io.h&gt;</span>         <span class="comment">// include I/O definitions (port names, pin names, etc)</span>
00024 <span class="preprocessor">#include &lt;avr/interrupt.h&gt;</span>  <span class="comment">// include interrupt support</span>
00025 <span class="preprocessor">#include &lt;avr/pgmspace.h&gt;</span>   <span class="comment">// include AVR program memory support</span>
00026 <span class="preprocessor">#include &lt;string.h&gt;</span>         <span class="comment">// include standard C string functions</span>
00027 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>         <span class="comment">// include stdlib for string conversion functions</span>
00028 
00029 <span class="preprocessor">#include "<a class="code" href="global_8h.html">global.h</a>"</span>     <span class="comment">// include our global settings</span>
00030 <span class="preprocessor">#include "<a class="code" href="cmdline_8h.html">cmdline.h</a>"</span>
00031 
00032 <span class="comment">// include project-specific configuration</span>
00033 <span class="preprocessor">#include "<a class="code" href="cmdlineconf_8h.html">cmdlineconf.h</a>"</span>
00034 
00035 <span class="comment">// defines</span>
00036 <span class="preprocessor">#define ASCII_BEL               0x07</span>
00037 <span class="preprocessor"></span><span class="preprocessor">#define ASCII_BS                0x08</span>
00038 <span class="preprocessor"></span><span class="preprocessor">#define ASCII_CR                0x0D</span>
00039 <span class="preprocessor"></span><span class="preprocessor">#define ASCII_LF                0x0A</span>
00040 <span class="preprocessor"></span><span class="preprocessor">#define ASCII_ESC               0x1B</span>
00041 <span class="preprocessor"></span><span class="preprocessor">#define ASCII_DEL               0x7F</span>
00042 <span class="preprocessor"></span>
00043 <span class="preprocessor">#define VT100_ARROWUP           'A'</span>
00044 <span class="preprocessor"></span><span class="preprocessor">#define VT100_ARROWDOWN         'B'</span>
00045 <span class="preprocessor"></span><span class="preprocessor">#define VT100_ARROWRIGHT        'C'</span>
00046 <span class="preprocessor"></span><span class="preprocessor">#define VT100_ARROWLEFT         'D'</span>
00047 <span class="preprocessor"></span>
00048 <span class="preprocessor">#define CMDLINE_HISTORY_SAVE    0</span>
00049 <span class="preprocessor"></span><span class="preprocessor">#define CMDLINE_HISTORY_PREV    1</span>
00050 <span class="preprocessor"></span><span class="preprocessor">#define CMDLINE_HISTORY_NEXT    2</span>
00051 <span class="preprocessor"></span>
00052 
00053 <span class="comment">// Global variables</span>
00054 
00055 <span class="comment">// strings</span>
00056 u08 PROGMEM CmdlinePrompt[] = <span class="stringliteral">"cmd&gt;"</span>;
00057 u08 PROGMEM CmdlineNotice[] = <span class="stringliteral">"cmdline: "</span>;
00058 u08 PROGMEM CmdlineCmdNotFound[] = <span class="stringliteral">"command not found"</span>;
00059 
00060 <span class="comment">// command list</span>
00061 <span class="comment">// -commands are null-terminated strings</span>
00062 <span class="keyword">static</span> <span class="keywordtype">char</span> CmdlineCommandList[CMDLINE_MAX_COMMANDS][CMDLINE_MAX_CMD_LENGTH];
00063 <span class="comment">// command function pointer list</span>
00064 <span class="keyword">static</span> CmdlineFuncPtrType CmdlineFunctionList[CMDLINE_MAX_COMMANDS];
00065 <span class="comment">// number of commands currently registered</span>
00066 u08 CmdlineNumCommands;
00067 
00068 u08 CmdlineBuffer[CMDLINE_BUFFERSIZE];
00069 u08 CmdlineBufferLength;
00070 u08 CmdlineBufferEditPos;
00071 u08 CmdlineInputVT100State;
00072 u08 CmdlineHistory[CMDLINE_HISTORYSIZE][CMDLINE_BUFFERSIZE];
00073 CmdlineFuncPtrType CmdlineExecFunction;
00074 
00075 <span class="comment">// Functions</span>
00076 
00077 <span class="comment">// function pointer to single character output routine</span>
00078 <span class="keyword">static</span> void (*cmdlineOutputFunc)(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> c);
00079 
<a name="l00080"></a><a class="code" href="group__cmdline.html#ga1">00080</a> <span class="keywordtype">void</span> <a class="code" href="group__cmdline.html#ga1">cmdlineInit</a>(<span class="keywordtype">void</span>)
00081 {
00082     <span class="comment">// reset vt100 processing state</span>
00083     CmdlineInputVT100State = 0;
00084     <span class="comment">// initialize input buffer</span>
00085     CmdlineBufferLength = 0;
00086     CmdlineBufferEditPos = 0;
00087     <span class="comment">// initialize executing function</span>
00088     CmdlineExecFunction = 0;
00089     <span class="comment">// initialize command list</span>
00090     CmdlineNumCommands = 0;
00091 }
00092 
<a name="l00093"></a><a class="code" href="group__cmdline.html#ga2">00093</a> <span class="keywordtype">void</span> <a class="code" href="group__cmdline.html#ga2">cmdlineAddCommand</a>(u08* newCmdString, CmdlineFuncPtrType newCmdFuncPtr)
00094 {
00095     <span class="comment">// add command string to end of command list</span>
00096     strcpy(CmdlineCommandList[CmdlineNumCommands], newCmdString);
00097     <span class="comment">// add command function ptr to end of function list</span>
00098     CmdlineFunctionList[CmdlineNumCommands] = newCmdFuncPtr;
00099     <span class="comment">// increment number of registered commands</span>
00100     CmdlineNumCommands++;
00101 }
00102 
<a name="l00103"></a><a class="code" href="group__cmdline.html#ga3">00103</a> <span class="keywordtype">void</span> <a class="code" href="group__cmdline.html#ga3">cmdlineSetOutputFunc</a>(<span class="keywordtype">void</span> (*output_func)(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> c))
00104 {
00105     <span class="comment">// set new output function</span>
00106     cmdlineOutputFunc = output_func;
00107     
00108     <span class="comment">// should we really do this?</span>
00109     <span class="comment">// print a prompt </span>
00110     <span class="comment">//cmdlinePrintPrompt();</span>
00111 }
00112 
<a name="l00113"></a><a class="code" href="group__cmdline.html#ga4">00113</a> <span class="keywordtype">void</span> <a class="code" href="group__cmdline.html#ga4">cmdlineInputFunc</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> c)
00114 {
00115     u08 i;
00116     <span class="comment">// process the received character</span>
00117 
00118     <span class="comment">// VT100 handling</span>
00119     <span class="comment">// are we processing a VT100 command?</span>
00120     <span class="keywordflow">if</span>(CmdlineInputVT100State == 2)
00121     {
00122         <span class="comment">// we have already received ESC and [</span>
00123         <span class="comment">// now process the vt100 code</span>
00124         <span class="keywordflow">switch</span>(c)
00125         {
00126         <span class="keywordflow">case</span> VT100_ARROWUP:
00127             cmdlineDoHistory(CMDLINE_HISTORY_PREV);
00128             <span class="keywordflow">break</span>;
00129         <span class="keywordflow">case</span> VT100_ARROWDOWN:
00130             cmdlineDoHistory(CMDLINE_HISTORY_NEXT);
00131             <span class="keywordflow">break</span>;
00132         <span class="keywordflow">case</span> VT100_ARROWRIGHT:
00133             <span class="comment">// if the edit position less than current string length</span>
00134             <span class="keywordflow">if</span>(CmdlineBufferEditPos &lt; CmdlineBufferLength)
00135             {
00136                 <span class="comment">// increment the edit position</span>
00137                 CmdlineBufferEditPos++;
00138                 <span class="comment">// move cursor forward one space (no erase)</span>
00139                 cmdlineOutputFunc(ASCII_ESC);
00140                 cmdlineOutputFunc(<span class="charliteral">'['</span>);
00141                 cmdlineOutputFunc(VT100_ARROWRIGHT);
00142             }
00143             <span class="keywordflow">else</span>
00144             {
00145                 <span class="comment">// else, ring the bell</span>
00146                 cmdlineOutputFunc(ASCII_BEL);
00147             }
00148             <span class="keywordflow">break</span>;
00149         <span class="keywordflow">case</span> VT100_ARROWLEFT:
00150             <span class="comment">// if the edit position is non-zero</span>
00151             <span class="keywordflow">if</span>(CmdlineBufferEditPos)
00152             {
00153                 <span class="comment">// decrement the edit position</span>
00154                 CmdlineBufferEditPos--;
00155                 <span class="comment">// move cursor back one space (no erase)</span>
00156                 cmdlineOutputFunc(ASCII_BS);
00157             }
00158             <span class="keywordflow">else</span>
00159             {
00160                 <span class="comment">// else, ring the bell</span>
00161                 cmdlineOutputFunc(ASCII_BEL);
00162             }
00163             <span class="keywordflow">break</span>;
00164         <span class="keywordflow">default</span>:
00165             <span class="keywordflow">break</span>;
00166         }
00167         <span class="comment">// done, reset state</span>
00168         CmdlineInputVT100State = 0;
00169         <span class="keywordflow">return</span>;
00170     }
00171     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(CmdlineInputVT100State == 1)
00172     {
00173         <span class="comment">// we last received [ESC]</span>
00174         <span class="keywordflow">if</span>(c == <span class="charliteral">'['</span>)
00175         {
00176             CmdlineInputVT100State = 2;
00177             <span class="keywordflow">return</span>;
00178         }
00179         <span class="keywordflow">else</span>
00180             CmdlineInputVT100State = 0;
00181     }
00182     <span class="keywordflow">else</span>
00183     {
00184         <span class="comment">// anything else, reset state</span>
00185         CmdlineInputVT100State = 0;
00186     }
00187 
00188     <span class="comment">// Regular handling</span>
00189     <span class="keywordflow">if</span>( (c &gt;= 0x20) &amp;&amp; (c &lt; 0x7F) )
00190     {
00191         <span class="comment">// character is printable</span>
00192         <span class="comment">// is this a simple append</span>
00193         <span class="keywordflow">if</span>(CmdlineBufferEditPos == CmdlineBufferLength)
00194         {
00195             <span class="comment">// echo character to the output</span>
00196             cmdlineOutputFunc(c);
00197             <span class="comment">// add it to the command line buffer</span>
00198             CmdlineBuffer[CmdlineBufferEditPos++] = c;
00199             <span class="comment">// update buffer length</span>
00200             CmdlineBufferLength++;
00201         }
00202         <span class="keywordflow">else</span>
00203         {
00204             <span class="comment">// edit/cursor position != end of buffer</span>
00205             <span class="comment">// we're inserting characters at a mid-line edit position</span>
00206             <span class="comment">// make room at the insert point</span>
00207             CmdlineBufferLength++;
00208             <span class="keywordflow">for</span>(i=CmdlineBufferLength; i&gt;CmdlineBufferEditPos; i--)
00209                 CmdlineBuffer[i] = CmdlineBuffer[i-1];
00210             <span class="comment">// insert character</span>
00211             CmdlineBuffer[CmdlineBufferEditPos++] = c;
00212             <span class="comment">// repaint</span>
00213             cmdlineRepaint();
00214             <span class="comment">// reposition cursor</span>
00215             <span class="keywordflow">for</span>(i=CmdlineBufferEditPos; i&lt;CmdlineBufferLength; i++)
00216                 cmdlineOutputFunc(ASCII_BS);
00217         }
00218     }
00219     <span class="comment">// handle special characters</span>
00220     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(c == ASCII_CR)
00221     {
00222         <span class="comment">// user pressed [ENTER]</span>
00223         <span class="comment">// echo CR and LF to terminal</span>
00224         cmdlineOutputFunc(ASCII_CR);
00225         cmdlineOutputFunc(ASCII_LF);
00226         <span class="comment">// add null termination to command</span>
00227         CmdlineBuffer[CmdlineBufferLength++] = 0;
00228         CmdlineBufferEditPos++;
00229         <span class="comment">// command is complete, process it</span>
00230         cmdlineProcessInputString();
00231         <span class="comment">// reset buffer</span>
00232         CmdlineBufferLength = 0;
00233         CmdlineBufferEditPos = 0;
00234     }
00235     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(c == ASCII_BS)
00236     {
00237         <span class="keywordflow">if</span>(CmdlineBufferEditPos)
00238         {
00239             <span class="comment">// is this a simple delete (off the end of the line)</span>
00240             <span class="keywordflow">if</span>(CmdlineBufferEditPos == CmdlineBufferLength)
00241             {
00242                 <span class="comment">// destructive backspace</span>
00243                 <span class="comment">// echo backspace-space-backspace</span>
00244                 cmdlineOutputFunc(ASCII_BS);
00245                 cmdlineOutputFunc(<span class="charliteral">' '</span>);
00246                 cmdlineOutputFunc(ASCII_BS);
00247                 <span class="comment">// decrement our buffer length and edit position</span>
00248                 CmdlineBufferLength--;
00249                 CmdlineBufferEditPos--;
00250             }
00251             <span class="keywordflow">else</span>
00252             {
00253                 <span class="comment">// edit/cursor position != end of buffer</span>
00254                 <span class="comment">// we're deleting characters at a mid-line edit position</span>
00255                 <span class="comment">// shift characters down, effectively deleting</span>
00256                 CmdlineBufferLength--;
00257                 CmdlineBufferEditPos--;
00258                 <span class="keywordflow">for</span>(i=CmdlineBufferEditPos; i&lt;CmdlineBufferLength; i++)
00259                     CmdlineBuffer[i] = CmdlineBuffer[i+1];
00260                 <span class="comment">// repaint</span>
00261                 cmdlineRepaint();
00262                 <span class="comment">// add space to clear leftover characters</span>
00263                 cmdlineOutputFunc(<span class="charliteral">' '</span>);
00264                 <span class="comment">// reposition cursor</span>
00265                 <span class="keywordflow">for</span>(i=CmdlineBufferEditPos; i&lt;(CmdlineBufferLength+1); i++)
00266                     cmdlineOutputFunc(ASCII_BS);
00267             }
00268         }
00269         <span class="keywordflow">else</span>
00270         {
00271             <span class="comment">// else, ring the bell</span>
00272             cmdlineOutputFunc(ASCII_BEL);
00273         }
00274     }
00275     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(c == ASCII_DEL)
00276     {
00277         <span class="comment">// not yet handled</span>
00278     }
00279     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(c == ASCII_ESC)
00280     {
00281         CmdlineInputVT100State = 1;
00282     }
00283 }
00284 
00285 <span class="keywordtype">void</span> cmdlineRepaint(<span class="keywordtype">void</span>)
00286 {
00287     u08* ptr;
00288     u08 i;
00289 
00290     <span class="comment">// carriage return</span>
00291     cmdlineOutputFunc(ASCII_CR);
00292     <span class="comment">// print fresh prompt</span>
00293     cmdlinePrintPrompt();
00294     <span class="comment">// print the new command line buffer</span>
00295     i = CmdlineBufferLength;
00296     ptr = CmdlineBuffer;
00297     <span class="keywordflow">while</span>(i--) cmdlineOutputFunc(*ptr++);
00298 }
00299 
00300 <span class="keywordtype">void</span> cmdlineDoHistory(u08 action)
00301 {
00302     <span class="keywordflow">switch</span>(action)
00303     {
00304     <span class="keywordflow">case</span> CMDLINE_HISTORY_SAVE:
00305         <span class="comment">// copy CmdlineBuffer to history if not null string</span>
00306         <span class="keywordflow">if</span>( strlen(CmdlineBuffer) )
00307             strcpy(CmdlineHistory[0], CmdlineBuffer);
00308         <span class="keywordflow">break</span>;
00309     <span class="keywordflow">case</span> CMDLINE_HISTORY_PREV:
00310         <span class="comment">// copy history to current buffer</span>
00311         strcpy(CmdlineBuffer, CmdlineHistory[0]);
00312         <span class="comment">// set the buffer position to the end of the line</span>
00313         CmdlineBufferLength = strlen(CmdlineBuffer);
00314         CmdlineBufferEditPos = CmdlineBufferLength;
00315         <span class="comment">// "re-paint" line</span>
00316         cmdlineRepaint();
00317         <span class="keywordflow">break</span>;
00318     <span class="keywordflow">case</span> CMDLINE_HISTORY_NEXT:
00319         <span class="keywordflow">break</span>;
00320     }
00321 }
00322 
00323 <span class="keywordtype">void</span> cmdlineProcessInputString(<span class="keywordtype">void</span>)
00324 {
00325     u08 cmdIndex;
00326     u08 i=0;
00327 
00328     <span class="comment">// save command in history</span>
00329     cmdlineDoHistory(CMDLINE_HISTORY_SAVE);
00330 
00331     <span class="comment">// find the end of the command (excluding arguments)</span>
00332     <span class="comment">// find first whitespace character in CmdlineBuffer</span>
00333     <span class="keywordflow">while</span>( !((CmdlineBuffer[i] == <span class="charliteral">' '</span>) || (CmdlineBuffer[i] == 0)) ) i++;
00334 
00335     <span class="keywordflow">if</span>(!i)
00336     {
00337         <span class="comment">// command was null or empty</span>
00338         <span class="comment">// output a new prompt</span>
00339         cmdlinePrintPrompt();
00340         <span class="comment">// we're done</span>
00341         <span class="keywordflow">return</span>;
00342     }
00343 
00344     <span class="comment">// search command list for match with entered command</span>
00345     <span class="keywordflow">for</span>(cmdIndex=0; cmdIndex&lt;CmdlineNumCommands; cmdIndex++)
00346     {
00347         <span class="keywordflow">if</span>( !strncmp(CmdlineCommandList[cmdIndex], CmdlineBuffer, i) )
00348         {
00349             <span class="comment">// user-entered command matched a command in the list (database)</span>
00350             <span class="comment">// run the corresponding function</span>
00351             CmdlineExecFunction = CmdlineFunctionList[cmdIndex];
00352             <span class="comment">// new prompt will be output after user function runs</span>
00353             <span class="comment">// and we're done</span>
00354             <span class="keywordflow">return</span>;
00355         }
00356     }
00357 
00358     <span class="comment">// if we did not get a match</span>
00359     <span class="comment">// output an error message</span>
00360     cmdlinePrintError();
00361     <span class="comment">// output a new prompt</span>
00362     cmdlinePrintPrompt();
00363 }
00364 
<a name="l00365"></a><a class="code" href="group__cmdline.html#ga5">00365</a> <span class="keywordtype">void</span> <a class="code" href="group__cmdline.html#ga5">cmdlineMainLoop</a>(<span class="keywordtype">void</span>)
00366 {
00367     <span class="comment">// do we have a command/function to be executed</span>
00368     <span class="keywordflow">if</span>(CmdlineExecFunction)
00369     {
00370         <span class="comment">// run it</span>
00371         CmdlineExecFunction();
00372         <span class="comment">// reset</span>
00373         CmdlineExecFunction = 0;
00374         <span class="comment">// output new prompt</span>
00375         cmdlinePrintPrompt();
00376     }
00377 }
00378 
00379 <span class="keywordtype">void</span> cmdlinePrintPrompt(<span class="keywordtype">void</span>)
00380 {
00381     <span class="comment">// print a new command prompt</span>
00382     u08* ptr = CmdlinePrompt;
00383     <span class="keywordflow">while</span>(pgm_read_byte(ptr)) cmdlineOutputFunc( pgm_read_byte(ptr++) );
00384 }
00385 
00386 <span class="keywordtype">void</span> cmdlinePrintError(<span class="keywordtype">void</span>)
00387 {
00388     u08 * ptr;
00389 
00390     <span class="comment">// print a notice header</span>
00391     <span class="comment">// (u08*) cast used to avoid compiler warning</span>
00392     ptr = (u08*)CmdlineNotice;
00393     <span class="keywordflow">while</span>(pgm_read_byte(ptr)) cmdlineOutputFunc( pgm_read_byte(ptr++) );
00394     
00395     <span class="comment">// print the offending command</span>
00396     ptr = CmdlineBuffer;
00397     <span class="keywordflow">while</span>((*ptr) &amp;&amp; (*ptr != <span class="charliteral">' '</span>)) cmdlineOutputFunc(*ptr++);
00398 
00399     cmdlineOutputFunc(<span class="charliteral">':'</span>);
00400     cmdlineOutputFunc(<span class="charliteral">' '</span>);
00401 
00402     <span class="comment">// print the not-found message</span>
00403     <span class="comment">// (u08*) cast used to avoid compiler warning</span>
00404     ptr = (u08*)CmdlineCmdNotFound;
00405     <span class="keywordflow">while</span>(pgm_read_byte(ptr)) cmdlineOutputFunc( pgm_read_byte(ptr++) );
00406 
00407     cmdlineOutputFunc(<span class="charliteral">'\r'</span>);
00408     cmdlineOutputFunc(<span class="charliteral">'\n'</span>);
00409 }
00410 
00411 <span class="comment">// argument retrieval commands</span>
00412 
00413 <span class="comment">// return string pointer to argument [argnum]</span>
<a name="l00414"></a><a class="code" href="group__cmdline.html#ga11">00414</a> u08* <a class="code" href="group__cmdline.html#ga11">cmdlineGetArgStr</a>(u08 argnum)
00415 {
00416     <span class="comment">// find the offset of argument number [argnum]</span>
00417     u08 idx=0;
00418     u08 arg;
00419     
00420     <span class="comment">// find the first non-whitespace character</span>
00421     <span class="keywordflow">while</span>( (CmdlineBuffer[idx] != 0) &amp;&amp; (CmdlineBuffer[idx] == <span class="charliteral">' '</span>)) idx++;
00422     
00423     <span class="comment">// we are at the first argument</span>
00424     <span class="keywordflow">for</span>(arg=0; arg&lt;argnum; arg++)
00425     {
00426         <span class="comment">// find the next whitespace character</span>
00427         <span class="keywordflow">while</span>( (CmdlineBuffer[idx] != 0) &amp;&amp; (CmdlineBuffer[idx] != <span class="charliteral">' '</span>)) idx++;
00428         <span class="comment">// find the first non-whitespace character</span>
00429         <span class="keywordflow">while</span>( (CmdlineBuffer[idx] != 0) &amp;&amp; (CmdlineBuffer[idx] == <span class="charliteral">' '</span>)) idx++;
00430     }
00431     <span class="comment">// we are at the requested argument or the end of the buffer</span>
00432     <span class="keywordflow">return</span> &amp;CmdlineBuffer[idx];
00433 }
00434 
00435 <span class="comment">// return argument [argnum] interpreted as a decimal integer</span>
<a name="l00436"></a><a class="code" href="group__cmdline.html#ga12">00436</a> <span class="keywordtype">long</span> <a class="code" href="group__cmdline.html#ga12">cmdlineGetArgInt</a>(u08 argnum)
00437 {
00438     <span class="keywordtype">char</span>* endptr;
00439     <span class="keywordflow">return</span> strtol(<a class="code" href="group__cmdline.html#ga11">cmdlineGetArgStr</a>(argnum), &amp;endptr, 10);
00440 }
00441 
00442 <span class="comment">// return argument [argnum] interpreted as a hex integer</span>
<a name="l00443"></a><a class="code" href="group__cmdline.html#ga13">00443</a> <span class="keywordtype">long</span> <a class="code" href="group__cmdline.html#ga13">cmdlineGetArgHex</a>(u08 argnum)
00444 {
00445     <span class="keywordtype">char</span>* endptr;
00446     <span class="keywordflow">return</span> strtol(<a class="code" href="group__cmdline.html#ga11">cmdlineGetArgStr</a>(argnum), &amp;endptr, 16);
00447 }
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Sun Oct 29 03:41:06 2006 for Procyon AVRlib by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.2 </small></address>
</body>
</html>
