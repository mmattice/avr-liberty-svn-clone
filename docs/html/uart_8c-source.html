<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Procyon AVRlib: uart.c Source File</title>
<link href="dox.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.2 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>uart.c</h1><a href="uart_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*! \file uart.c \brief UART driver with buffer support. */</span>
00002 <span class="comment">// *****************************************************************************</span>
00003 <span class="comment">//</span>
00004 <span class="comment">// File Name    : 'uart.c'</span>
00005 <span class="comment">// Title        : UART driver with buffer support</span>
00006 <span class="comment">// Author       : Pascal Stang - Copyright (C) 2000-2002</span>
00007 <span class="comment">// Created      : 11/22/2000</span>
00008 <span class="comment">// Revised      : 06/09/2003</span>
00009 <span class="comment">// Version      : 1.3</span>
00010 <span class="comment">// Target MCU   : ATMEL AVR Series</span>
00011 <span class="comment">// Editor Tabs  : 4</span>
00012 <span class="comment">//</span>
00013 <span class="comment">// This code is distributed under the GNU Public License</span>
00014 <span class="comment">//      which can be found at http://www.gnu.org/licenses/gpl.txt</span>
00015 <span class="comment">//</span>
00016 <span class="comment">// *****************************************************************************</span>
00017 
00018 <span class="preprocessor">#include &lt;avr/io.h&gt;</span>
00019 <span class="preprocessor">#include &lt;avr/interrupt.h&gt;</span>
00020 
00021 <span class="preprocessor">#include "<a class="code" href="buffer_8h.html">buffer.h</a>"</span>
00022 <span class="preprocessor">#include "<a class="code" href="uart_8h.html">uart.h</a>"</span>
00023 
00024 <span class="comment">// UART global variables</span>
00025 <span class="comment">// flag variables</span>
<a name="l00026"></a><a class="code" href="uart_8c.html#a0">00026</a> <span class="keyword">volatile</span> u08   <a class="code" href="uart_8c.html#a0">uartReadyTx</a>;         <span class="comment">///&lt; uartReadyTx flag</span>
<a name="l00027"></a><a class="code" href="uart_8c.html#a1">00027</a> <span class="comment"></span><span class="keyword">volatile</span> u08   <a class="code" href="uart_8c.html#a1">uartBufferedTx</a>;      <span class="comment">///&lt; uartBufferedTx flag</span>
00028 <span class="comment"></span><span class="comment">// receive and transmit buffers</span>
<a name="l00029"></a><a class="code" href="uart_8c.html#a2">00029</a> <a class="code" href="structstruct__cBuffer.html">cBuffer</a> <a class="code" href="uart_8c.html#a2">uartRxBuffer</a>;               <span class="comment">///&lt; uart receive buffer</span>
<a name="l00030"></a><a class="code" href="uart_8c.html#a3">00030</a> <span class="comment"></span><a class="code" href="structstruct__cBuffer.html">cBuffer</a> <a class="code" href="uart_8c.html#a3">uartTxBuffer</a>;               <span class="comment">///&lt; uart transmit buffer</span>
<a name="l00031"></a><a class="code" href="uart_8c.html#a4">00031</a> <span class="comment"></span><span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> <a class="code" href="uart_8c.html#a4">uartRxOverflow</a>;      <span class="comment">///&lt; receive overflow counter</span>
00032 <span class="comment"></span>
00033 <span class="preprocessor">#ifndef UART_BUFFERS_EXTERNAL_RAM</span>
00034 <span class="preprocessor"></span>    <span class="comment">// using internal ram,</span>
00035     <span class="comment">// automatically allocate space in ram for each buffer</span>
00036     <span class="keyword">static</span> <span class="keywordtype">char</span> uartRxData[<a class="code" href="group__uart.html#ga16">UART_RX_BUFFER_SIZE</a>];
00037     <span class="keyword">static</span> <span class="keywordtype">char</span> uartTxData[<a class="code" href="group__uart.html#ga15">UART_TX_BUFFER_SIZE</a>];
00038 <span class="preprocessor">#endif</span>
00039 <span class="preprocessor"></span>
00040 <span class="keyword">typedef</span> void (*voidFuncPtru08)(<span class="keywordtype">unsigned</span> char);
00041 <span class="keyword">volatile</span> <span class="keyword">static</span> voidFuncPtru08 UartRxFunc;
00042 
00043 <span class="comment">// enable and initialize the uart</span>
<a name="l00044"></a><a class="code" href="group__uart2.html#ga0">00044</a> <span class="keywordtype">void</span> <a class="code" href="group__uart.html#ga0">uartInit</a>(<span class="keywordtype">void</span>)
00045 {
00046     <span class="comment">// initialize the buffers</span>
00047     <a class="code" href="group__uart.html#ga1">uartInitBuffers</a>();
00048     <span class="comment">// initialize user receive handler</span>
00049     UartRxFunc = 0;
00050 
00051     <span class="comment">// enable RxD/TxD and interrupts</span>
00052     outb(UCR, BV(RXCIE)|BV(TXCIE)|BV(RXEN)|BV(TXEN));
00053 
00054     <span class="comment">// set default baud rate</span>
00055     <a class="code" href="group__uart.html#ga3">uartSetBaudRate</a>(<a class="code" href="group__uart.html#ga14">UART_DEFAULT_BAUD_RATE</a>);  
00056     <span class="comment">// initialize states</span>
00057     <a class="code" href="uart_8c.html#a0">uartReadyTx</a> = TRUE;
00058     <a class="code" href="uart_8c.html#a1">uartBufferedTx</a> = FALSE;
00059     <span class="comment">// clear overflow count</span>
00060     <a class="code" href="uart_8c.html#a4">uartRxOverflow</a> = 0;
00061     <span class="comment">// enable interrupts</span>
00062     sei();
00063 }
00064 
00065 <span class="comment">// create and initialize the uart transmit and receive buffers</span>
<a name="l00066"></a><a class="code" href="group__uart.html#ga1">00066</a> <span class="keywordtype">void</span> <a class="code" href="group__uart.html#ga1">uartInitBuffers</a>(<span class="keywordtype">void</span>)
00067 {
00068 <span class="preprocessor">    #ifndef UART_BUFFERS_EXTERNAL_RAM</span>
00069 <span class="preprocessor"></span>        <span class="comment">// initialize the UART receive buffer</span>
00070         <a class="code" href="group__buffer.html#ga1">bufferInit</a>(&amp;uartRxBuffer, uartRxData, <a class="code" href="group__uart.html#ga16">UART_RX_BUFFER_SIZE</a>);
00071         <span class="comment">// initialize the UART transmit buffer</span>
00072         <a class="code" href="group__buffer.html#ga1">bufferInit</a>(&amp;uartTxBuffer, uartTxData, <a class="code" href="group__uart.html#ga15">UART_TX_BUFFER_SIZE</a>);
00073 <span class="preprocessor">    #else</span>
00074 <span class="preprocessor"></span>        <span class="comment">// initialize the UART receive buffer</span>
00075         <a class="code" href="group__buffer.html#ga1">bufferInit</a>(&amp;uartRxBuffer, (u08*) UART_RX_BUFFER_ADDR, <a class="code" href="group__uart.html#ga16">UART_RX_BUFFER_SIZE</a>);
00076         <span class="comment">// initialize the UART transmit buffer</span>
00077         <a class="code" href="group__buffer.html#ga1">bufferInit</a>(&amp;uartTxBuffer, (u08*) UART_TX_BUFFER_ADDR, <a class="code" href="group__uart.html#ga15">UART_TX_BUFFER_SIZE</a>);
00078 <span class="preprocessor">    #endif</span>
00079 <span class="preprocessor"></span>}
00080 
00081 <span class="comment">// redirects received data to a user function</span>
<a name="l00082"></a><a class="code" href="group__uart.html#ga2">00082</a> <span class="keywordtype">void</span> <a class="code" href="group__uart.html#ga2">uartSetRxHandler</a>(<span class="keywordtype">void</span> (*rx_func)(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> c))
00083 {
00084     <span class="comment">// set the receive interrupt to run the supplied user function</span>
00085     UartRxFunc = rx_func;
00086 }
00087 
00088 <span class="comment">// set the uart baud rate</span>
<a name="l00089"></a><a class="code" href="group__uart.html#ga3">00089</a> <span class="keywordtype">void</span> <a class="code" href="group__uart.html#ga3">uartSetBaudRate</a>(u32 baudrate)
00090 {
00091     <span class="comment">// calculate division factor for requested baud rate, and set it</span>
00092     u16 bauddiv = ((F_CPU+(baudrate*8L))/(baudrate*16L)-1);
00093     outb(UBRRL, bauddiv);
00094 <span class="preprocessor">    #ifdef UBRRH</span>
00095 <span class="preprocessor"></span>    outb(UBRRH, bauddiv&gt;&gt;8);
00096 <span class="preprocessor">    #endif</span>
00097 <span class="preprocessor"></span>}
00098 
00099 <span class="comment">// returns the receive buffer structure </span>
<a name="l00100"></a><a class="code" href="group__uart.html#ga4">00100</a> <a class="code" href="structstruct__cBuffer.html">cBuffer</a>* <a class="code" href="group__uart.html#ga4">uartGetRxBuffer</a>(<span class="keywordtype">void</span>)
00101 {
00102     <span class="comment">// return rx buffer pointer</span>
00103     <span class="keywordflow">return</span> &amp;uartRxBuffer;
00104 }
00105 
00106 <span class="comment">// returns the transmit buffer structure </span>
<a name="l00107"></a><a class="code" href="group__uart.html#ga5">00107</a> <a class="code" href="structstruct__cBuffer.html">cBuffer</a>* <a class="code" href="group__uart.html#ga5">uartGetTxBuffer</a>(<span class="keywordtype">void</span>)
00108 {
00109     <span class="comment">// return tx buffer pointer</span>
00110     <span class="keywordflow">return</span> &amp;uartTxBuffer;
00111 }
00112 
00113 <span class="comment">// transmits a byte over the uart</span>
<a name="l00114"></a><a class="code" href="group__uart.html#ga6">00114</a> <span class="keywordtype">void</span> <a class="code" href="group__uart.html#ga6">uartSendByte</a>(u08 txData)
00115 {
00116     <span class="comment">// wait for the transmitter to be ready</span>
00117     <span class="keywordflow">while</span>(!<a class="code" href="uart_8c.html#a0">uartReadyTx</a>);
00118     <span class="comment">// send byte</span>
00119     outb(UDR, txData);
00120     <span class="comment">// set ready state to FALSE</span>
00121     <a class="code" href="uart_8c.html#a0">uartReadyTx</a> = FALSE;
00122 }
00123 
00124 <span class="comment">// gets a single byte from the uart receive buffer (getchar-style)</span>
<a name="l00125"></a><a class="code" href="group__uart.html#ga7">00125</a> <span class="keywordtype">int</span> <a class="code" href="group__uart.html#ga7">uartGetByte</a>(<span class="keywordtype">void</span>)
00126 {
00127     u08 c;
00128     <span class="keywordflow">if</span>(<a class="code" href="group__uart.html#ga8">uartReceiveByte</a>(&amp;c))
00129         <span class="keywordflow">return</span> c;
00130     <span class="keywordflow">else</span>
00131         <span class="keywordflow">return</span> -1;
00132 }
00133 
00134 <span class="comment">// gets a byte (if available) from the uart receive buffer</span>
<a name="l00135"></a><a class="code" href="group__uart.html#ga8">00135</a> u08 <a class="code" href="group__uart.html#ga8">uartReceiveByte</a>(u08* rxData)
00136 {
00137     <span class="comment">// make sure we have a receive buffer</span>
00138     <span class="keywordflow">if</span>(uartRxBuffer.<a class="code" href="structstruct__cBuffer.html#o1">size</a>)
00139     {
00140         <span class="comment">// make sure we have data</span>
00141         <span class="keywordflow">if</span>(uartRxBuffer.<a class="code" href="structstruct__cBuffer.html#o2">datalength</a>)
00142         {
00143             <span class="comment">// get byte from beginning of buffer</span>
00144             *rxData = <a class="code" href="group__buffer.html#ga2">bufferGetFromFront</a>(&amp;uartRxBuffer);
00145             <span class="keywordflow">return</span> TRUE;
00146         }
00147         <span class="keywordflow">else</span>
00148         {
00149             <span class="comment">// no data</span>
00150             <span class="keywordflow">return</span> FALSE;
00151         }
00152     }
00153     <span class="keywordflow">else</span>
00154     {
00155         <span class="comment">// no buffer</span>
00156         <span class="keywordflow">return</span> FALSE;
00157     }
00158 }
00159 
00160 <span class="comment">// flush all data out of the receive buffer</span>
<a name="l00161"></a><a class="code" href="group__uart.html#ga10">00161</a> <span class="keywordtype">void</span> <a class="code" href="group__uart.html#ga10">uartFlushReceiveBuffer</a>(<span class="keywordtype">void</span>)
00162 {
00163     <span class="comment">// flush all data from receive buffer</span>
00164     <span class="comment">//bufferFlush(&amp;uartRxBuffer);</span>
00165     <span class="comment">// same effect as above</span>
00166     uartRxBuffer.<a class="code" href="structstruct__cBuffer.html#o2">datalength</a> = 0;
00167 }
00168 
00169 <span class="comment">// return true if uart receive buffer is empty</span>
<a name="l00170"></a><a class="code" href="group__uart.html#ga9">00170</a> u08 <a class="code" href="group__uart.html#ga9">uartReceiveBufferIsEmpty</a>(<span class="keywordtype">void</span>)
00171 {
00172     <span class="keywordflow">if</span>(uartRxBuffer.<a class="code" href="structstruct__cBuffer.html#o2">datalength</a> == 0)
00173     {
00174         <span class="keywordflow">return</span> TRUE;
00175     }
00176     <span class="keywordflow">else</span>
00177     {
00178         <span class="keywordflow">return</span> FALSE;
00179     }
00180 }
00181 
00182 <span class="comment">// add byte to end of uart Tx buffer</span>
<a name="l00183"></a><a class="code" href="group__uart.html#ga11">00183</a> u08 <a class="code" href="group__uart.html#ga11">uartAddToTxBuffer</a>(u08 data)
00184 {
00185     <span class="comment">// add data byte to the end of the tx buffer</span>
00186     <span class="keywordflow">return</span> <a class="code" href="group__buffer.html#ga5">bufferAddToEnd</a>(&amp;uartTxBuffer, data);
00187 }
00188 
00189 <span class="comment">// start transmission of the current uart Tx buffer contents</span>
<a name="l00190"></a><a class="code" href="group__uart.html#ga12">00190</a> <span class="keywordtype">void</span> <a class="code" href="group__uart.html#ga12">uartSendTxBuffer</a>(<span class="keywordtype">void</span>)
00191 {
00192     <span class="comment">// turn on buffered transmit</span>
00193     <a class="code" href="uart_8c.html#a1">uartBufferedTx</a> = TRUE;
00194     <span class="comment">// send the first byte to get things going by interrupts</span>
00195     <a class="code" href="group__uart.html#ga6">uartSendByte</a>(<a class="code" href="group__buffer.html#ga2">bufferGetFromFront</a>(&amp;uartTxBuffer));
00196 }
00197 <span class="comment">/*</span>
00198 <span class="comment">// transmit nBytes from buffer out the uart</span>
00199 <span class="comment">u08 uartSendBuffer(char *buffer, u16 nBytes)</span>
00200 <span class="comment">{</span>
00201 <span class="comment">    register u08 first;</span>
00202 <span class="comment">    register u16 i;</span>
00203 <span class="comment"></span>
00204 <span class="comment">    // check if there's space (and that we have any bytes to send at all)</span>
00205 <span class="comment">    if((uartTxBuffer.datalength + nBytes &lt; uartTxBuffer.size) &amp;&amp; nBytes)</span>
00206 <span class="comment">    {</span>
00207 <span class="comment">        // grab first character</span>
00208 <span class="comment">        first = *buffer++;</span>
00209 <span class="comment">        // copy user buffer to uart transmit buffer</span>
00210 <span class="comment">        for(i = 0; i &lt; nBytes-1; i++)</span>
00211 <span class="comment">        {</span>
00212 <span class="comment">            // put data bytes at end of buffer</span>
00213 <span class="comment">            bufferAddToEnd(&amp;uartTxBuffer, *buffer++);</span>
00214 <span class="comment">        }</span>
00215 <span class="comment"></span>
00216 <span class="comment">        // send the first byte to get things going by interrupts</span>
00217 <span class="comment">        uartBufferedTx = TRUE;</span>
00218 <span class="comment">        uartSendByte(first);</span>
00219 <span class="comment">        // return success</span>
00220 <span class="comment">        return TRUE;</span>
00221 <span class="comment">    }</span>
00222 <span class="comment">    else</span>
00223 <span class="comment">    {</span>
00224 <span class="comment">        // return failure</span>
00225 <span class="comment">        return FALSE;</span>
00226 <span class="comment">    }</span>
00227 <span class="comment">}</span>
00228 <span class="comment">*/</span>
00229 <span class="comment">// UART Transmit Complete Interrupt Handler</span>
00230 <a class="code" href="group__uart.html#ga17">UART_INTERRUPT_HANDLER</a>(SIG_UART_TRANS)
00231 {
00232     <span class="comment">// check if buffered tx is enabled</span>
00233     <span class="keywordflow">if</span>(<a class="code" href="uart_8c.html#a1">uartBufferedTx</a>)
00234     {
00235         <span class="comment">// check if there's data left in the buffer</span>
00236         <span class="keywordflow">if</span>(uartTxBuffer.<a class="code" href="structstruct__cBuffer.html#o2">datalength</a>)
00237         {
00238             <span class="comment">// send byte from top of buffer</span>
00239             outb(UDR, <a class="code" href="group__buffer.html#ga2">bufferGetFromFront</a>(&amp;uartTxBuffer));
00240         }
00241         <span class="keywordflow">else</span>
00242         {
00243             <span class="comment">// no data left</span>
00244             <a class="code" href="uart_8c.html#a1">uartBufferedTx</a> = FALSE;
00245             <span class="comment">// return to ready state</span>
00246             <a class="code" href="uart_8c.html#a0">uartReadyTx</a> = TRUE;
00247         }
00248     }
00249     <span class="keywordflow">else</span>
00250     {
00251         <span class="comment">// we're using single-byte tx mode</span>
00252         <span class="comment">// indicate transmit complete, back to ready</span>
00253         <a class="code" href="uart_8c.html#a0">uartReadyTx</a> = TRUE;
00254     }
00255 }
00256 
00257 <span class="comment">// UART Receive Complete Interrupt Handler</span>
00258 <a class="code" href="group__uart.html#ga17">UART_INTERRUPT_HANDLER</a>(SIG_UART_RECV)
00259 {
00260     u08 c;
00261     
00262     <span class="comment">// get received char</span>
00263     c = inb(UDR);
00264 
00265     <span class="comment">// if there's a user function to handle this receive event</span>
00266     <span class="keywordflow">if</span>(UartRxFunc)
00267     {
00268         <span class="comment">// call it and pass the received data</span>
00269         UartRxFunc(c);
00270     }
00271     <span class="keywordflow">else</span>
00272     {
00273         <span class="comment">// otherwise do default processing</span>
00274         <span class="comment">// put received char in buffer</span>
00275         <span class="comment">// check if there's space</span>
00276         <span class="keywordflow">if</span>( !<a class="code" href="group__buffer.html#ga5">bufferAddToEnd</a>(&amp;uartRxBuffer, c) )
00277         {
00278             <span class="comment">// no space in buffer</span>
00279             <span class="comment">// count overflow</span>
00280             <a class="code" href="uart_8c.html#a4">uartRxOverflow</a>++;
00281         }
00282     }
00283 }
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Sun Oct 29 03:41:08 2006 for Procyon AVRlib by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.2 </small></address>
</body>
</html>
