<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Procyon AVRlib: timer.c Source File</title>
<link href="dox.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.2 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>timer.c</h1><a href="timer_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*! \file timer.c \brief System Timer function library. */</span>
00002 <span class="comment">//*****************************************************************************</span>
00003 <span class="comment">//</span>
00004 <span class="comment">// File Name    : 'timer.c'</span>
00005 <span class="comment">// Title        : System Timer function library</span>
00006 <span class="comment">// Author       : Pascal Stang - Copyright (C) 2000-2002</span>
00007 <span class="comment">// Created      : 11/22/2000</span>
00008 <span class="comment">// Revised      : 07/09/2003</span>
00009 <span class="comment">// Version      : 1.1</span>
00010 <span class="comment">// Target MCU   : Atmel AVR Series</span>
00011 <span class="comment">// Editor Tabs  : 4</span>
00012 <span class="comment">//</span>
00013 <span class="comment">// This code is distributed under the GNU Public License</span>
00014 <span class="comment">//      which can be found at http://www.gnu.org/licenses/gpl.txt</span>
00015 <span class="comment">//</span>
00016 <span class="comment">//*****************************************************************************</span>
00017 
00018 <span class="preprocessor">#include &lt;avr/io.h&gt;</span>
00019 <span class="preprocessor">#include &lt;avr/interrupt.h&gt;</span>
00020 <span class="preprocessor">#include &lt;avr/pgmspace.h&gt;</span>
00021 <span class="preprocessor">#include &lt;avr/sleep.h&gt;</span>
00022 
00023 <span class="preprocessor">#include "<a class="code" href="global_8h.html">global.h</a>"</span>
00024 <span class="preprocessor">#include "<a class="code" href="timer_8h.html">timer.h</a>"</span>
00025 
00026 <span class="preprocessor">#include "<a class="code" href="rprintf_8h.html">rprintf.h</a>"</span>
00027 
00028 <span class="comment">// Program ROM constants</span>
00029 <span class="comment">// the prescale division values stored in order of timer control register index</span>
00030 <span class="comment">// STOP, CLK, CLK/8, CLK/64, CLK/256, CLK/1024</span>
00031 <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> __attribute__ ((progmem)) TimerPrescaleFactor[] = {0,1,8,64,256,1024};
00032 <span class="comment">// the prescale division values stored in order of timer control register index</span>
00033 <span class="comment">// STOP, CLK, CLK/8, CLK/32, CLK/64, CLK/128, CLK/256, CLK/1024</span>
00034 <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> __attribute__ ((progmem)) TimerRTCPrescaleFactor[] = {0,1,8,32,64,128,256,1024};
00035 
00036 <span class="comment">// Global variables</span>
00037 <span class="comment">// time registers</span>
00038 <span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> TimerPauseReg;
00039 <span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> Timer0Reg0;
00040 <span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> Timer2Reg0;
00041 
00042 <span class="keyword">typedef</span> void (*voidFuncPtr)(void);
00043 <span class="keyword">volatile</span> <span class="keyword">static</span> voidFuncPtr TimerIntFunc[TIMER_NUM_INTERRUPTS];
00044 
00045 <span class="comment">// delay for a minimum of &lt;us&gt; microseconds </span>
00046 <span class="comment">// the time resolution is dependent on the time the loop takes </span>
00047 <span class="comment">// e.g. with 4Mhz and 5 cycles per loop, the resolution is 1.25 us </span>
00048 <span class="keywordtype">void</span> delay_us(<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> time_us) 
00049 {
00050     <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> delay_loops;
00051     <span class="keyword">register</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> i;
00052 
00053     delay_loops = (time_us+3)/5*CYCLES_PER_US; <span class="comment">// +3 for rounding up (dirty) </span>
00054 
00055     <span class="comment">// one loop takes 5 cpu cycles </span>
00056     <span class="keywordflow">for</span> (i=0; i &lt; delay_loops; i++) {};
00057 }
00058 <span class="comment">/*</span>
00059 <span class="comment">void delay_ms(unsigned char time_ms)</span>
00060 <span class="comment">{</span>
00061 <span class="comment">    unsigned short delay_count = F_CPU / 4000;</span>
00062 <span class="comment"></span>
00063 <span class="comment">    unsigned short cnt;</span>
00064 <span class="comment">    asm volatile ("\n"</span>
00065 <span class="comment">                  "L_dl1%=:\n\t"</span>
00066 <span class="comment">                  "mov %A0, %A2\n\t"</span>
00067 <span class="comment">                  "mov %B0, %B2\n"</span>
00068 <span class="comment">                  "L_dl2%=:\n\t"</span>
00069 <span class="comment">                  "sbiw %A0, 1\n\t"</span>
00070 <span class="comment">                  "brne L_dl2%=\n\t"</span>
00071 <span class="comment">                  "dec %1\n\t" "brne L_dl1%=\n\t":"=&amp;w" (cnt)</span>
00072 <span class="comment">                  :"r"(time_ms), "r"((unsigned short) (delay_count))</span>
00073 <span class="comment">    );</span>
00074 <span class="comment">}</span>
00075 <span class="comment">*/</span>
<a name="l00076"></a><a class="code" href="group__timerx8.html#ga1">00076</a> <span class="keywordtype">void</span> <a class="code" href="group__timer.html#ga1">timerInit</a>(<span class="keywordtype">void</span>)
00077 {
00078     u08 intNum;
00079     <span class="comment">// detach all user functions from interrupts</span>
00080     <span class="keywordflow">for</span>(intNum=0; intNum&lt;TIMER_NUM_INTERRUPTS; intNum++)
00081         <a class="code" href="group__timer.html#ga9">timerDetach</a>(intNum);
00082 
00083     <span class="comment">// initialize all timers</span>
00084     <a class="code" href="group__timer.html#ga2">timer0Init</a>();
00085     <a class="code" href="group__timer.html#ga3">timer1Init</a>();
00086 <span class="preprocessor">    #ifdef TCNT2    // support timer2 only if it exists</span>
00087 <span class="preprocessor"></span>    timer2Init();
00088 <span class="preprocessor">    #endif</span>
00089 <span class="preprocessor"></span>    <span class="comment">// enable interrupts</span>
00090     sei();
00091 }
00092 
<a name="l00093"></a><a class="code" href="group__timerx8.html#ga2">00093</a> <span class="keywordtype">void</span> <a class="code" href="group__timer.html#ga2">timer0Init</a>()
00094 {
00095     <span class="comment">// initialize timer 0</span>
00096     <a class="code" href="group__timer.html#ga4">timer0SetPrescaler</a>( <a class="code" href="group__timer.html#ga33">TIMER0PRESCALE</a> );   <span class="comment">// set prescaler</span>
00097     outb(TCNT0, 0);                         <span class="comment">// reset TCNT0</span>
00098     sbi(TIMSK, TOIE0);                      <span class="comment">// enable TCNT0 overflow interrupt</span>
00099 
00100     <a class="code" href="group__timer.html#ga11">timer0ClearOverflowCount</a>();             <span class="comment">// initialize time registers</span>
00101 }
00102 
<a name="l00103"></a><a class="code" href="group__timerx8.html#ga3">00103</a> <span class="keywordtype">void</span> <a class="code" href="group__timer.html#ga3">timer1Init</a>(<span class="keywordtype">void</span>)
00104 {
00105     <span class="comment">// initialize timer 1</span>
00106     <a class="code" href="group__timer.html#ga6">timer1SetPrescaler</a>( <a class="code" href="group__timer.html#ga34">TIMER1PRESCALE</a> );   <span class="comment">// set prescaler</span>
00107     outb(TCNT1H, 0);                        <span class="comment">// reset TCNT1</span>
00108     outb(TCNT1L, 0);
00109     sbi(TIMSK, TOIE1);                      <span class="comment">// enable TCNT1 overflow</span>
00110 }
00111 
00112 <span class="preprocessor">#ifdef TCNT2    // support timer2 only if it exists</span>
00113 <span class="preprocessor"></span><span class="keywordtype">void</span> timer2Init(<span class="keywordtype">void</span>)
00114 {
00115     <span class="comment">// initialize timer 2</span>
00116     <a class="code" href="group__timer128.html#ga8">timer2SetPrescaler</a>( <a class="code" href="group__timer.html#ga35">TIMER2PRESCALE</a> );   <span class="comment">// set prescaler</span>
00117     outb(TCNT2, 0);                         <span class="comment">// reset TCNT2</span>
00118     sbi(TIMSK, TOIE2);                      <span class="comment">// enable TCNT2 overflow</span>
00119 
00120     timer2ClearOverflowCount();             <span class="comment">// initialize time registers</span>
00121 }
00122 <span class="preprocessor">#endif</span>
00123 <span class="preprocessor"></span>
<a name="l00124"></a><a class="code" href="group__timerx8.html#ga4">00124</a> <span class="keywordtype">void</span> <a class="code" href="group__timer.html#ga4">timer0SetPrescaler</a>(u08 prescale)
00125 {
00126     <span class="comment">// set prescaler on timer 0</span>
00127     outb(TCCR0, (inb(TCCR0) &amp; ~<a class="code" href="group__timer.html#ga23">TIMER_PRESCALE_MASK</a>) | prescale);
00128 }
00129 
<a name="l00130"></a><a class="code" href="group__timerx8.html#ga6">00130</a> <span class="keywordtype">void</span> <a class="code" href="group__timer.html#ga6">timer1SetPrescaler</a>(u08 prescale)
00131 {
00132     <span class="comment">// set prescaler on timer 1</span>
00133     outb(TCCR1B, (inb(TCCR1B) &amp; ~<a class="code" href="group__timer.html#ga23">TIMER_PRESCALE_MASK</a>) | prescale);
00134 }
00135 
00136 <span class="preprocessor">#ifdef TCNT2    // support timer2 only if it exists</span>
00137 <span class="preprocessor"></span><span class="keywordtype">void</span> <a class="code" href="group__timer128.html#ga8">timer2SetPrescaler</a>(u08 prescale)
00138 {
00139     <span class="comment">// set prescaler on timer 2</span>
00140     outb(TCCR2, (inb(TCCR2) &amp; ~<a class="code" href="group__timer.html#ga23">TIMER_PRESCALE_MASK</a>) | prescale);
00141 }
00142 <span class="preprocessor">#endif</span>
00143 <span class="preprocessor"></span>
<a name="l00144"></a><a class="code" href="group__timerx8.html#ga5">00144</a> u16 <a class="code" href="group__timer.html#ga5">timer0GetPrescaler</a>(<span class="keywordtype">void</span>)
00145 {
00146     <span class="comment">// get the current prescaler setting</span>
00147     <span class="keywordflow">return</span> (pgm_read_word(TimerPrescaleFactor+(inb(TCCR0) &amp; <a class="code" href="group__timer.html#ga23">TIMER_PRESCALE_MASK</a>)));
00148 }
00149 
<a name="l00150"></a><a class="code" href="group__timerx8.html#ga7">00150</a> u16 <a class="code" href="group__timer.html#ga7">timer1GetPrescaler</a>(<span class="keywordtype">void</span>)
00151 {
00152     <span class="comment">// get the current prescaler setting</span>
00153     <span class="keywordflow">return</span> (pgm_read_word(TimerPrescaleFactor+(inb(TCCR1B) &amp; <a class="code" href="group__timer.html#ga23">TIMER_PRESCALE_MASK</a>)));
00154 }
00155 
00156 <span class="preprocessor">#ifdef TCNT2    // support timer2 only if it exists</span>
00157 <span class="preprocessor"></span>u16 <a class="code" href="group__timer128.html#ga12">timer2GetPrescaler</a>(<span class="keywordtype">void</span>)
00158 {
00159     <span class="comment">//TODO: can we assume for all 3-timer AVR processors,</span>
00160     <span class="comment">// that timer2 is the RTC timer?</span>
00161 
00162     <span class="comment">// get the current prescaler setting</span>
00163     <span class="keywordflow">return</span> (pgm_read_word(TimerRTCPrescaleFactor+(inb(TCCR2) &amp; <a class="code" href="group__timer.html#ga23">TIMER_PRESCALE_MASK</a>)));
00164 }
00165 <span class="preprocessor">#endif</span>
00166 <span class="preprocessor"></span>
<a name="l00167"></a><a class="code" href="group__timerx8.html#ga8">00167</a> <span class="keywordtype">void</span> <a class="code" href="group__timer.html#ga8">timerAttach</a>(u08 interruptNum, <span class="keywordtype">void</span> (*userFunc)(<span class="keywordtype">void</span>) )
00168 {
00169     <span class="comment">// make sure the interrupt number is within bounds</span>
00170     <span class="keywordflow">if</span>(interruptNum &lt; TIMER_NUM_INTERRUPTS)
00171     {
00172         <span class="comment">// set the interrupt function to run</span>
00173         <span class="comment">// the supplied user's function</span>
00174         TimerIntFunc[interruptNum] = userFunc;
00175     }
00176 }
00177 
<a name="l00178"></a><a class="code" href="group__timerx8.html#ga9">00178</a> <span class="keywordtype">void</span> <a class="code" href="group__timer.html#ga9">timerDetach</a>(u08 interruptNum)
00179 {
00180     <span class="comment">// make sure the interrupt number is within bounds</span>
00181     <span class="keywordflow">if</span>(interruptNum &lt; TIMER_NUM_INTERRUPTS)
00182     {
00183         <span class="comment">// set the interrupt function to run nothing</span>
00184         TimerIntFunc[interruptNum] = 0;
00185     }
00186 }
00187 <span class="comment">/*</span>
00188 <span class="comment">u32 timerMsToTics(u16 ms)</span>
00189 <span class="comment">{</span>
00190 <span class="comment">    // calculate the prescaler division rate</span>
00191 <span class="comment">    u16 prescaleDiv = 1&lt;&lt;(pgm_read_byte(TimerPrescaleFactor+inb(TCCR0)));</span>
00192 <span class="comment">    // calculate the number of timer tics in x milliseconds</span>
00193 <span class="comment">    return (ms*(F_CPU/(prescaleDiv*256)))/1000;</span>
00194 <span class="comment">}</span>
00195 <span class="comment"></span>
00196 <span class="comment">u16 timerTicsToMs(u32 tics)</span>
00197 <span class="comment">{</span>
00198 <span class="comment">    // calculate the prescaler division rate</span>
00199 <span class="comment">    u16 prescaleDiv = 1&lt;&lt;(pgm_read_byte(TimerPrescaleFactor+inb(TCCR0)));</span>
00200 <span class="comment">    // calculate the number of milliseconds in x timer tics</span>
00201 <span class="comment">    return (tics*1000*(prescaleDiv*256))/F_CPU;</span>
00202 <span class="comment">}</span>
00203 <span class="comment">*/</span>
<a name="l00204"></a><a class="code" href="group__timerx8.html#ga10">00204</a> <span class="keywordtype">void</span> <a class="code" href="group__timer.html#ga10">timerPause</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> pause_ms)
00205 {
00206     <span class="comment">// pauses for exactly &lt;pause_ms&gt; number of milliseconds</span>
00207     u08 timerThres;
00208     u32 ticRateHz;
00209     u32 pause;
00210 
00211     <span class="comment">// capture current pause timer value</span>
00212     timerThres = inb(TCNT0);
00213     <span class="comment">// reset pause timer overflow count</span>
00214     TimerPauseReg = 0;
00215     <span class="comment">// calculate delay for [pause_ms] milliseconds</span>
00216     <span class="comment">// prescaler division = 1&lt;&lt;(pgm_read_byte(TimerPrescaleFactor+inb(TCCR0)))</span>
00217     ticRateHz = F_CPU/<a class="code" href="group__timer.html#ga5">timer0GetPrescaler</a>();
00218     <span class="comment">// precision management</span>
00219     <span class="comment">// prevent overflow and precision underflow</span>
00220     <span class="comment">//  -could add more conditions to improve accuracy</span>
00221     <span class="keywordflow">if</span>( ((ticRateHz &lt; 429497) &amp;&amp; (pause_ms &lt;= 10000)) )
00222         pause = (pause_ms*ticRateHz)/1000;
00223     <span class="keywordflow">else</span>
00224         pause = pause_ms*(ticRateHz/1000);
00225 
00226     <span class="comment">// loop until time expires</span>
00227     <span class="keywordflow">while</span>( ((TimerPauseReg&lt;&lt;8) | inb(TCNT0)) &lt; (pause+timerThres) )
00228     {
00229         <span class="keywordflow">if</span>( TimerPauseReg &lt; (pause&gt;&gt;8));
00230         {
00231             <span class="comment">// save power by idling the processor</span>
00232             set_sleep_mode(SLEEP_MODE_IDLE);
00233             sleep_mode();
00234         }
00235     }
00236 
00237     <span class="comment">/* old inaccurate code, for reference</span>
00238 <span class="comment">    </span>
00239 <span class="comment">    // calculate delay for [pause_ms] milliseconds</span>
00240 <span class="comment">    u16 prescaleDiv = 1&lt;&lt;(pgm_read_byte(TimerPrescaleFactor+inb(TCCR0)));</span>
00241 <span class="comment">    u32 pause = (pause_ms*(F_CPU/(prescaleDiv*256)))/1000;</span>
00242 <span class="comment">    </span>
00243 <span class="comment">    TimerPauseReg = 0;</span>
00244 <span class="comment">    while(TimerPauseReg &lt; pause);</span>
00245 <span class="comment"></span>
00246 <span class="comment">    */</span>
00247 }
00248 
<a name="l00249"></a><a class="code" href="group__timerx8.html#ga11">00249</a> <span class="keywordtype">void</span> <a class="code" href="group__timer.html#ga11">timer0ClearOverflowCount</a>(<span class="keywordtype">void</span>)
00250 {
00251     <span class="comment">// clear the timer overflow counter registers</span>
00252     Timer0Reg0 = 0; <span class="comment">// initialize time registers</span>
00253 }
00254 
<a name="l00255"></a><a class="code" href="group__timerx8.html#ga12">00255</a> <span class="keywordtype">long</span> <a class="code" href="group__timer.html#ga12">timer0GetOverflowCount</a>(<span class="keywordtype">void</span>)
00256 {
00257     <span class="comment">// return the current timer overflow count</span>
00258     <span class="comment">// (this is since the last timer0ClearOverflowCount() command was called)</span>
00259     <span class="keywordflow">return</span> Timer0Reg0;
00260 }
00261 
00262 <span class="preprocessor">#ifdef TCNT2    // support timer2 only if it exists</span>
00263 <span class="preprocessor"></span><span class="keywordtype">void</span> timer2ClearOverflowCount(<span class="keywordtype">void</span>)
00264 {
00265     <span class="comment">// clear the timer overflow counter registers</span>
00266     Timer2Reg0 = 0; <span class="comment">// initialize time registers</span>
00267 }
00268 
00269 <span class="keywordtype">long</span> timer2GetOverflowCount(<span class="keywordtype">void</span>)
00270 {
00271     <span class="comment">// return the current timer overflow count</span>
00272     <span class="comment">// (this is since the last timer2ClearOverflowCount() command was called)</span>
00273     <span class="keywordflow">return</span> Timer2Reg0;
00274 }
00275 <span class="preprocessor">#endif</span>
00276 <span class="preprocessor"></span>
<a name="l00277"></a><a class="code" href="group__timerpwm.html#ga0">00277</a> <span class="keywordtype">void</span> <a class="code" href="group__timerpwm.html#ga0">timer1PWMInit</a>(u08 bitRes)
00278 {
00279     <span class="comment">// configures timer1 for use with PWM output</span>
00280     <span class="comment">// on OC1A and OC1B pins</span>
00281 
00282     <span class="comment">// enable timer1 as 8,9,10bit PWM</span>
00283     <span class="keywordflow">if</span>(bitRes == 9)
00284     {   <span class="comment">// 9bit mode</span>
00285         sbi(TCCR1A,PWM11);
00286         cbi(TCCR1A,PWM10);
00287     }
00288     <span class="keywordflow">else</span> <span class="keywordflow">if</span>( bitRes == 10 )
00289     {   <span class="comment">// 10bit mode</span>
00290         sbi(TCCR1A,PWM11);
00291         sbi(TCCR1A,PWM10);
00292     }
00293     <span class="keywordflow">else</span>
00294     {   <span class="comment">// default 8bit mode</span>
00295         cbi(TCCR1A,PWM11);
00296         sbi(TCCR1A,PWM10);
00297     }
00298 
00299     <span class="comment">// clear output compare value A</span>
00300     outb(OCR1AH, 0);
00301     outb(OCR1AL, 0);
00302     <span class="comment">// clear output compare value B</span>
00303     outb(OCR1BH, 0);
00304     outb(OCR1BL, 0);
00305 }
00306 
00307 <span class="preprocessor">#ifdef WGM10</span>
00308 <span class="preprocessor"></span><span class="comment">// include support for arbitrary top-count PWM</span>
00309 <span class="comment">// on new AVR processors that support it</span>
00310 <span class="keywordtype">void</span> <a class="code" href="group__timerpwm.html#ga1">timer1PWMInitICR</a>(u16 topcount)
00311 {
00312     <span class="comment">// set PWM mode with ICR top-count</span>
00313     cbi(TCCR1A,WGM10);
00314     sbi(TCCR1A,WGM11);
00315     sbi(TCCR1B,WGM12);
00316     sbi(TCCR1B,WGM13);
00317     
00318     <span class="comment">// set top count value</span>
00319     ICR1 = topcount;
00320     
00321     <span class="comment">// clear output compare value A</span>
00322     OCR1A = 0;
00323     <span class="comment">// clear output compare value B</span>
00324     OCR1B = 0;
00325 
00326 }
00327 <span class="preprocessor">#endif</span>
00328 <span class="preprocessor"></span>
<a name="l00329"></a><a class="code" href="group__timer128.html#ga23">00329</a> <span class="keywordtype">void</span> <a class="code" href="group__timerpwm.html#ga2">timer1PWMOff</a>(<span class="keywordtype">void</span>)
00330 {
00331     <span class="comment">// turn off timer1 PWM mode</span>
00332     cbi(TCCR1A,PWM11);
00333     cbi(TCCR1A,PWM10);
00334     <span class="comment">// set PWM1A/B (OutputCompare action) to none</span>
00335     <a class="code" href="group__timerpwm.html#ga5">timer1PWMAOff</a>();
00336     <a class="code" href="group__timerpwm.html#ga6">timer1PWMBOff</a>();
00337 }
00338 
<a name="l00339"></a><a class="code" href="group__timer128.html#ga24">00339</a> <span class="keywordtype">void</span> <a class="code" href="group__timerpwm.html#ga3">timer1PWMAOn</a>(<span class="keywordtype">void</span>)
00340 {
00341     <span class="comment">// turn on channel A (OC1A) PWM output</span>
00342     <span class="comment">// set OC1A as non-inverted PWM</span>
00343     sbi(TCCR1A,COM1A1);
00344     cbi(TCCR1A,COM1A0);
00345 }
00346 
<a name="l00347"></a><a class="code" href="group__timer128.html#ga25">00347</a> <span class="keywordtype">void</span> <a class="code" href="group__timerpwm.html#ga4">timer1PWMBOn</a>(<span class="keywordtype">void</span>)
00348 {
00349     <span class="comment">// turn on channel B (OC1B) PWM output</span>
00350     <span class="comment">// set OC1B as non-inverted PWM</span>
00351     sbi(TCCR1A,COM1B1);
00352     cbi(TCCR1A,COM1B0);
00353 }
00354 
<a name="l00355"></a><a class="code" href="group__timer128.html#ga27">00355</a> <span class="keywordtype">void</span> <a class="code" href="group__timerpwm.html#ga5">timer1PWMAOff</a>(<span class="keywordtype">void</span>)
00356 {
00357     <span class="comment">// turn off channel A (OC1A) PWM output</span>
00358     <span class="comment">// set OC1A (OutputCompare action) to none</span>
00359     cbi(TCCR1A,COM1A1);
00360     cbi(TCCR1A,COM1A0);
00361 }
00362 
<a name="l00363"></a><a class="code" href="group__timer128.html#ga28">00363</a> <span class="keywordtype">void</span> <a class="code" href="group__timerpwm.html#ga6">timer1PWMBOff</a>(<span class="keywordtype">void</span>)
00364 {
00365     <span class="comment">// turn off channel B (OC1B) PWM output</span>
00366     <span class="comment">// set OC1B (OutputCompare action) to none</span>
00367     cbi(TCCR1A,COM1B1);
00368     cbi(TCCR1A,COM1B0);
00369 }
00370 
<a name="l00371"></a><a class="code" href="group__timer128.html#ga30">00371</a> <span class="keywordtype">void</span> <a class="code" href="group__timerpwm.html#ga7">timer1PWMASet</a>(u16 pwmDuty)
00372 {
00373     <span class="comment">// set PWM (output compare) duty for channel A</span>
00374     <span class="comment">// this PWM output is generated on OC1A pin</span>
00375     <span class="comment">// NOTE:    pwmDuty should be in the range 0-255 for 8bit PWM</span>
00376     <span class="comment">//          pwmDuty should be in the range 0-511 for 9bit PWM</span>
00377     <span class="comment">//          pwmDuty should be in the range 0-1023 for 10bit PWM</span>
00378     <span class="comment">//outp( (pwmDuty&gt;&gt;8), OCR1AH);      // set the high 8bits of OCR1A</span>
00379     <span class="comment">//outp( (pwmDuty&amp;0x00FF), OCR1AL);  // set the low 8bits of OCR1A</span>
00380     OCR1A = pwmDuty;
00381 }
00382 
<a name="l00383"></a><a class="code" href="group__timer128.html#ga31">00383</a> <span class="keywordtype">void</span> <a class="code" href="group__timerpwm.html#ga8">timer1PWMBSet</a>(u16 pwmDuty)
00384 {
00385     <span class="comment">// set PWM (output compare) duty for channel B</span>
00386     <span class="comment">// this PWM output is generated on OC1B pin</span>
00387     <span class="comment">// NOTE:    pwmDuty should be in the range 0-255 for 8bit PWM</span>
00388     <span class="comment">//          pwmDuty should be in the range 0-511 for 9bit PWM</span>
00389     <span class="comment">//          pwmDuty should be in the range 0-1023 for 10bit PWM</span>
00390     <span class="comment">//outp( (pwmDuty&gt;&gt;8), OCR1BH);      // set the high 8bits of OCR1B</span>
00391     <span class="comment">//outp( (pwmDuty&amp;0x00FF), OCR1BL);  // set the low 8bits of OCR1B</span>
00392     OCR1B = pwmDuty;
00393 }
00394 <span class="comment"></span>
00395 <span class="comment">//! Interrupt handler for tcnt0 overflow interrupt</span>
<a name="l00396"></a><a class="code" href="timer_8c.html#a27">00396</a> <span class="comment"></span>TIMER_INTERRUPT_HANDLER(SIG_OVERFLOW0)
00397 {
00398     Timer0Reg0++;           <span class="comment">// increment low-order counter</span>
00399 
00400     <span class="comment">// increment pause counter</span>
00401     TimerPauseReg++;
00402 
00403     <span class="comment">// if a user function is defined, execute it too</span>
00404     <span class="keywordflow">if</span>(TimerIntFunc[TIMER0OVERFLOW_INT])
00405         TimerIntFunc[TIMER0OVERFLOW_INT]();
00406 }
00407 <span class="comment"></span>
00408 <span class="comment">//! Interrupt handler for tcnt1 overflow interrupt</span>
<a name="l00409"></a><a class="code" href="timer_8c.html#a28">00409</a> <span class="comment"></span>TIMER_INTERRUPT_HANDLER(SIG_OVERFLOW1)
00410 {
00411     <span class="comment">// if a user function is defined, execute it</span>
00412     <span class="keywordflow">if</span>(TimerIntFunc[TIMER1OVERFLOW_INT])
00413         TimerIntFunc[TIMER1OVERFLOW_INT]();
00414 }
00415 
00416 <span class="preprocessor">#ifdef TCNT2    // support timer2 only if it exists</span>
00417 <span class="preprocessor"></span><span class="comment">//! Interrupt handler for tcnt2 overflow interrupt</span>
00418 <span class="comment"></span>TIMER_INTERRUPT_HANDLER(SIG_OVERFLOW2)
00419 {
00420     Timer2Reg0++;           <span class="comment">// increment low-order counter</span>
00421 
00422     <span class="comment">// if a user function is defined, execute it</span>
00423     <span class="keywordflow">if</span>(TimerIntFunc[TIMER2OVERFLOW_INT])
00424         TimerIntFunc[TIMER2OVERFLOW_INT]();
00425 }
00426 <span class="preprocessor">#endif</span>
00427 <span class="preprocessor"></span>
00428 <span class="preprocessor">#ifdef OCR0</span>
00429 <span class="preprocessor"></span><span class="comment">// include support for Output Compare 0 for new AVR processors that support it</span><span class="comment"></span>
00430 <span class="comment">//! Interrupt handler for OutputCompare0 match (OC0) interrupt</span>
00431 <span class="comment"></span>TIMER_INTERRUPT_HANDLER(SIG_OUTPUT_COMPARE0)
00432 {
00433     <span class="comment">// if a user function is defined, execute it</span>
00434     <span class="keywordflow">if</span>(TimerIntFunc[TIMER0OUTCOMPARE_INT])
00435         TimerIntFunc[TIMER0OUTCOMPARE_INT]();
00436 }
00437 <span class="preprocessor">#endif</span>
00438 <span class="preprocessor"></span><span class="comment"></span>
00439 <span class="comment">//! Interrupt handler for CutputCompare1A match (OC1A) interrupt</span>
<a name="l00440"></a><a class="code" href="timer_8c.html#a29">00440</a> <span class="comment"></span>TIMER_INTERRUPT_HANDLER(SIG_OUTPUT_COMPARE1A)
00441 {
00442     <span class="comment">// if a user function is defined, execute it</span>
00443     <span class="keywordflow">if</span>(TimerIntFunc[TIMER1OUTCOMPAREA_INT])
00444         TimerIntFunc[TIMER1OUTCOMPAREA_INT]();
00445 }
00446 <span class="comment"></span>
00447 <span class="comment">//! Interrupt handler for OutputCompare1B match (OC1B) interrupt</span>
<a name="l00448"></a><a class="code" href="timer_8c.html#a30">00448</a> <span class="comment"></span>TIMER_INTERRUPT_HANDLER(SIG_OUTPUT_COMPARE1B)
00449 {
00450     <span class="comment">// if a user function is defined, execute it</span>
00451     <span class="keywordflow">if</span>(TimerIntFunc[TIMER1OUTCOMPAREB_INT])
00452         TimerIntFunc[TIMER1OUTCOMPAREB_INT]();
00453 }
00454 <span class="comment"></span>
00455 <span class="comment">//! Interrupt handler for InputCapture1 (IC1) interrupt</span>
<a name="l00456"></a><a class="code" href="timer_8c.html#a31">00456</a> <span class="comment"></span>TIMER_INTERRUPT_HANDLER(SIG_INPUT_CAPTURE1)
00457 {
00458     <span class="comment">// if a user function is defined, execute it</span>
00459     <span class="keywordflow">if</span>(TimerIntFunc[TIMER1INPUTCAPTURE_INT])
00460         TimerIntFunc[TIMER1INPUTCAPTURE_INT]();
00461 }
00462 <span class="comment"></span>
00463 <span class="comment">//! Interrupt handler for OutputCompare2 match (OC2) interrupt</span>
<a name="l00464"></a><a class="code" href="timer_8c.html#a32">00464</a> <span class="comment"></span>TIMER_INTERRUPT_HANDLER(SIG_OUTPUT_COMPARE2)
00465 {
00466     <span class="comment">// if a user function is defined, execute it</span>
00467     <span class="keywordflow">if</span>(TimerIntFunc[TIMER2OUTCOMPARE_INT])
00468         TimerIntFunc[TIMER2OUTCOMPARE_INT]();
00469 }
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Sun Oct 29 03:41:07 2006 for Procyon AVRlib by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.2 </small></address>
</body>
</html>
