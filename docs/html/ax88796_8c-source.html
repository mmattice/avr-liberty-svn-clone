<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Procyon AVRlib: net/ax88796.c Source File</title>
<link href="dox.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.2 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<div class="nav">
<a class="el" href="dir_000001.html">net</a></div>
<h1>ax88796.c</h1><a href="ax88796_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*! \file ax88796.c \brief ASIX AX88796 Ethernet Interface Driver. */</span>
00002 <span class="comment">//*****************************************************************************</span>
00003 <span class="comment">//</span>
00004 <span class="comment">// File Name    : 'ax88796.c'</span>
00005 <span class="comment">// Title        : ASIX AX88796 Ethernet Interface Driver</span>
00006 <span class="comment">// Author       : Pascal Stang</span>
00007 <span class="comment">// Created      : 10/22/2002</span>
00008 <span class="comment">// Revised      : 8/21/2005</span>
00009 <span class="comment">// Version      : 0.1</span>
00010 <span class="comment">// Target MCU   : Atmel AVR series</span>
00011 <span class="comment">// Editor Tabs  : 4</span>
00012 <span class="comment">//</span>
00013 <span class="comment">// Description  : This driver provides initialization and transmit/receive</span>
00014 <span class="comment">//      functions for the ASIX AX88796 10/100Mb Ethernet Controller and PHY.</span>
00015 <span class="comment">//</span>
00016 <span class="comment">// Based in part on code by Louis Beaudoin (www.embedded-creations.com).</span>
00017 <span class="comment">// Thanks to Adam Dunkels and Louis Beaudoin for providing the initial</span>
00018 <span class="comment">// structure in which to write this driver.</span>
00019 <span class="comment">//</span>
00020 <span class="comment">//*****************************************************************************</span>
00021 
00022 <span class="preprocessor">#include "<a class="code" href="global_8h.html">global.h</a>"</span>
00023 <span class="preprocessor">#include "<a class="code" href="timer_8h.html">timer.h</a>"</span>
00024 <span class="preprocessor">#include "<a class="code" href="rprintf_8h.html">rprintf.h</a>"</span>
00025 
00026 <span class="preprocessor">#include "<a class="code" href="ax88796_8h.html">ax88796.h</a>"</span>
00027 
00028 <span class="comment">// include configuration</span>
00029 <span class="preprocessor">#include "<a class="code" href="ax88796conf_8h.html">ax88796conf.h</a>"</span>
00030 
00031 <span class="comment">// pointers to locations in the ax88796 receive buffer</span>
00032 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> NextPage;              <span class="comment">// page pointer to next Rx packet</span>
00033 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> CurrentRetreiveAddress; <span class="comment">// DMA address for read Rx packet location</span>
00034 
00035 
<a name="l00036"></a><a class="code" href="group__nic.html#ga0">00036</a> <span class="keywordtype">void</span> <a class="code" href="group__nic.html#ga0">nicInit</a>(<span class="keywordtype">void</span>)
00037 {
00038     ax88796Init();
00039 }
00040 
<a name="l00041"></a><a class="code" href="group__nic.html#ga1">00041</a> <span class="keywordtype">void</span> <a class="code" href="group__nic.html#ga1">nicSend</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> len, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* packet)
00042 {
00043     ax88796BeginPacketSend(len);
00044     ax88796SendPacketData(packet, len);
00045     ax88796EndPacketSend();
00046 }
00047 
<a name="l00048"></a><a class="code" href="group__nic.html#ga2">00048</a> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="group__nic.html#ga2">nicPoll</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxlen, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* packet)
00049 {
00050     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> packetLength;
00051     
00052     packetLength = ax88796BeginPacketRetreive();
00053 
00054     <span class="comment">// if there's no packet or an error - exit without ending the operation</span>
00055     <span class="keywordflow">if</span>( !packetLength )
00056         <span class="keywordflow">return</span> 0;
00057 
00058     <span class="comment">// drop anything too big for the buffer</span>
00059     <span class="keywordflow">if</span>( packetLength &gt; maxlen )
00060     {
00061         ax88796EndPacketRetreive();
00062         <span class="keywordflow">return</span> 0;
00063     }
00064     
00065     <span class="comment">// copy the packet data into the uIP packet buffer</span>
00066     ax88796RetreivePacketData( packet, packetLength );
00067     ax88796EndPacketRetreive();
00068         
00069     <span class="keywordflow">return</span> packetLength;
00070 }
00071 
00072 <span class="keywordtype">void</span> nicGetMacAddress(u08* macaddr)
00073 {
00074     u08 tempCR;
00075     <span class="comment">// switch register pages</span>
00076     tempCR = ax88796Read(CR);
00077     ax88796Write(CR,tempCR|PS0);
00078     <span class="comment">// read MAC address registers</span>
00079     *macaddr++ = ax88796Read(PAR0);
00080     *macaddr++ = ax88796Read(PAR1);
00081     *macaddr++ = ax88796Read(PAR2);
00082     *macaddr++ = ax88796Read(PAR3);
00083     *macaddr++ = ax88796Read(PAR4);
00084     *macaddr++ = ax88796Read(PAR5);
00085     <span class="comment">// switch register pages back</span>
00086     ax88796Write(CR,tempCR);
00087 }
00088 
00089 <span class="keywordtype">void</span> nicSetMacAddress(u08* macaddr)
00090 {
00091     u08 tempCR;
00092     <span class="comment">// switch register pages</span>
00093     tempCR = ax88796Read(CR);
00094     ax88796Write(CR,tempCR|PS0);
00095     <span class="comment">// write MAC address registers</span>
00096     ax88796Write(PAR0, *macaddr++);
00097     ax88796Write(PAR1, *macaddr++);
00098     ax88796Write(PAR2, *macaddr++);
00099     ax88796Write(PAR3, *macaddr++);
00100     ax88796Write(PAR4, *macaddr++);
00101     ax88796Write(PAR5, *macaddr++);
00102     <span class="comment">// switch register pages back</span>
00103     ax88796Write(CR,tempCR);
00104 }
00105 
<a name="l00106"></a><a class="code" href="group__nic.html#ga5">00106</a> <span class="keywordtype">void</span> <a class="code" href="group__nic.html#ga5">nicRegDump</a>(<span class="keywordtype">void</span>)
00107 {
00108     ax88796RegDump();
00109 }
00110 
00111 
00112 <span class="keywordtype">void</span> ax88796SetupPorts(<span class="keywordtype">void</span>)
00113 {
00114 <span class="preprocessor">#if NIC_CONNECTION == MEMORY_MAPPED</span>
00115 <span class="preprocessor"></span>    <span class="comment">// enable external SRAM interface - no wait states</span>
00116     sbi(MCUCR, SRE);
00117 <span class="comment">//  sbi(MCUCR, SRW10);</span>
00118 <span class="comment">//  sbi(XMCRA, SRW00);</span>
00119 <span class="comment">//  sbi(XMCRA, SRW01);</span>
00120 <span class="comment">//  sbi(XMCRA, SRW11);</span>
00121 <span class="preprocessor">#else</span>
00122 <span class="preprocessor"></span>    <span class="comment">// set address port to output</span>
00123     AX88796_ADDRESS_DDR = AX88796_ADDRESS_MASK;
00124     
00125     <span class="comment">// set data port to input with pull-ups</span>
00126     AX88796_DATA_DDR = 0x00;
00127     AX88796_DATA_PORT = 0xFF;
00128 
00129     <span class="comment">// initialize the control port read and write pins to de-asserted</span>
00130     sbi( AX88796_CONTROL_PORT, AX88796_CONTROL_READPIN );
00131     sbi( AX88796_CONTROL_PORT, AX88796_CONTROL_WRITEPIN );
00132     <span class="comment">// set the read and write pins to output</span>
00133     sbi( AX88796_CONTROL_DDR, AX88796_CONTROL_READPIN );
00134     sbi( AX88796_CONTROL_DDR, AX88796_CONTROL_WRITEPIN );
00135 <span class="preprocessor">#endif</span>
00136 <span class="preprocessor"></span>    <span class="comment">// set reset pin to output</span>
00137     sbi( AX88796_RESET_DDR, AX88796_RESET_PIN );
00138 }
00139 
00140 
00141 <span class="preprocessor">#if NIC_CONNECTION == MEMORY_MAPPED</span>
00142 <span class="preprocessor"></span><span class="keyword">inline</span> <span class="keywordtype">void</span> ax88796Write(u08 address, u08 data)
00143 {
00144     *(<span class="keyword">volatile</span> u08*)(AX88796_MEMORY_MAPPED_OFFSET + address) = data;
00145 }
00146 <span class="preprocessor">#else</span>
00147 <span class="preprocessor"></span><span class="keywordtype">void</span> ax88796Write(u08 address, u08 data)
00148 {
00149     <span class="comment">// assert the address</span>
00150     AX88796_ADDRESS_PORT = address | (AX88796_ADDRESS_PORT&amp;~AX88796_ADDRESS_MASK);
00151 
00152     <span class="comment">// set data bus as output and place data on bus</span>
00153     AX88796_DATA_DDR = 0xFF;
00154     AX88796_DATA_PORT = data;
00155     
00156     <span class="comment">// clock write pin</span>
00157     cbi(AX88796_CONTROL_PORT, AX88796_CONTROL_WRITEPIN);
00158     nop();
00159     nop();
00160     sbi(AX88796_CONTROL_PORT, AX88796_CONTROL_WRITEPIN);
00161     
00162     <span class="comment">// set data bus back to input with pullups enabled</span>
00163     AX88796_DATA_DDR = 0x00;
00164     AX88796_DATA_PORT = 0xFF;
00165 }
00166 <span class="preprocessor">#endif</span>
00167 <span class="preprocessor"></span>
00168 
00169 <span class="preprocessor">#if NIC_CONNECTION == MEMORY_MAPPED</span>
00170 <span class="preprocessor"></span><span class="keyword">inline</span> u08 ax88796Read(u08 address)
00171 {
00172     <span class="keywordflow">return</span> *(<span class="keyword">volatile</span> u08*)(AX88796_MEMORY_MAPPED_OFFSET + address);
00173 }
00174 <span class="preprocessor">#else</span>
00175 <span class="preprocessor"></span>u08 ax88796Read(u08 address)
00176 {
00177     u08 data;
00178    
00179     <span class="comment">// assert the address</span>
00180     AX88796_ADDRESS_PORT = address | (AX88796_ADDRESS_PORT&amp;~AX88796_ADDRESS_MASK);
00181 
00182     <span class="comment">// assert read</span>
00183     cbi(AX88796_CONTROL_PORT, AX88796_CONTROL_READPIN);
00184     nop();
00185     nop();
00186     <span class="comment">// read in the data</span>
00187     data = AX88796_DATA_PIN;
00188 
00189     <span class="comment">// negate read</span>
00190     sbi(AX88796_CONTROL_PORT, AX88796_CONTROL_READPIN);
00191 
00192     <span class="keywordflow">return</span> data;
00193 }
00194 <span class="preprocessor">#endif                       </span>
00195 <span class="preprocessor"></span>
00196 
00197 <span class="keywordtype">void</span> ax88796Init(<span class="keywordtype">void</span>)
00198 {
00199     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> tcrFduFlag;
00200     
00201     <span class="comment">// initialize I/O ports</span>
00202     ax88796SetupPorts();
00203 
00204     <span class="comment">// do a hard reset</span>
00205     sbi(AX88796_RESET_PORT, AX88796_RESET_PIN);
00206     delay_ms(100);
00207     cbi(AX88796_RESET_PORT, AX88796_RESET_PIN);
00208 
00209     <span class="comment">// do soft reset</span>
00210     ax88796Write(ISR, ax88796Read(ISR));
00211     delay_ms(50);
00212 
00213     <span class="comment">// wait for PHY to come out of reset</span>
00214     ax88796Read(RSTPORT);
00215     <span class="keywordflow">while</span>(ax88796Read(TR) &amp; RST_B);
00216   
00217     ax88796WriteMii(0x10,0x00,0x0800);
00218     delay_ms(255);
00219     ax88796WriteMii(0x10,0x00,0x1200);
00220 
00221     ax88796Write(CR,(RD2|STOP));        <span class="comment">// stop the NIC, abort DMA, page 0</span>
00222     delay_ms(5);                        <span class="comment">// make sure nothing is coming in or going out</span>
00223     ax88796Write(DCR,DCR_INIT);    
00224     ax88796Write(RBCR0,0x00);
00225     ax88796Write(RBCR1,0x00);
00226     ax88796Write(IMR,0x00);
00227     ax88796Write(ISR,0xFF);
00228     ax88796Write(RCR,0x20);
00229     ax88796Write(BNRY,RXSTART_INIT);
00230     ax88796Write(PSTART,RXSTART_INIT);
00231     ax88796Write(PSTOP,RXSTOP_INIT);
00232     
00233     <span class="comment">// switch to page 1</span>
00234     ax88796Write(CR,(PS0|RD2|STOP));
00235     <span class="comment">// write mac address</span>
00236     ax88796Write(PAR0+0, AX88796_MAC0);
00237     ax88796Write(PAR0+1, AX88796_MAC1);
00238     ax88796Write(PAR0+2, AX88796_MAC2);
00239     ax88796Write(PAR0+3, AX88796_MAC3);
00240     ax88796Write(PAR0+4, AX88796_MAC4);
00241     ax88796Write(PAR0+5, AX88796_MAC5);
00242     <span class="comment">// set start point</span>
00243     ax88796Write(CURR,RXSTART_INIT+1);
00244 
00245     ax88796Write(CR,(RD2|START));
00246     ax88796Write(RCR,RCR_INIT);
00247 
00248     <span class="keywordflow">if</span>(ax88796Read(GPI) &amp; I_SPD)        <span class="comment">// check PHY speed setting</span>
00249         tcrFduFlag = FDU;               <span class="comment">// if 100base, do full duplex</span>
00250     <span class="keywordflow">else</span>
00251         tcrFduFlag = 0;                 <span class="comment">// if 10base, do half duplex</span>
00252         
00253     ax88796Write(TCR,(tcrFduFlag|TCR_INIT));
00254 
00255     ax88796Write(GPOC,MPSEL);           <span class="comment">// select media interface</span>
00256   
00257     ax88796Write(TPSR,TXSTART_INIT);
00258 
00259     ax88796Write(CR,(RD2|STOP));
00260     ax88796Write(DCR,DCR_INIT);
00261     ax88796Write(CR,(RD2|START));
00262     ax88796Write(ISR,0xFF);
00263     ax88796Write(IMR,IMR_INIT);
00264     ax88796Write(TCR,(tcrFduFlag|TCR_INIT));
00265 
00266     <span class="comment">//test</span>
00267 <span class="comment">/*</span>
00268 <span class="comment">    while(1)</span>
00269 <span class="comment">    {</span>
00270 <span class="comment">        vt100SetCursorPos(18,0);</span>
00271 <span class="comment">        ax88796RegDump();</span>
00272 <span class="comment">    }</span>
00273 <span class="comment">*/</span>
00274 }
00275 
00276 
00277 <span class="keywordtype">void</span> ax88796BeginPacketSend(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> packetLength)
00278 {
00279     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sendPacketLength;
00280     sendPacketLength = (packetLength&gt;=ETHERNET_MIN_PACKET_LENGTH)?
00281                         (packetLength):(ETHERNET_MIN_PACKET_LENGTH);
00282     
00283     <span class="comment">//start the NIC</span>
00284     ax88796Write(CR,(RD2|START));
00285     
00286     <span class="comment">// still transmitting a packet - wait for it to finish</span>
00287     <span class="keywordflow">while</span>( ax88796Read(CR) &amp; TXP );
00288 
00289     <span class="comment">//load beginning page for transmit buffer</span>
00290     ax88796Write(TPSR,TXSTART_INIT);
00291     
00292     <span class="comment">//set start address for remote DMA operation</span>
00293     ax88796Write(RSAR0,0x00);
00294     ax88796Write(RSAR1,0x40);
00295     
00296     <span class="comment">//clear the packet stored interrupt</span>
00297     ax88796Write(ISR, PTX);
00298 
00299     <span class="comment">//load data byte count for remote DMA</span>
00300     ax88796Write(RBCR0, (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)(packetLength));
00301     ax88796Write(RBCR1, (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)(packetLength&gt;&gt;8));
00302 
00303     ax88796Write(TBCR0, (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)(sendPacketLength));
00304     ax88796Write(TBCR1, (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)((sendPacketLength)&gt;&gt;8));
00305     
00306     <span class="comment">//do remote write operation</span>
00307     ax88796Write(CR,0x12);
00308 }
00309 
00310 
00311 <span class="keywordtype">void</span> ax88796SendPacketData(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> * localBuffer, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> length)
00312 {
00313     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;
00314     
00315     <span class="keywordflow">for</span>(i=0;i&lt;length;i++)
00316         ax88796Write(RDMAPORT, localBuffer[i]);
00317 }
00318 
00319 
00320 <span class="keywordtype">void</span> ax88796EndPacketSend(<span class="keywordtype">void</span>)
00321 {
00322     <span class="comment">//send the contents of the transmit buffer onto the network</span>
00323     ax88796Write(CR,(RD2|TXP));
00324     
00325     <span class="comment">// clear the remote DMA interrupt</span>
00326     ax88796Write(ISR, RDC);
00327 }
00328 
00329 
00330 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ax88796BeginPacketRetreive(<span class="keywordtype">void</span>)
00331 {
00332     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> writePagePtr;
00333     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> readPagePtr;
00334     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> bnryPagePtr;
00335     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> i;
00336     
00337     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> pageheader[4];
00338     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> rxlen;
00339     
00340     <span class="comment">// check for and handle an overflow</span>
00341     ax88796ProcessInterrupt();
00342     
00343     <span class="comment">// read CURR from page 1</span>
00344     ax88796Write(CR,(PS0|RD2|START));
00345     writePagePtr = ax88796Read(CURR);
00346     <span class="comment">// read the boundary register from page 0</span>
00347     ax88796Write(CR,(RD2|START));
00348     bnryPagePtr = ax88796Read(BNRY);
00349 
00350     <span class="comment">// first packet is at page bnryPtr+1</span>
00351     readPagePtr = bnryPagePtr+1;
00352     <span class="keywordflow">if</span>(readPagePtr &gt;= RXSTOP_INIT) readPagePtr = RXSTART_INIT;
00353     
00354     <span class="comment">// return if there is no packet in the buffer</span>
00355     <span class="keywordflow">if</span>( readPagePtr == writePagePtr )
00356     {
00357         <span class="keywordflow">return</span> 0;
00358     }
00359     
00360     <span class="comment">// clear the packet received interrupt flag</span>
00361     ax88796Write(ISR, PRX);
00362     
00363     <span class="comment">// if the boundary pointer is invalid,</span>
00364     <span class="comment">// reset the contents of the buffer and exit</span>
00365     <span class="keywordflow">if</span>( (bnryPagePtr &lt; RXSTART_INIT) || (bnryPagePtr &gt;= RXSTOP_INIT) )
00366     {
00367         ax88796Write(BNRY, RXSTART_INIT);
00368         ax88796Write(CR, (PS0|RD2|START));
00369         ax88796Write(CURR, RXSTART_INIT+1);
00370         ax88796Write(CR, (RD2|START));
00371         
00372 <span class="comment">//      rprintf("B");</span>
00373         <span class="keywordflow">return</span> 0;
00374     }
00375 
00376     <span class="comment">// initiate DMA to transfer the RTL8019 packet header</span>
00377     ax88796Write(RBCR0, 4);
00378     ax88796Write(RBCR1, 0);
00379     ax88796Write(RSAR0, 0);
00380     ax88796Write(RSAR1, readPagePtr);
00381     ax88796Write(CR, (RD0|START));
00382     <span class="keywordflow">for</span>(i=0;i&lt;4;i++)
00383         pageheader[i] = ax88796Read(RDMAPORT);
00384 
00385     <span class="comment">// end the DMA operation</span>
00386     ax88796Write(CR, (RD2|START));
00387     <span class="keywordflow">for</span>(i = 0; i &lt;= 20; i++)
00388         <span class="keywordflow">if</span>(ax88796Read(ISR) &amp; RDC)
00389             <span class="keywordflow">break</span>;
00390     ax88796Write(ISR, RDC);
00391     
00392     rxlen = (pageheader[PKTHEADER_PKTLENH]&lt;&lt;8) + pageheader[PKTHEADER_PKTLENL];
00393     NextPage = pageheader[PKTHEADER_NEXTPAGE];
00394     
00395     CurrentRetreiveAddress = (readPagePtr&lt;&lt;8) + 4;
00396     
00397     <span class="comment">// if the NextPage pointer is invalid, the packet is not ready yet - exit</span>
00398     <span class="keywordflow">if</span>( (NextPage &gt;= RXSTOP_INIT) || (NextPage &lt; RXSTART_INIT) )
00399     {
00400 <span class="comment">//      rprintf("N");</span>
00401 <span class="comment">//      rprintfu08(nextPage);</span>
00402         <span class="keywordflow">return</span> 0;
00403     }
00404 
00405     <span class="keywordflow">return</span> rxlen-4;
00406 }
00407 
00408 
00409 <span class="keywordtype">void</span> ax88796RetreivePacketData(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> * localBuffer, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> length)
00410 {
00411     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;
00412     
00413     <span class="comment">// initiate DMA to transfer the data</span>
00414     ax88796Write(RBCR0, (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)length);
00415     ax88796Write(RBCR1, (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)(length&gt;&gt;8));
00416     ax88796Write(RSAR0, (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)CurrentRetreiveAddress);
00417     ax88796Write(RSAR1, (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)(CurrentRetreiveAddress&gt;&gt;8));
00418     ax88796Write(CR, (RD0|START));
00419     <span class="keywordflow">for</span>(i=0;i&lt;length;i++)
00420         localBuffer[i] = ax88796Read(RDMAPORT);
00421 
00422     <span class="comment">// end the DMA operation</span>
00423     ax88796Write(CR, (RD2|START));
00424     <span class="keywordflow">for</span>(i = 0; i &lt;= 20; i++)
00425         <span class="keywordflow">if</span>(ax88796Read(ISR) &amp; RDC)
00426             <span class="keywordflow">break</span>;
00427     ax88796Write(ISR, RDC);
00428     
00429     CurrentRetreiveAddress += length;
00430     <span class="keywordflow">if</span>( CurrentRetreiveAddress &gt;= 0x6000 )
00431         CurrentRetreiveAddress -= (0x6000-0x4600) ;
00432 }
00433 
00434 
00435 <span class="keywordtype">void</span> ax88796EndPacketRetreive(<span class="keywordtype">void</span>)
00436 {
00437     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> i;
00438     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> bnryPagePtr;
00439 
00440     <span class="comment">// end the DMA operation</span>
00441     ax88796Write(CR, (RD2|START));
00442     <span class="keywordflow">for</span>(i = 0; i &lt;= 20; i++)
00443         <span class="keywordflow">if</span>(ax88796Read(ISR) &amp; RDC)
00444             <span class="keywordflow">break</span>;
00445     ax88796Write(ISR, RDC);
00446 
00447     <span class="comment">// set the boundary register to point</span>
00448     <span class="comment">// to the start of the next packet-1</span>
00449     bnryPagePtr = NextPage-1;
00450     <span class="keywordflow">if</span>(bnryPagePtr &lt; RXSTART_INIT) bnryPagePtr = RXSTOP_INIT-1;
00451 
00452     ax88796Write(BNRY, bnryPagePtr);
00453 }
00454 
00455 
00456 <span class="keywordtype">void</span> ax88796ProcessInterrupt(<span class="keywordtype">void</span>)
00457 {
00458     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> intr = ax88796Read(ISR);
00459     
00460     <span class="comment">// check for receive overflow</span>
00461     <span class="keywordflow">if</span>( intr &amp; OVW )
00462         ax88796ReceiveOverflowRecover();
00463 }
00464 
00465 
00466 <span class="keywordtype">void</span> ax88796ReceiveOverflowRecover(<span class="keywordtype">void</span>)
00467 {
00468     <span class="comment">// receive buffer overflow handling procedure</span>
00469     <span class="comment">// as specified in the AX88796 datasheet</span>
00470 
00471     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> cmdReg;
00472     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> resend=0;
00473 
00474     <span class="comment">// check if we were transmitting something</span>
00475     cmdReg = ax88796Read(CR);
00476     <span class="comment">// stop the interface</span>
00477     ax88796Write(CR, (RD2|STOP));
00478     <span class="comment">// wait for timeout</span>
00479     delay_ms(2);
00480     <span class="comment">// clear remote byte count registers</span>
00481     ax88796Write(RBCR0, 0x00);
00482     ax88796Write(RBCR1, 0x00);
00483     
00484     <span class="comment">// if we were transmitting something</span>
00485     <span class="keywordflow">if</span>(cmdReg &amp; TXP)
00486     {
00487         <span class="comment">// check if the transmit completed</span>
00488         cmdReg = ax88796Read(ISR);
00489         <span class="keywordflow">if</span>((cmdReg &amp; PTX) || (cmdReg &amp; TXE))
00490             resend = 0;     <span class="comment">// transmit completed</span>
00491         <span class="keywordflow">else</span>
00492             resend = 1;     <span class="comment">// transmit was interrupted, must resend</span>
00493     }
00494     <span class="comment">// switch to loopback mode</span>
00495     ax88796Write(TCR, LB0);
00496     <span class="comment">// start the interface</span>
00497     ax88796Write(CR, (RD2|START));
00498     <span class="comment">// set boundary</span>
00499     ax88796Write(BNRY, RXSTART_INIT);
00500     <span class="comment">// go to page 1</span>
00501     ax88796Write(CR, (PS0|RD2|START));
00502     <span class="comment">// set current page register</span>
00503     ax88796Write(CPR, RXSTART_INIT+1);
00504     <span class="comment">// go to page 0</span>
00505     ax88796Write(CR, (RD2|START));
00506     <span class="comment">// clear the overflow int</span>
00507     ax88796Write(ISR, OVW);
00508     <span class="comment">// switch to normal (non-loopback mode)</span>
00509     ax88796Write(TCR, TCR_INIT);
00510 
00511     <span class="comment">// if previous transmit was interrupted, then resend</span>
00512     <span class="keywordflow">if</span>(resend)
00513         ax88796Write(CR, (RD2|TXP|START));
00514 
00515     <span class="comment">// recovery completed</span>
00516 }
00517 
00518 
00519 <span class="preprocessor">#define set_mdc     ax88796Write(MEMR,ax88796Read(MEMR)|0x01);</span>
00520 <span class="preprocessor"></span><span class="preprocessor">#define clr_mdc     ax88796Write(MEMR,ax88796Read(MEMR)&amp;0xFE);</span>
00521 <span class="preprocessor"></span>
00522 <span class="preprocessor">#define mii_clk     set_mdc; clr_mdc;                 </span>
00523 <span class="preprocessor"></span>                    
00524 <span class="preprocessor">#define set_mdir    ax88796Write(MEMR,ax88796Read(MEMR)|0x02);</span>
00525 <span class="preprocessor"></span><span class="preprocessor">#define clr_mdir    ax88796Write(MEMR,ax88796Read(MEMR)&amp;0xFD);</span>
00526 <span class="preprocessor"></span>                    
00527 <span class="preprocessor">#define set_mdo     ax88796Write(MEMR,ax88796Read(MEMR)|0x08)</span>
00528 <span class="preprocessor"></span><span class="preprocessor">#define clr_mdo     ax88796Write(MEMR,ax88796Read(MEMR)&amp;0xF7)</span>
00529 <span class="preprocessor"></span>
00530 <span class="preprocessor">#define mii_write   clr_mdo; mii_clk;   \</span>
00531 <span class="preprocessor">                    set_mdo; mii_clk;   \</span>
00532 <span class="preprocessor">                    clr_mdo; mii_clk;   \</span>
00533 <span class="preprocessor">                    set_mdo; mii_clk;</span>
00534 <span class="preprocessor"></span>
00535 <span class="preprocessor">#define mii_read    clr_mdo; mii_clk;   \</span>
00536 <span class="preprocessor">                    set_mdo; mii_clk;   \</span>
00537 <span class="preprocessor">                    set_mdo; mii_clk;   \</span>
00538 <span class="preprocessor">                    clr_mdo; mii_clk;</span>
00539 <span class="preprocessor"></span>
00540 <span class="preprocessor">#define mii_r_ta    mii_clk;            \</span>
00541 <span class="preprocessor"></span>
00542 <span class="preprocessor"></span><span class="preprocessor">#define mii_w_ta    set_mdo; mii_clk;   \</span>
00543 <span class="preprocessor">                    clr_mdo; mii_clk;</span>
00544 <span class="preprocessor"></span>            
00545 <span class="keywordtype">void</span> ax88796WriteMii(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> phyad,<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> regad,<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> mii_data)
00546 {
00547     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> mask8;
00548     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  i,mask16;
00549 
00550     mii_write;
00551  
00552     mask8 = 0x10;
00553     <span class="keywordflow">for</span>(i=0;i&lt;5;++i)
00554     {
00555         <span class="keywordflow">if</span>(mask8 &amp; phyad)
00556             set_mdo;
00557         <span class="keywordflow">else</span>
00558             clr_mdo;
00559         mii_clk;
00560         mask8 &gt;&gt;= 1;     
00561     }   
00562     mask8 = 0x10;
00563     <span class="keywordflow">for</span>(i=0;i&lt;5;++i)
00564     {
00565         <span class="keywordflow">if</span>(mask8 &amp; regad)
00566             set_mdo;
00567         <span class="keywordflow">else</span>
00568             clr_mdo;
00569         mii_clk;
00570         mask8 &gt;&gt;= 1;     
00571     }                       
00572     mii_w_ta;
00573  
00574     mask16 = 0x8000;
00575     <span class="keywordflow">for</span>(i=0;i&lt;16;++i)
00576     {
00577         <span class="keywordflow">if</span>(mask16 &amp; mii_data)
00578             set_mdo;
00579         <span class="keywordflow">else</span>
00580             clr_mdo;
00581         mii_clk;     
00582         mask16 &gt;&gt;= 1;    
00583     }               
00584 }
00585  
00586 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ax88796ReadMii(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> phyad,<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> regad)
00587 {
00588     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> mask8,i;
00589     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  mask16,result16;
00590  
00591     mii_read;
00592 
00593     mask8 = 0x10;
00594     <span class="keywordflow">for</span>(i=0;i&lt;5;++i)
00595     {
00596         <span class="keywordflow">if</span>(mask8 &amp; phyad)
00597             set_mdo;
00598         <span class="keywordflow">else</span>
00599             clr_mdo;
00600         mii_clk;     
00601         mask8 &gt;&gt;= 1;
00602     }
00603     mask8 = 0x10;
00604     <span class="keywordflow">for</span>(i=0;i&lt;5;++i)
00605     {
00606         <span class="keywordflow">if</span>(mask8 &amp; regad)
00607             set_mdo;
00608         <span class="keywordflow">else</span>
00609             clr_mdo;
00610         mii_clk;
00611         mask8 &gt;&gt;= 1;
00612     }
00613             
00614     mii_r_ta;
00615  
00616     mask16 = 0x8000;
00617     result16 = 0x0000;
00618     <span class="keywordflow">for</span>(i=0;i&lt;16;++i)
00619     {
00620         mii_clk;
00621         <span class="keywordflow">if</span>(ax88796Read(MEMR) &amp; 0x04)
00622         {
00623             result16 |= mask16;
00624         }
00625         <span class="keywordflow">else</span>
00626         {
00627             <span class="keyword">asm</span> <span class="keyword">volatile</span> (<span class="stringliteral">"nop"</span>);
00628             <span class="keywordflow">break</span>;
00629         }
00630         mask16 &gt;&gt;= 1;
00631     }
00632     <span class="keywordflow">return</span> result16;
00633 }
00634 
00635 
00636 <span class="keywordtype">void</span> ax88796RegDump(<span class="keywordtype">void</span>)
00637 {
00638     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> result;
00639     result = ax88796Read(TR);
00640     
00641     rprintf(<span class="stringliteral">"Media State: "</span>);
00642     <span class="keywordflow">if</span>(!(result &amp; AUTOD))
00643         rprintf(<span class="stringliteral">"Autonegotiation\r\n"</span>);
00644     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(result &amp; RST_B)
00645         rprintf(<span class="stringliteral">"PHY in Reset   \r\n"</span>);
00646     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(!(result &amp; RST_10B))
00647         rprintf(<span class="stringliteral">"10BASE-T       \r\n"</span>);
00648     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(!(result &amp; RST_TXB))
00649         rprintf(<span class="stringliteral">"100BASE-T      \r\n"</span>);
00650                 
00651     <span class="comment">//rprintf("TR regsiter      : %x\r\n",result);</span>
00652     <span class="comment">//result = read_mii(0x10,0);</span>
00653     <span class="comment">//rprintf("MII regsiter 0x10: %x\r\n",result);</span>
00654 
00655     <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">"Page0: CR  BNRY PSR PST ISR TSR RSR MMR TR  GPI\r\n"</span>);
00656     <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">"       "</span>);
00657     <a class="code" href="group__rprintf.html#ga7">rprintfu08</a>(ax88796Read(CR));
00658     <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">"  "</span>);
00659     <a class="code" href="group__rprintf.html#ga7">rprintfu08</a>(ax88796Read(BNRY));
00660     <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">"   "</span>);
00661     <a class="code" href="group__rprintf.html#ga7">rprintfu08</a>(ax88796Read(PSTART));
00662     <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">"  "</span>);
00663     <a class="code" href="group__rprintf.html#ga7">rprintfu08</a>(ax88796Read(PSTOP));
00664     <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">"  "</span>);
00665     <a class="code" href="group__rprintf.html#ga7">rprintfu08</a>(ax88796Read(ISR));
00666     <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">"  "</span>);
00667     <a class="code" href="group__rprintf.html#ga7">rprintfu08</a>(ax88796Read(TSR));
00668     <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">"  "</span>);
00669     <a class="code" href="group__rprintf.html#ga7">rprintfu08</a>(ax88796Read(RSR));
00670     <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">"  "</span>);
00671     <a class="code" href="group__rprintf.html#ga7">rprintfu08</a>(ax88796Read(MEMR));
00672     <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">"  "</span>);
00673     <a class="code" href="group__rprintf.html#ga7">rprintfu08</a>(ax88796Read(TR));
00674     <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">"  "</span>);
00675     <a class="code" href="group__rprintf.html#ga7">rprintfu08</a>(ax88796Read(GPI));
00676     <a class="code" href="group__rprintf.html#ga5">rprintfCRLF</a>();
00677 
00678     ax88796Write(CR,ax88796Read(CR)|PS0);
00679 
00680     rprintf(<span class="stringliteral">"Page1: CR  PAR    CPR\r\n"</span>);
00681     <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">"       "</span>);
00682     <a class="code" href="group__rprintf.html#ga7">rprintfu08</a>(ax88796Read(CR));
00683     <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">"  "</span>);
00684     <a class="code" href="group__rprintf.html#ga1">rprintfChar</a>(ax88796Read(PAR0));
00685     <a class="code" href="group__rprintf.html#ga1">rprintfChar</a>(ax88796Read(PAR1));
00686     <a class="code" href="group__rprintf.html#ga1">rprintfChar</a>(ax88796Read(PAR2));
00687     <a class="code" href="group__rprintf.html#ga1">rprintfChar</a>(ax88796Read(PAR3));
00688     <a class="code" href="group__rprintf.html#ga1">rprintfChar</a>(ax88796Read(PAR4));
00689     <a class="code" href="group__rprintf.html#ga1">rprintfChar</a>(ax88796Read(PAR5));
00690     <a class="code" href="group__rprintf.html#ga15">rprintfProgStrM</a>(<span class="stringliteral">" "</span>);
00691     <a class="code" href="group__rprintf.html#ga7">rprintfu08</a>(ax88796Read(CPR));
00692     
00693     ax88796Write(CR,ax88796Read(CR)&amp;~PS0);
00694 
00695     delay_ms(25);
00696 }
00697 
00698 <span class="comment">/*</span>
00699 <span class="comment">unsigned char ax88796ReceiveEmpty(void)</span>
00700 <span class="comment">{</span>
00701 <span class="comment">    unsigned char temp;</span>
00702 <span class="comment"></span>
00703 <span class="comment">    // read CPR from page 1</span>
00704 <span class="comment">    ax88796Write(CR,0x62);</span>
00705 <span class="comment">    temp = ax88796Read(CPR);</span>
00706 <span class="comment">    </span>
00707 <span class="comment">    // return to page 0</span>
00708 <span class="comment">    ax88796Write(CR,0x22);</span>
00709 <span class="comment">    </span>
00710 <span class="comment">    return ( ax88796Read(BNRY) == temp );</span>
00711 <span class="comment">    </span>
00712 <span class="comment">}*/</span>
00713 
00714 
00715 
00716 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Sun Oct 29 03:41:07 2006 for Procyon AVRlib by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.2 </small></address>
</body>
</html>
