<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Procyon AVRlib: ks0108.c Source File</title>
<link href="dox.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.2 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>ks0108.c</h1><a href="ks0108_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*! \file ks0108.c \brief Graphic LCD driver for HD61202/KS0108 displays. */</span>
00002 <span class="comment">//*****************************************************************************</span>
00003 <span class="comment">//</span>
00004 <span class="comment">// File Name    : 'ks0108.c'</span>
00005 <span class="comment">// Title        : Graphic LCD driver for HD61202/KS0108 displays</span>
00006 <span class="comment">// Author       : Pascal Stang - Copyright (C) 2001-2003</span>
00007 <span class="comment">// Date         : 10/19/2002</span>
00008 <span class="comment">// Revised      : 5/5/2003</span>
00009 <span class="comment">// Version      : 0.5</span>
00010 <span class="comment">// Target MCU   : Atmel AVR</span>
00011 <span class="comment">// Editor Tabs  : 4</span>
00012 <span class="comment">//</span>
00013 <span class="comment">// NOTE: This code is currently below version 1.0, and therefore is considered</span>
00014 <span class="comment">// to be lacking in some functionality or documentation, or may not be fully</span>
00015 <span class="comment">// tested.  Nonetheless, you can expect most functions to work.</span>
00016 <span class="comment">//</span>
00017 <span class="comment">// This code is distributed under the GNU Public License</span>
00018 <span class="comment">//      which can be found at http://www.gnu.org/licenses/gpl.txt</span>
00019 <span class="comment">//</span>
00020 <span class="comment">//*****************************************************************************</span>
00021 
00022 <span class="preprocessor">#ifndef WIN32</span>
00023 <span class="preprocessor"></span><span class="comment">// AVR specific includes</span>
00024 <span class="preprocessor">    #include &lt;avr/io.h&gt;</span>
00025 <span class="preprocessor">    #include &lt;avr/interrupt.h&gt;</span>
00026 <span class="preprocessor">#endif</span>
00027 <span class="preprocessor"></span>
00028 <span class="preprocessor">#include "<a class="code" href="global_8h.html">global.h</a>"</span>
00029 <span class="preprocessor">#include "<a class="code" href="ks0108_8h.html">ks0108.h</a>"</span>
00030 
00031 <span class="comment">// global variables</span>
00032 GrLcdStateType GrLcdState;
00033 
00034 <span class="comment">/*************************************************************/</span>
00035 <span class="comment">/********************** LOCAL FUNCTIONS **********************/</span>
00036 <span class="comment">/*************************************************************/</span>
00037 
00038 <span class="keywordtype">void</span> glcdInitHW(<span class="keywordtype">void</span>)
00039 {
00040     <span class="comment">// initialize I/O ports</span>
00041     <span class="comment">// if I/O interface is in use</span>
00042 <span class="preprocessor">#ifdef GLCD_PORT_INTERFACE</span>
00043 <span class="preprocessor"></span>
00044     <span class="comment">//TODO: make setup of chip select lines contingent on how</span>
00045     <span class="comment">// many controllers are actually in the display</span>
00046     
00047     <span class="comment">// initialize LCD control lines levels</span>
00048     cbi(GLCD_CTRL_PORT, GLCD_CTRL_RS);
00049     cbi(GLCD_CTRL_PORT, GLCD_CTRL_RW);
00050     cbi(GLCD_CTRL_PORT, GLCD_CTRL_E);
00051     cbi(GLCD_CTRL_PORT, GLCD_CTRL_CS0);
00052     cbi(GLCD_CTRL_PORT, GLCD_CTRL_CS1);
00053     cbi(GLCD_CTRL_PORT, GLCD_CTRL_CS2);
00054     cbi(GLCD_CTRL_PORT, GLCD_CTRL_CS3);
00055     cbi(GLCD_CTRL_PORT, GLCD_CTRL_RESET);
00056     <span class="comment">// initialize LCD control port to output</span>
00057     sbi(GLCD_CTRL_DDR, GLCD_CTRL_RS);
00058     sbi(GLCD_CTRL_DDR, GLCD_CTRL_RW);
00059     sbi(GLCD_CTRL_DDR, GLCD_CTRL_E);
00060     sbi(GLCD_CTRL_DDR, GLCD_CTRL_CS0);
00061     sbi(GLCD_CTRL_DDR, GLCD_CTRL_CS1);
00062     sbi(GLCD_CTRL_DDR, GLCD_CTRL_CS2);
00063     sbi(GLCD_CTRL_DDR, GLCD_CTRL_CS3);
00064     sbi(GLCD_CTRL_DDR, GLCD_CTRL_RESET);
00065     <span class="comment">// initialize LCD data</span>
00066     outb(GLCD_DATA_PORT, 0x00);
00067     <span class="comment">// initialize LCD data port to output</span>
00068     outb(GLCD_DATA_DDR, 0xFF);
00069 <span class="preprocessor">#endif</span>
00070 <span class="preprocessor"></span>}
00071 
00072 <span class="keywordtype">void</span> glcdControllerSelect(u08 controller)
00073 {
00074 <span class="preprocessor">#ifdef GLCD_PORT_INTERFACE</span>
00075 <span class="preprocessor"></span>    <span class="comment">//TODO: make control of chip select lines contingent on how</span>
00076     <span class="comment">// many controllers are actually in the display</span>
00077 
00078     <span class="comment">// unselect all controllers</span>
00079     cbi(GLCD_CTRL_PORT, GLCD_CTRL_CS0);
00080     cbi(GLCD_CTRL_PORT, GLCD_CTRL_CS1);
00081     cbi(GLCD_CTRL_PORT, GLCD_CTRL_CS2);
00082     cbi(GLCD_CTRL_PORT, GLCD_CTRL_CS3);
00083 
00084     <span class="comment">// select requested controller</span>
00085     <span class="keywordflow">switch</span>(controller)
00086     {
00087     <span class="keywordflow">case</span> 0: sbi(GLCD_CTRL_PORT, GLCD_CTRL_CS0); <span class="keywordflow">break</span>;
00088     <span class="keywordflow">case</span> 1: sbi(GLCD_CTRL_PORT, GLCD_CTRL_CS1); <span class="keywordflow">break</span>;
00089     <span class="keywordflow">case</span> 2: sbi(GLCD_CTRL_PORT, GLCD_CTRL_CS2); <span class="keywordflow">break</span>;
00090     <span class="keywordflow">case</span> 3: sbi(GLCD_CTRL_PORT, GLCD_CTRL_CS3); <span class="keywordflow">break</span>;
00091     <span class="keywordflow">default</span>: <span class="keywordflow">break</span>;
00092     }
00093 <span class="preprocessor">#endif</span>
00094 <span class="preprocessor"></span>}
00095 
00096 <span class="keywordtype">void</span> glcdBusyWait(u08 controller)
00097 {
00098 <span class="preprocessor">#ifdef GLCD_PORT_INTERFACE</span>
00099 <span class="preprocessor"></span>    cli();
00100     <span class="comment">// wait until LCD busy bit goes to zero</span>
00101     <span class="comment">// select the controller chip</span>
00102     glcdControllerSelect(controller);
00103     <span class="comment">// do a read from control register</span>
00104     outb(GLCD_DATA_PORT, 0xFF);
00105     cbi(GLCD_CTRL_PORT, GLCD_CTRL_RS);
00106     outb(GLCD_DATA_DDR, 0x00);
00107     sbi(GLCD_CTRL_PORT, GLCD_CTRL_RW);
00108     sbi(GLCD_CTRL_PORT, GLCD_CTRL_E);
00109     <span class="keyword">asm</span> <span class="keyword">volatile</span> (<span class="stringliteral">"nop"</span>); <span class="keyword">asm</span> <span class="keyword">volatile</span> (<span class="stringliteral">"nop"</span>);
00110     <span class="keywordflow">while</span>(inb(GLCD_DATA_PIN) &amp; GLCD_STATUS_BUSY)
00111     {
00112         cbi(GLCD_CTRL_PORT, GLCD_CTRL_E);
00113         <span class="keyword">asm</span> <span class="keyword">volatile</span> (<span class="stringliteral">"nop"</span>); <span class="keyword">asm</span> <span class="keyword">volatile</span> (<span class="stringliteral">"nop"</span>);
00114         <span class="keyword">asm</span> <span class="keyword">volatile</span> (<span class="stringliteral">"nop"</span>); <span class="keyword">asm</span> <span class="keyword">volatile</span> (<span class="stringliteral">"nop"</span>);
00115         sbi(GLCD_CTRL_PORT, GLCD_CTRL_E);
00116         <span class="keyword">asm</span> <span class="keyword">volatile</span> (<span class="stringliteral">"nop"</span>); <span class="keyword">asm</span> <span class="keyword">volatile</span> (<span class="stringliteral">"nop"</span>);
00117         <span class="keyword">asm</span> <span class="keyword">volatile</span> (<span class="stringliteral">"nop"</span>); <span class="keyword">asm</span> <span class="keyword">volatile</span> (<span class="stringliteral">"nop"</span>);
00118     }
00119     cbi(GLCD_CTRL_PORT, GLCD_CTRL_E);
00120     cbi(GLCD_CTRL_PORT, GLCD_CTRL_RW);
00121     outb(GLCD_DATA_DDR, 0xFF);
00122     sei();
00123 <span class="preprocessor">#else</span>
00124 <span class="preprocessor"></span>    <span class="comment">// sbi(MCUCR, SRW);         // enable RAM waitstate</span>
00125     <span class="comment">// wait until LCD busy bit goes to zero</span>
00126     <span class="keywordflow">while</span>(*(<span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)
00127         (GLCD_CONTROLLER0_CTRL_ADDR + GLCD_CONTROLLER_ADDR_OFFSET*controller) &amp; GLCD_STATUS_BUSY);
00128     <span class="comment">// cbi(MCUCR, SRW);         // disable RAM waitstate</span>
00129 <span class="preprocessor">#endif</span>
00130 <span class="preprocessor"></span>}
00131 
00132 <span class="keywordtype">void</span> glcdControlWrite(u08 controller, u08 data)
00133 {
00134 <span class="preprocessor">#ifdef GLCD_PORT_INTERFACE</span>
00135 <span class="preprocessor"></span>    cli();
00136     glcdBusyWait(controller);   <span class="comment">// wait until LCD not busy</span>
00137     cbi(GLCD_CTRL_PORT, GLCD_CTRL_RS);
00138     cbi(GLCD_CTRL_PORT, GLCD_CTRL_RW);
00139     sbi(GLCD_CTRL_PORT, GLCD_CTRL_E);
00140     outb(GLCD_DATA_DDR, 0xFF);
00141     outb(GLCD_DATA_PORT, data);
00142     <span class="keyword">asm</span> <span class="keyword">volatile</span> (<span class="stringliteral">"nop"</span>); <span class="keyword">asm</span> <span class="keyword">volatile</span> (<span class="stringliteral">"nop"</span>);
00143     <span class="keyword">asm</span> <span class="keyword">volatile</span> (<span class="stringliteral">"nop"</span>); <span class="keyword">asm</span> <span class="keyword">volatile</span> (<span class="stringliteral">"nop"</span>);
00144     <span class="keyword">asm</span> <span class="keyword">volatile</span> (<span class="stringliteral">"nop"</span>); <span class="keyword">asm</span> <span class="keyword">volatile</span> (<span class="stringliteral">"nop"</span>);
00145     <span class="keyword">asm</span> <span class="keyword">volatile</span> (<span class="stringliteral">"nop"</span>); <span class="keyword">asm</span> <span class="keyword">volatile</span> (<span class="stringliteral">"nop"</span>);
00146     cbi(GLCD_CTRL_PORT, GLCD_CTRL_E);
00147     sei();
00148 <span class="preprocessor">#else</span>
00149 <span class="preprocessor"></span>    <span class="comment">//sbi(MCUCR, SRW);              // enable RAM waitstate</span>
00150     glcdBusyWait(controller);       <span class="comment">// wait until LCD not busy</span>
00151     *(<span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) (GLCD_CONTROLLER0_CTRL_ADDR + GLCD_CONTROLLER_ADDR_OFFSET*controller) = data;
00152     <span class="comment">//cbi(MCUCR, SRW);              // disable RAM waitstate</span>
00153 <span class="preprocessor">#endif</span>
00154 <span class="preprocessor"></span>}
00155 
00156 u08 glcdControlRead(u08 controller)
00157 {
00158     <span class="keyword">register</span> u08 data;
00159 <span class="preprocessor">#ifdef GLCD_PORT_INTERFACE</span>
00160 <span class="preprocessor"></span>    cli();
00161     glcdBusyWait(controller);       <span class="comment">// wait until LCD not busy</span>
00162     cbi(GLCD_CTRL_PORT, GLCD_CTRL_RS);
00163     outb(GLCD_DATA_DDR, 0x00);
00164     sbi(GLCD_CTRL_PORT, GLCD_CTRL_RW);
00165     sbi(GLCD_CTRL_PORT, GLCD_CTRL_E);
00166     <span class="keyword">asm</span> <span class="keyword">volatile</span> (<span class="stringliteral">"nop"</span>); <span class="keyword">asm</span> <span class="keyword">volatile</span> (<span class="stringliteral">"nop"</span>);
00167     <span class="keyword">asm</span> <span class="keyword">volatile</span> (<span class="stringliteral">"nop"</span>); <span class="keyword">asm</span> <span class="keyword">volatile</span> (<span class="stringliteral">"nop"</span>);
00168     <span class="keyword">asm</span> <span class="keyword">volatile</span> (<span class="stringliteral">"nop"</span>); <span class="keyword">asm</span> <span class="keyword">volatile</span> (<span class="stringliteral">"nop"</span>);
00169     <span class="keyword">asm</span> <span class="keyword">volatile</span> (<span class="stringliteral">"nop"</span>); <span class="keyword">asm</span> <span class="keyword">volatile</span> (<span class="stringliteral">"nop"</span>);
00170     data = inb(GLCD_DATA_PIN);
00171     cbi(GLCD_CTRL_PORT, GLCD_CTRL_E);
00172     cbi(GLCD_CTRL_PORT, GLCD_CTRL_RW);
00173     outb(GLCD_DATA_DDR, 0xFF);
00174     sei();
00175 <span class="preprocessor">#else</span>
00176 <span class="preprocessor"></span>    <span class="comment">//sbi(MCUCR, SRW);              // enable RAM waitstate</span>
00177     glcdBusyWait(controller);       <span class="comment">// wait until LCD not busy</span>
00178     data = *(<span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) (GLCD_CONTROLLER0_CTRL_ADDR + GLCD_CONTROLLER_ADDR_OFFSET*controller);
00179     <span class="comment">//cbi(MCUCR, SRW);              // disable RAM waitstate</span>
00180 <span class="preprocessor">#endif</span>
00181 <span class="preprocessor"></span>    <span class="keywordflow">return</span> data;
00182 }
00183 
00184 <span class="keywordtype">void</span> glcdDataWrite(u08 data)
00185 {
00186     <span class="keyword">register</span> u08 controller = (GrLcdState.lcdXAddr/GLCD_CONTROLLER_XPIXELS);
00187 <span class="preprocessor">#ifdef GLCD_PORT_INTERFACE</span>
00188 <span class="preprocessor"></span>    cli();
00189     glcdBusyWait(controller);       <span class="comment">// wait until LCD not busy</span>
00190     sbi(GLCD_CTRL_PORT, GLCD_CTRL_RS);
00191     cbi(GLCD_CTRL_PORT, GLCD_CTRL_RW);
00192     sbi(GLCD_CTRL_PORT, GLCD_CTRL_E);
00193     outb(GLCD_DATA_DDR, 0xFF);
00194     outb(GLCD_DATA_PORT, data);
00195     <span class="keyword">asm</span> <span class="keyword">volatile</span> (<span class="stringliteral">"nop"</span>); <span class="keyword">asm</span> <span class="keyword">volatile</span> (<span class="stringliteral">"nop"</span>);
00196     <span class="keyword">asm</span> <span class="keyword">volatile</span> (<span class="stringliteral">"nop"</span>); <span class="keyword">asm</span> <span class="keyword">volatile</span> (<span class="stringliteral">"nop"</span>);
00197     <span class="keyword">asm</span> <span class="keyword">volatile</span> (<span class="stringliteral">"nop"</span>); <span class="keyword">asm</span> <span class="keyword">volatile</span> (<span class="stringliteral">"nop"</span>);
00198     <span class="keyword">asm</span> <span class="keyword">volatile</span> (<span class="stringliteral">"nop"</span>); <span class="keyword">asm</span> <span class="keyword">volatile</span> (<span class="stringliteral">"nop"</span>);
00199     cbi(GLCD_CTRL_PORT, GLCD_CTRL_E);
00200     sei();
00201 <span class="preprocessor">#else</span>
00202 <span class="preprocessor"></span>    <span class="comment">//sbi(MCUCR, SRW);              // enable RAM waitstate</span>
00203     glcdBusyWait(controller);       <span class="comment">// wait until LCD not busy</span>
00204     *(<span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) (GLCD_CONTROLLER0_CTRL_ADDR + GLCD_CONTROLLER_ADDR_OFFSET*controller) = data;
00205     <span class="comment">//cbi(MCUCR, SRW);              // disable RAM waitstate</span>
00206 <span class="preprocessor">#endif</span>
00207 <span class="preprocessor"></span>    <span class="comment">// increment our local address counter</span>
00208     GrLcdState.ctrlr[controller].xAddr++;
00209     GrLcdState.lcdXAddr++;
00210     <span class="keywordflow">if</span>(GrLcdState.lcdXAddr &gt;= GLCD_XPIXELS)
00211     {
00212         GrLcdState.lcdYAddr++;
00213         glcdSetYAddress(GrLcdState.lcdYAddr);
00214         glcdSetXAddress(0);
00215     }
00216 }
00217 
00218 u08 glcdDataRead(<span class="keywordtype">void</span>)
00219 {
00220     <span class="keyword">register</span> u08 data;
00221     <span class="keyword">register</span> u08 controller = (GrLcdState.lcdXAddr/GLCD_CONTROLLER_XPIXELS);
00222 <span class="preprocessor">#ifdef GLCD_PORT_INTERFACE</span>
00223 <span class="preprocessor"></span>    cli();
00224     glcdBusyWait(controller);       <span class="comment">// wait until LCD not busy</span>
00225     sbi(GLCD_CTRL_PORT, GLCD_CTRL_RS);
00226     outb(GLCD_DATA_DDR, 0x00);
00227     sbi(GLCD_CTRL_PORT, GLCD_CTRL_RW);
00228     sbi(GLCD_CTRL_PORT, GLCD_CTRL_E);
00229     <span class="keyword">asm</span> <span class="keyword">volatile</span> (<span class="stringliteral">"nop"</span>); <span class="keyword">asm</span> <span class="keyword">volatile</span> (<span class="stringliteral">"nop"</span>);
00230     <span class="keyword">asm</span> <span class="keyword">volatile</span> (<span class="stringliteral">"nop"</span>); <span class="keyword">asm</span> <span class="keyword">volatile</span> (<span class="stringliteral">"nop"</span>);
00231     <span class="keyword">asm</span> <span class="keyword">volatile</span> (<span class="stringliteral">"nop"</span>); <span class="keyword">asm</span> <span class="keyword">volatile</span> (<span class="stringliteral">"nop"</span>);
00232     <span class="keyword">asm</span> <span class="keyword">volatile</span> (<span class="stringliteral">"nop"</span>); <span class="keyword">asm</span> <span class="keyword">volatile</span> (<span class="stringliteral">"nop"</span>);
00233     data = inb(GLCD_DATA_PIN);
00234     cbi(GLCD_CTRL_PORT, GLCD_CTRL_E);
00235     cbi(GLCD_CTRL_PORT, GLCD_CTRL_RW);
00236     sei();
00237 <span class="preprocessor">#else</span>
00238 <span class="preprocessor"></span>    <span class="comment">//sbi(MCUCR, SRW);              // enable RAM waitstate</span>
00239     glcdBusyWait(controller);       <span class="comment">// wait until LCD not busy</span>
00240     data = *(<span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) (GLCD_CONTROLLER0_CTRL_ADDR + GLCD_CONTROLLER_ADDR_OFFSET*controller);
00241     <span class="comment">//cbi(MCUCR, SRW);              // disable RAM waitstate</span>
00242 <span class="preprocessor">#endif</span>
00243 <span class="preprocessor"></span>    <span class="comment">// increment our local address counter</span>
00244     GrLcdState.ctrlr[controller].xAddr++;
00245     GrLcdState.lcdXAddr++;
00246     <span class="keywordflow">if</span>(GrLcdState.lcdXAddr &gt;= GLCD_XPIXELS)
00247     {
00248         GrLcdState.lcdYAddr++;
00249         glcdSetYAddress(GrLcdState.lcdYAddr);
00250         glcdSetXAddress(0);
00251     }
00252     <span class="keywordflow">return</span> data;
00253 }
00254 
00255 <span class="keywordtype">void</span> glcdReset(u08 resetState)
00256 {
00257     <span class="comment">// reset lcd if argument is true</span>
00258     <span class="comment">// run lcd if argument is false</span>
00259 <span class="preprocessor">#ifdef GLCD_PORT_INTERFACE</span>
00260 <span class="preprocessor"></span>    <span class="keywordflow">if</span>(resetState)
00261         cbi(GLCD_CTRL_PORT, GLCD_CTRL_RESET);
00262     <span class="keywordflow">else</span>
00263         sbi(GLCD_CTRL_PORT, GLCD_CTRL_RESET);
00264 <span class="preprocessor">#endif</span>
00265 <span class="preprocessor"></span>}
00266 
00267 <span class="keywordtype">void</span> glcdSetXAddress(u08 xAddr)
00268 {
00269     u08 i;
00270     <span class="comment">// record address change locally</span>
00271     GrLcdState.lcdXAddr = xAddr;
00272     
00273     <span class="comment">// clear y (col) address on all controllers</span>
00274     <span class="keywordflow">for</span>(i=0; i&lt;GLCD_NUM_CONTROLLERS; i++)
00275     {
00276         glcdControlWrite(i, GLCD_SET_Y_ADDR | 0x00);
00277         GrLcdState.ctrlr[i].xAddr = 0;
00278     }
00279 
00280     <span class="comment">// set y (col) address on destination controller</span>
00281     glcdControlWrite((GrLcdState.lcdXAddr/GLCD_CONTROLLER_XPIXELS),
00282         GLCD_SET_Y_ADDR | (GrLcdState.lcdXAddr &amp; 0x3F));
00283 }
00284 
00285 <span class="keywordtype">void</span> glcdSetYAddress(u08 yAddr)
00286 {
00287     u08 i;
00288     <span class="comment">// record address change locally</span>
00289     GrLcdState.lcdYAddr = yAddr;
00290     <span class="comment">// set page address for all controllers</span>
00291     <span class="keywordflow">for</span>(i=0; i&lt;GLCD_NUM_CONTROLLERS; i++)
00292     {
00293         glcdControlWrite(i, GLCD_SET_PAGE | yAddr);
00294     }
00295 }
00296 
00297 <span class="comment">/*************************************************************/</span>
00298 <span class="comment">/********************* PUBLIC FUNCTIONS **********************/</span>
00299 <span class="comment">/*************************************************************/</span>
00300 
<a name="l00301"></a><a class="code" href="ks0108_8h.html#a19">00301</a> <span class="keywordtype">void</span> <a class="code" href="ks0108_8c.html#a11">glcdInit</a>()
00302 {
00303     u08 i;
00304     <span class="comment">// initialize hardware</span>
00305     glcdInitHW();
00306     <span class="comment">// bring lcd out of reset</span>
00307     glcdReset(FALSE);
00308     <span class="comment">// Turn on LCD</span>
00309     <span class="keywordflow">for</span>(i=0; i&lt;GLCD_NUM_CONTROLLERS; i++)
00310     {
00311         glcdControlWrite(i, GLCD_ON_CTRL | GLCD_ON_DISPLAY);
00312     }
00313     <span class="comment">// clear lcd</span>
00314     <a class="code" href="ks0108_8c.html#a13">glcdClearScreen</a>();
00315     <span class="comment">// initialize positions</span>
00316     <a class="code" href="ks0108_8c.html#a12">glcdHome</a>();
00317 }
00318 
<a name="l00319"></a><a class="code" href="ks0108_8h.html#a21">00319</a> <span class="keywordtype">void</span> <a class="code" href="ks0108_8c.html#a12">glcdHome</a>(<span class="keywordtype">void</span>)
00320 {
00321     u08 i;
00322     <span class="comment">// initialize addresses/positions</span>
00323     <a class="code" href="ks0108_8c.html#a14">glcdStartLine</a>(0);
00324     <a class="code" href="ks0108_8c.html#a15">glcdSetAddress</a>(0,0);
00325     <span class="comment">// initialize local data structures</span>
00326     <span class="keywordflow">for</span>(i=0; i&lt;GLCD_NUM_CONTROLLERS; i++)
00327     {
00328         GrLcdState.ctrlr[i].xAddr = 0;
00329         GrLcdState.ctrlr[i].yAddr = 0;
00330     }
00331 }
00332 
<a name="l00333"></a><a class="code" href="ks0108_8h.html#a20">00333</a> <span class="keywordtype">void</span> <a class="code" href="ks0108_8c.html#a13">glcdClearScreen</a>(<span class="keywordtype">void</span>)
00334 {
00335     u08 pageAddr;
00336     u08 xAddr;
00337 
00338     <span class="comment">// clear LCD</span>
00339     <span class="comment">// loop through all pages</span>
00340     <span class="keywordflow">for</span>(pageAddr=0; pageAddr&lt;(GLCD_YPIXELS&gt;&gt;3); pageAddr++)
00341     {
00342         <span class="comment">// set page address</span>
00343         <a class="code" href="ks0108_8c.html#a15">glcdSetAddress</a>(0, pageAddr);
00344         <span class="comment">// clear all lines of this page of display memory</span>
00345         <span class="keywordflow">for</span>(xAddr=0; xAddr&lt;GLCD_XPIXELS; xAddr++)
00346         {
00347             glcdDataWrite(0x00);
00348         }
00349     }
00350 }
00351 
<a name="l00352"></a><a class="code" href="ks0108_8h.html#a24">00352</a> <span class="keywordtype">void</span> <a class="code" href="ks0108_8c.html#a14">glcdStartLine</a>(u08 start)
00353 {
00354     glcdControlWrite(0, GLCD_START_LINE | start);
00355     glcdControlWrite(1, GLCD_START_LINE | start);
00356 }
00357 
<a name="l00358"></a><a class="code" href="ks0108_8h.html#a23">00358</a> <span class="keywordtype">void</span> <a class="code" href="ks0108_8c.html#a15">glcdSetAddress</a>(u08 x, u08 yLine)
00359 {
00360     <span class="comment">// set addresses</span>
00361     glcdSetYAddress(yLine);
00362     glcdSetXAddress(x);
00363 }
00364 
<a name="l00365"></a><a class="code" href="ks0108_8h.html#a22">00365</a> <span class="keywordtype">void</span> <a class="code" href="ks0108_8c.html#a16">glcdGotoChar</a>(u08 line, u08 col)
00366 {
00367     <a class="code" href="ks0108_8c.html#a15">glcdSetAddress</a>(col*6, line);
00368 }
00369 
<a name="l00370"></a><a class="code" href="ks0108_8h.html#a25">00370</a> <span class="keywordtype">void</span> <a class="code" href="ks0108_8c.html#a17">glcdDelay</a>(u16 p)           <span class="comment">// 1-8us      ...2-13us     ...5-31us</span>
00371 {                               <span class="comment">// 10-60us    ...50-290us</span>
00372     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;             <span class="comment">// 100-580us  ...500-2,9ms</span>
00373     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> j;            <span class="comment">// 1000-5,8ms ...5000-29ms</span>
00374                                 <span class="comment">// 10000-56ms ...30000-170ms</span>
00375                                 <span class="comment">// 50000-295ms...60000-345ms</span>
00376 <span class="comment">//  for (i = 0; i &lt; p; i++) for (j = 0; j &lt; 10; j++) asm volatile ("nop");</span>
00377     <span class="keywordflow">for</span> (i = 0; i &lt; p; i++) <span class="keywordflow">for</span> (j = 0; j &lt; 10; j++);
00378 }
00379 
00380 
00381 <span class="comment">// Higher level functionality has been moved to the API-layer glcd.c/glcd.h</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Sun Oct 29 03:41:07 2006 for Procyon AVRlib by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.2 </small></address>
</body>
</html>
