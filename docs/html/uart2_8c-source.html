<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Procyon AVRlib: uart2.c Source File</title>
<link href="dox.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.2 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>uart2.c</h1><a href="uart2_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*! \file uart2.c \brief Dual UART driver with buffer support. */</span>
00002 <span class="comment">//*****************************************************************************</span>
00003 <span class="comment">//</span>
00004 <span class="comment">// File Name    : 'uart2.c'</span>
00005 <span class="comment">// Title        : Dual UART driver with buffer support</span>
00006 <span class="comment">// Author       : Pascal Stang - Copyright (C) 2000-2004</span>
00007 <span class="comment">// Created      : 11/20/2000</span>
00008 <span class="comment">// Revised      : 07/04/2004</span>
00009 <span class="comment">// Version      : 1.0</span>
00010 <span class="comment">// Target MCU   : ATMEL AVR Series</span>
00011 <span class="comment">// Editor Tabs  : 4</span>
00012 <span class="comment">//</span>
00013 <span class="comment">// Description  : This is a UART driver for AVR-series processors with two</span>
00014 <span class="comment">//      hardware UARTs such as the mega161 and mega128 </span>
00015 <span class="comment">//</span>
00016 <span class="comment">// This code is distributed under the GNU Public License</span>
00017 <span class="comment">//      which can be found at http://www.gnu.org/licenses/gpl.txt</span>
00018 <span class="comment">//</span>
00019 <span class="comment">//*****************************************************************************</span>
00020 
00021 <span class="preprocessor">#include &lt;avr/io.h&gt;</span>
00022 <span class="preprocessor">#include &lt;avr/interrupt.h&gt;</span>
00023 
00024 <span class="preprocessor">#include "<a class="code" href="buffer_8h.html">buffer.h</a>"</span>
00025 <span class="preprocessor">#include "<a class="code" href="uart2_8h.html">uart2.h</a>"</span>
00026 
00027 <span class="comment">// UART global variables</span>
00028 <span class="comment">// flag variables</span>
00029 <span class="keyword">volatile</span> u08   <a class="code" href="uart_8c.html#a0">uartReadyTx</a>[2];
00030 <span class="keyword">volatile</span> u08   <a class="code" href="uart_8c.html#a1">uartBufferedTx</a>[2];
00031 <span class="comment">// receive and transmit buffers</span>
00032 <a class="code" href="structstruct__cBuffer.html">cBuffer</a> <a class="code" href="uart_8c.html#a2">uartRxBuffer</a>[2];
00033 <a class="code" href="structstruct__cBuffer.html">cBuffer</a> <a class="code" href="uart_8c.html#a3">uartTxBuffer</a>[2];
00034 <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> <a class="code" href="uart_8c.html#a4">uartRxOverflow</a>[2];
00035 <span class="preprocessor">#ifndef UART_BUFFER_EXTERNAL_RAM</span>
00036 <span class="preprocessor"></span>    <span class="comment">// using internal ram,</span>
00037     <span class="comment">// automatically allocate space in ram for each buffer</span>
00038     <span class="keyword">static</span> <span class="keywordtype">char</span> uart0RxData[<a class="code" href="group__uart2.html#ga27">UART0_RX_BUFFER_SIZE</a>];
00039     <span class="keyword">static</span> <span class="keywordtype">char</span> uart0TxData[<a class="code" href="group__uart2.html#ga26">UART0_TX_BUFFER_SIZE</a>];
00040     <span class="keyword">static</span> <span class="keywordtype">char</span> uart1RxData[<a class="code" href="group__uart2.html#ga29">UART1_RX_BUFFER_SIZE</a>];
00041     <span class="keyword">static</span> <span class="keywordtype">char</span> uart1TxData[<a class="code" href="group__uart2.html#ga28">UART1_TX_BUFFER_SIZE</a>];
00042 <span class="preprocessor">#endif</span>
00043 <span class="preprocessor"></span>
00044 <span class="keyword">typedef</span> void (*voidFuncPtru08)(<span class="keywordtype">unsigned</span> char);
00045 <span class="keyword">volatile</span> <span class="keyword">static</span> voidFuncPtru08 UartRxFunc[2];
00046 
<a name="l00047"></a><a class="code" href="group__uart.html#ga0">00047</a> <span class="keywordtype">void</span> <a class="code" href="group__uart.html#ga0">uartInit</a>(<span class="keywordtype">void</span>)
00048 {
00049     <span class="comment">// initialize both uarts</span>
00050     <a class="code" href="group__uart2.html#ga1">uart0Init</a>();
00051     <a class="code" href="group__uart2.html#ga2">uart1Init</a>();
00052 }
00053 
<a name="l00054"></a><a class="code" href="group__uart2.html#ga1">00054</a> <span class="keywordtype">void</span> <a class="code" href="group__uart2.html#ga1">uart0Init</a>(<span class="keywordtype">void</span>)
00055 {
00056     <span class="comment">// initialize the buffers</span>
00057     <a class="code" href="group__uart2.html#ga3">uart0InitBuffers</a>();
00058     <span class="comment">// initialize user receive handlers</span>
00059     UartRxFunc[0] = 0;
00060     <span class="comment">// enable RxD/TxD and interrupts</span>
00061     outb(UCSR0B, BV(RXCIE)|BV(TXCIE)|BV(RXEN)|BV(TXEN));
00062     <span class="comment">// set default baud rate</span>
00063     <a class="code" href="group__uart.html#ga3">uartSetBaudRate</a>(0, <a class="code" href="group__uart2.html#ga24">UART0_DEFAULT_BAUD_RATE</a>); 
00064     <span class="comment">// initialize states</span>
00065     <a class="code" href="uart_8c.html#a0">uartReadyTx</a>[0] = TRUE;
00066     <a class="code" href="uart_8c.html#a1">uartBufferedTx</a>[0] = FALSE;
00067     <span class="comment">// clear overflow count</span>
00068     <a class="code" href="uart_8c.html#a4">uartRxOverflow</a>[0] = 0;
00069     <span class="comment">// enable interrupts</span>
00070     sei();
00071 }
00072 
<a name="l00073"></a><a class="code" href="group__uart2.html#ga2">00073</a> <span class="keywordtype">void</span> <a class="code" href="group__uart2.html#ga2">uart1Init</a>(<span class="keywordtype">void</span>)
00074 {
00075     <span class="comment">// initialize the buffers</span>
00076     uart1InitBuffers();
00077     <span class="comment">// initialize user receive handlers</span>
00078     UartRxFunc[1] = 0;
00079     <span class="comment">// enable RxD/TxD and interrupts</span>
00080     outb(UCSR1B, BV(RXCIE)|BV(TXCIE)|BV(RXEN)|BV(TXEN));
00081     <span class="comment">// set default baud rate</span>
00082     <a class="code" href="group__uart.html#ga3">uartSetBaudRate</a>(1, <a class="code" href="group__uart2.html#ga25">UART1_DEFAULT_BAUD_RATE</a>);
00083     <span class="comment">// initialize states</span>
00084     <a class="code" href="uart_8c.html#a0">uartReadyTx</a>[1] = TRUE;
00085     <a class="code" href="uart_8c.html#a1">uartBufferedTx</a>[1] = FALSE;
00086     <span class="comment">// clear overflow count</span>
00087     <a class="code" href="uart_8c.html#a4">uartRxOverflow</a>[1] = 0;
00088     <span class="comment">// enable interrupts</span>
00089     sei();
00090 }
00091 
<a name="l00092"></a><a class="code" href="group__uart2.html#ga3">00092</a> <span class="keywordtype">void</span> <a class="code" href="group__uart2.html#ga3">uart0InitBuffers</a>(<span class="keywordtype">void</span>)
00093 {
00094 <span class="preprocessor">    #ifndef UART_BUFFER_EXTERNAL_RAM</span>
00095 <span class="preprocessor"></span>        <span class="comment">// initialize the UART0 buffers</span>
00096         <a class="code" href="group__buffer.html#ga1">bufferInit</a>(&amp;uartRxBuffer[0], uart0RxData, <a class="code" href="group__uart2.html#ga27">UART0_RX_BUFFER_SIZE</a>);
00097         <a class="code" href="group__buffer.html#ga1">bufferInit</a>(&amp;uartTxBuffer[0], uart0TxData, <a class="code" href="group__uart2.html#ga26">UART0_TX_BUFFER_SIZE</a>);
00098 <span class="preprocessor">    #else</span>
00099 <span class="preprocessor"></span>        <span class="comment">// initialize the UART0 buffers</span>
00100         <a class="code" href="group__buffer.html#ga1">bufferInit</a>(&amp;uartRxBuffer[0], (u08*) UART0_RX_BUFFER_ADDR, <a class="code" href="group__uart2.html#ga27">UART0_RX_BUFFER_SIZE</a>);
00101         <a class="code" href="group__buffer.html#ga1">bufferInit</a>(&amp;uartTxBuffer[0], (u08*) UART0_TX_BUFFER_ADDR, <a class="code" href="group__uart2.html#ga26">UART0_TX_BUFFER_SIZE</a>);
00102 <span class="preprocessor">    #endif</span>
00103 <span class="preprocessor"></span>}
00104 
00105 <span class="keywordtype">void</span> uart1InitBuffers(<span class="keywordtype">void</span>)
00106 {
00107 <span class="preprocessor">    #ifndef UART_BUFFER_EXTERNAL_RAM</span>
00108 <span class="preprocessor"></span>        <span class="comment">// initialize the UART1 buffers</span>
00109         <a class="code" href="group__buffer.html#ga1">bufferInit</a>(&amp;uartRxBuffer[1], uart1RxData, <a class="code" href="group__uart2.html#ga29">UART1_RX_BUFFER_SIZE</a>);
00110         <a class="code" href="group__buffer.html#ga1">bufferInit</a>(&amp;uartTxBuffer[1], uart1TxData, <a class="code" href="group__uart2.html#ga28">UART1_TX_BUFFER_SIZE</a>);
00111 <span class="preprocessor">    #else</span>
00112 <span class="preprocessor"></span>        <span class="comment">// initialize the UART1 buffers</span>
00113         <a class="code" href="group__buffer.html#ga1">bufferInit</a>(&amp;uartRxBuffer[1], (u08*) UART1_RX_BUFFER_ADDR, <a class="code" href="group__uart2.html#ga29">UART1_RX_BUFFER_SIZE</a>);
00114         <a class="code" href="group__buffer.html#ga1">bufferInit</a>(&amp;uartTxBuffer[1], (u08*) UART1_TX_BUFFER_ADDR, <a class="code" href="group__uart2.html#ga28">UART1_TX_BUFFER_SIZE</a>);
00115 <span class="preprocessor">    #endif</span>
00116 <span class="preprocessor"></span>}
00117 
<a name="l00118"></a><a class="code" href="group__uart2.html#ga5">00118</a> <span class="keywordtype">void</span> <a class="code" href="group__uart.html#ga2">uartSetRxHandler</a>(u08 nUart, <span class="keywordtype">void</span> (*rx_func)(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> c))
00119 {
00120     <span class="comment">// make sure the uart number is within bounds</span>
00121     <span class="keywordflow">if</span>(nUart &lt; 2)
00122     {
00123         <span class="comment">// set the receive interrupt to run the supplied user function</span>
00124         UartRxFunc[nUart] = rx_func;
00125     }
00126 }
00127 
<a name="l00128"></a><a class="code" href="group__uart2.html#ga6">00128</a> <span class="keywordtype">void</span> <a class="code" href="group__uart.html#ga3">uartSetBaudRate</a>(u08 nUart, u32 baudrate)
00129 {
00130     <span class="comment">// calculate division factor for requested baud rate, and set it</span>
00131     u16 bauddiv = ((F_CPU+(baudrate*8L))/(baudrate*16L)-1);
00132     <span class="keywordflow">if</span>(nUart)
00133     {
00134         outb(UBRR1L, bauddiv);
00135 <span class="preprocessor">        #ifdef UBRR1H</span>
00136 <span class="preprocessor"></span>        outb(UBRR1H, bauddiv&gt;&gt;8);
00137 <span class="preprocessor">        #endif</span>
00138 <span class="preprocessor"></span>    }
00139     <span class="keywordflow">else</span>
00140     {
00141         outb(UBRR0L, bauddiv);
00142 <span class="preprocessor">        #ifdef UBRR0H</span>
00143 <span class="preprocessor"></span>        outb(UBRR0H, bauddiv&gt;&gt;8);
00144 <span class="preprocessor">        #endif</span>
00145 <span class="preprocessor"></span>    }
00146 }
00147 
<a name="l00148"></a><a class="code" href="group__uart2.html#ga7">00148</a> <a class="code" href="structstruct__cBuffer.html">cBuffer</a>* <a class="code" href="group__uart.html#ga4">uartGetRxBuffer</a>(u08 nUart)
00149 {
00150     <span class="comment">// return rx buffer pointer</span>
00151     <span class="keywordflow">return</span> &amp;uartRxBuffer[nUart];
00152 }
00153 
<a name="l00154"></a><a class="code" href="group__uart2.html#ga8">00154</a> <a class="code" href="structstruct__cBuffer.html">cBuffer</a>* <a class="code" href="group__uart.html#ga5">uartGetTxBuffer</a>(u08 nUart)
00155 {
00156     <span class="comment">// return tx buffer pointer</span>
00157     <span class="keywordflow">return</span> &amp;uartTxBuffer[nUart];
00158 }
00159 
<a name="l00160"></a><a class="code" href="group__uart2.html#ga9">00160</a> <span class="keywordtype">void</span> <a class="code" href="group__uart.html#ga6">uartSendByte</a>(u08 nUart, u08 txData)
00161 {
00162     <span class="comment">// wait for the transmitter to be ready</span>
00163 <span class="comment">//  while(!uartReadyTx[nUart]);</span>
00164     <span class="comment">// send byte</span>
00165     <span class="keywordflow">if</span>(nUart)
00166     {
00167         <span class="keywordflow">while</span>(!(UCSR1A &amp; (1&lt;&lt;UDRE)));
00168         outb(UDR1, txData);
00169     }
00170     <span class="keywordflow">else</span>
00171     {
00172         <span class="keywordflow">while</span>(!(UCSR0A &amp; (1&lt;&lt;UDRE)));
00173         outb(UDR0, txData);
00174     }
00175     <span class="comment">// set ready state to FALSE</span>
00176     <a class="code" href="uart_8c.html#a0">uartReadyTx</a>[nUart] = FALSE;
00177 }
00178 
<a name="l00179"></a><a class="code" href="group__uart2.html#ga10">00179</a> <span class="keywordtype">void</span> <a class="code" href="group__uart2.html#ga10">uart0SendByte</a>(u08 data)
00180 {
00181     <span class="comment">// send byte on UART0</span>
00182     <a class="code" href="group__uart.html#ga6">uartSendByte</a>(0, data);
00183 }
00184 
00185 <span class="keywordtype">void</span> uart1SendByte(u08 data)
00186 {
00187     <span class="comment">// send byte on UART1</span>
00188     <a class="code" href="group__uart.html#ga6">uartSendByte</a>(1, data);
00189 }
00190 
<a name="l00191"></a><a class="code" href="group__uart2.html#ga12">00191</a> <span class="keywordtype">int</span> <a class="code" href="group__uart2.html#ga12">uart0GetByte</a>(<span class="keywordtype">void</span>)
00192 {
00193     <span class="comment">// get single byte from receive buffer (if available)</span>
00194     u08 c;
00195     <span class="keywordflow">if</span>(<a class="code" href="group__uart.html#ga8">uartReceiveByte</a>(0,&amp;c))
00196         <span class="keywordflow">return</span> c;
00197     <span class="keywordflow">else</span>
00198         <span class="keywordflow">return</span> -1;
00199 }
00200 
00201 <span class="keywordtype">int</span> uart1GetByte(<span class="keywordtype">void</span>)
00202 {
00203     <span class="comment">// get single byte from receive buffer (if available)</span>
00204     u08 c;
00205     <span class="keywordflow">if</span>(<a class="code" href="group__uart.html#ga8">uartReceiveByte</a>(1,&amp;c))
00206         <span class="keywordflow">return</span> c;
00207     <span class="keywordflow">else</span>
00208         <span class="keywordflow">return</span> -1;
00209 }
00210 
00211 
<a name="l00212"></a><a class="code" href="group__uart2.html#ga14">00212</a> u08 <a class="code" href="group__uart.html#ga8">uartReceiveByte</a>(u08 nUart, u08* rxData)
00213 {
00214     <span class="comment">// make sure we have a receive buffer</span>
00215     <span class="keywordflow">if</span>(uartRxBuffer[nUart].<a class="code" href="structstruct__cBuffer.html#o1">size</a>)
00216     {
00217         <span class="comment">// make sure we have data</span>
00218         <span class="keywordflow">if</span>(uartRxBuffer[nUart].<a class="code" href="structstruct__cBuffer.html#o2">datalength</a>)
00219         {
00220             <span class="comment">// get byte from beginning of buffer</span>
00221             *rxData = <a class="code" href="group__buffer.html#ga2">bufferGetFromFront</a>(&amp;uartRxBuffer[nUart]);
00222             <span class="keywordflow">return</span> TRUE;
00223         }
00224         <span class="keywordflow">else</span>
00225             <span class="keywordflow">return</span> FALSE;           <span class="comment">// no data</span>
00226     }
00227     <span class="keywordflow">else</span>
00228         <span class="keywordflow">return</span> FALSE;               <span class="comment">// no buffer</span>
00229 }
00230 
<a name="l00231"></a><a class="code" href="group__uart2.html#ga16">00231</a> <span class="keywordtype">void</span> <a class="code" href="group__uart.html#ga10">uartFlushReceiveBuffer</a>(u08 nUart)
00232 {
00233     <span class="comment">// flush all data from receive buffer</span>
00234     <a class="code" href="group__buffer.html#ga7">bufferFlush</a>(&amp;uartRxBuffer[nUart]);
00235 }
00236 
<a name="l00237"></a><a class="code" href="group__uart2.html#ga15">00237</a> u08 <a class="code" href="group__uart.html#ga9">uartReceiveBufferIsEmpty</a>(u08 nUart)
00238 {
00239     <span class="keywordflow">return</span> (uartRxBuffer[nUart].datalength == 0);
00240 }
00241 
<a name="l00242"></a><a class="code" href="group__uart2.html#ga17">00242</a> <span class="keywordtype">void</span> <a class="code" href="group__uart.html#ga11">uartAddToTxBuffer</a>(u08 nUart, u08 data)
00243 {
00244     <span class="comment">// add data byte to the end of the tx buffer</span>
00245     <a class="code" href="group__buffer.html#ga5">bufferAddToEnd</a>(&amp;uartTxBuffer[nUart], data);
00246 }
00247 
<a name="l00248"></a><a class="code" href="group__uart2.html#ga18">00248</a> <span class="keywordtype">void</span> <a class="code" href="group__uart2.html#ga18">uart0AddToTxBuffer</a>(u08 data)
00249 {
00250     <a class="code" href="group__uart.html#ga11">uartAddToTxBuffer</a>(0,data);
00251 }
00252 
00253 <span class="keywordtype">void</span> uart1AddToTxBuffer(u08 data)
00254 {
00255     <a class="code" href="group__uart.html#ga11">uartAddToTxBuffer</a>(1,data);
00256 }
00257 
<a name="l00258"></a><a class="code" href="group__uart2.html#ga20">00258</a> <span class="keywordtype">void</span> <a class="code" href="group__uart.html#ga12">uartSendTxBuffer</a>(u08 nUart)
00259 {
00260     <span class="comment">// turn on buffered transmit</span>
00261     <a class="code" href="uart_8c.html#a1">uartBufferedTx</a>[nUart] = TRUE;
00262     <span class="comment">// send the first byte to get things going by interrupts</span>
00263     <a class="code" href="group__uart.html#ga6">uartSendByte</a>(nUart, <a class="code" href="group__buffer.html#ga2">bufferGetFromFront</a>(&amp;uartTxBuffer[nUart]));
00264 }
00265 
<a name="l00266"></a><a class="code" href="group__uart2.html#ga21">00266</a> u08 <a class="code" href="group__uart.html#ga13">uartSendBuffer</a>(u08 nUart, <span class="keywordtype">char</span> *buffer, u16 nBytes)
00267 {
00268     <span class="keyword">register</span> u08 first;
00269     <span class="keyword">register</span> u16 i;
00270 
00271     <span class="comment">// check if there's space (and that we have any bytes to send at all)</span>
00272     <span class="keywordflow">if</span>((uartTxBuffer[nUart].<a class="code" href="structstruct__cBuffer.html#o2">datalength</a> + nBytes &lt; uartTxBuffer[nUart].<a class="code" href="structstruct__cBuffer.html#o1">size</a>) &amp;&amp; nBytes)
00273     {
00274         <span class="comment">// grab first character</span>
00275         first = *buffer++;
00276         <span class="comment">// copy user buffer to uart transmit buffer</span>
00277         <span class="keywordflow">for</span>(i = 0; i &lt; nBytes-1; i++)
00278         {
00279             <span class="comment">// put data bytes at end of buffer</span>
00280             <a class="code" href="group__buffer.html#ga5">bufferAddToEnd</a>(&amp;uartTxBuffer[nUart], *buffer++);
00281         }
00282 
00283         <span class="comment">// send the first byte to get things going by interrupts</span>
00284         <a class="code" href="uart_8c.html#a1">uartBufferedTx</a>[nUart] = TRUE;
00285         <a class="code" href="group__uart.html#ga6">uartSendByte</a>(nUart, first);
00286         <span class="comment">// return success</span>
00287         <span class="keywordflow">return</span> TRUE;
00288     }
00289     <span class="keywordflow">else</span>
00290     {
00291         <span class="comment">// return failure</span>
00292         <span class="keywordflow">return</span> FALSE;
00293     }
00294 }
00295 
00296 <span class="comment">// UART Transmit Complete Interrupt Function</span>
<a name="l00297"></a><a class="code" href="group__uart2.html#ga22">00297</a> <span class="keywordtype">void</span> <a class="code" href="group__uart2.html#ga22">uartTransmitService</a>(u08 nUart)
00298 {
00299     <span class="comment">// check if buffered tx is enabled</span>
00300     <span class="keywordflow">if</span>(<a class="code" href="uart_8c.html#a1">uartBufferedTx</a>[nUart])
00301     {
00302         <span class="comment">// check if there's data left in the buffer</span>
00303         <span class="keywordflow">if</span>(uartTxBuffer[nUart].<a class="code" href="structstruct__cBuffer.html#o2">datalength</a>)
00304         {
00305             <span class="comment">// send byte from top of buffer</span>
00306             <span class="keywordflow">if</span>(nUart)
00307                 outb(UDR1,  <a class="code" href="group__buffer.html#ga2">bufferGetFromFront</a>(&amp;uartTxBuffer[1]) );
00308             <span class="keywordflow">else</span>
00309                 outb(UDR0,  <a class="code" href="group__buffer.html#ga2">bufferGetFromFront</a>(&amp;uartTxBuffer[0]) );
00310         }
00311         <span class="keywordflow">else</span>
00312         {
00313             <span class="comment">// no data left</span>
00314             <a class="code" href="uart_8c.html#a1">uartBufferedTx</a>[nUart] = FALSE;
00315             <span class="comment">// return to ready state</span>
00316             <a class="code" href="uart_8c.html#a0">uartReadyTx</a>[nUart] = TRUE;
00317         }
00318     }
00319     <span class="keywordflow">else</span>
00320     {
00321         <span class="comment">// we're using single-byte tx mode</span>
00322         <span class="comment">// indicate transmit complete, back to ready</span>
00323         <a class="code" href="uart_8c.html#a0">uartReadyTx</a>[nUart] = TRUE;
00324     }
00325 }
00326 
00327 <span class="comment">// UART Receive Complete Interrupt Function</span>
00328 <span class="keywordtype">void</span> uartReceiveService(u08 nUart)
00329 {
00330     u08 c;
00331     <span class="comment">// get received char</span>
00332     <span class="keywordflow">if</span>(nUart)
00333         c = inb(UDR1);
00334     <span class="keywordflow">else</span>
00335         c = inb(UDR0);
00336 
00337     <span class="comment">// if there's a user function to handle this receive event</span>
00338     <span class="keywordflow">if</span>(UartRxFunc[nUart])
00339     {
00340         <span class="comment">// call it and pass the received data</span>
00341         UartRxFunc[nUart](c);
00342     }
00343     <span class="keywordflow">else</span>
00344     {
00345         <span class="comment">// otherwise do default processing</span>
00346         <span class="comment">// put received char in buffer</span>
00347         <span class="comment">// check if there's space</span>
00348         <span class="keywordflow">if</span>( !<a class="code" href="group__buffer.html#ga5">bufferAddToEnd</a>(&amp;uartRxBuffer[nUart], c) )
00349         {
00350             <span class="comment">// no space in buffer</span>
00351             <span class="comment">// count overflow</span>
00352             <a class="code" href="uart_8c.html#a4">uartRxOverflow</a>[nUart]++;
00353         }
00354     }
00355 }
00356 
00357 <a class="code" href="group__uart.html#ga17">UART_INTERRUPT_HANDLER</a>(SIG_UART0_TRANS)      
00358 {
00359     <span class="comment">// service UART0 transmit interrupt</span>
00360     <a class="code" href="group__uart2.html#ga22">uartTransmitService</a>(0);
00361 }
00362 
00363 <a class="code" href="group__uart.html#ga17">UART_INTERRUPT_HANDLER</a>(SIG_UART1_TRANS)      
00364 {
00365     <span class="comment">// service UART1 transmit interrupt</span>
00366     <a class="code" href="group__uart2.html#ga22">uartTransmitService</a>(1);
00367 }
00368 
00369 <a class="code" href="group__uart.html#ga17">UART_INTERRUPT_HANDLER</a>(SIG_UART0_RECV)      
00370 {
00371     <span class="comment">// service UART0 receive interrupt</span>
00372     uartReceiveService(0);
00373 }
00374 
00375 <a class="code" href="group__uart.html#ga17">UART_INTERRUPT_HANDLER</a>(SIG_UART1_RECV)      
00376 {
00377     <span class="comment">// service UART1 receive interrupt</span>
00378     uartReceiveService(1);
00379 }
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Sun Oct 29 03:41:08 2006 for Procyon AVRlib by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.2 </small></address>
</body>
</html>
