<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Procyon AVRlib: a2d.c Source File</title>
<link href="dox.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.2 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>a2d.c</h1><a href="a2d_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*! \file a2d.c \brief Analog-to-Digital converter function library. */</span>
00002 <span class="comment">//*****************************************************************************</span>
00003 <span class="comment">//</span>
00004 <span class="comment">// File Name    : 'a2d.c'</span>
00005 <span class="comment">// Title        : Analog-to-digital converter functions</span>
00006 <span class="comment">// Author       : Pascal Stang - Copyright (C) 2002</span>
00007 <span class="comment">// Created      : 2002-04-08</span>
00008 <span class="comment">// Revised      : 2002-09-30</span>
00009 <span class="comment">// Version      : 1.1</span>
00010 <span class="comment">// Target MCU   : Atmel AVR series</span>
00011 <span class="comment">// Editor Tabs  : 4</span>
00012 <span class="comment">//</span>
00013 <span class="comment">// This code is distributed under the GNU Public License</span>
00014 <span class="comment">//      which can be found at http://www.gnu.org/licenses/gpl.txt</span>
00015 <span class="comment">//</span>
00016 <span class="comment">//*****************************************************************************</span>
00017 
00018 <span class="preprocessor">#include &lt;avr/io.h&gt;</span>
00019 <span class="preprocessor">#include &lt;avr/interrupt.h&gt;</span>
00020 
00021 <span class="preprocessor">#include "<a class="code" href="global_8h.html">global.h</a>"</span>
00022 <span class="preprocessor">#include "<a class="code" href="a2d_8h.html">a2d.h</a>"</span>
00023 
00024 <span class="comment">// global variables</span>
00025 <span class="comment"></span>
00026 <span class="comment">//! Software flag used to indicate when</span>
00027 <span class="comment">/// the a2d conversion is complete.</span>
<a name="l00028"></a><a class="code" href="a2d_8c.html#a0">00028</a> <span class="comment"></span><span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> <a class="code" href="a2d_8c.html#a0">a2dCompleteFlag</a>;
00029 
00030 <span class="comment">// functions</span>
00031 
00032 <span class="comment">// initialize a2d converter</span>
<a name="l00033"></a><a class="code" href="group__a2d.html#ga0">00033</a> <span class="keywordtype">void</span> <a class="code" href="group__a2d.html#ga0">a2dInit</a>(<span class="keywordtype">void</span>)
00034 {
00035     sbi(ADCSR, ADEN);               <span class="comment">// enable ADC (turn on ADC power)</span>
00036     cbi(ADCSR, ADFR);               <span class="comment">// default to single sample convert mode</span>
00037     <a class="code" href="group__a2d.html#ga2">a2dSetPrescaler</a>(ADC_PRESCALE);  <span class="comment">// set default prescaler</span>
00038     <a class="code" href="group__a2d.html#ga3">a2dSetReference</a>(ADC_REFERENCE); <span class="comment">// set default reference</span>
00039     cbi(ADMUX, ADLAR);              <span class="comment">// set to right-adjusted result</span>
00040 
00041     sbi(ADCSR, ADIE);               <span class="comment">// enable ADC interrupts</span>
00042 
00043     <a class="code" href="a2d_8c.html#a0">a2dCompleteFlag</a> = FALSE;        <span class="comment">// clear conversion complete flag</span>
00044     sei();                          <span class="comment">// turn on interrupts (if not already on)</span>
00045 }
00046 
00047 <span class="comment">// turn off a2d converter</span>
<a name="l00048"></a><a class="code" href="group__a2d.html#ga1">00048</a> <span class="keywordtype">void</span> <a class="code" href="group__a2d.html#ga1">a2dOff</a>(<span class="keywordtype">void</span>)
00049 {
00050     cbi(ADCSR, ADIE);               <span class="comment">// disable ADC interrupts</span>
00051     cbi(ADCSR, ADEN);               <span class="comment">// disable ADC (turn off ADC power)</span>
00052 }
00053 
00054 <span class="comment">// configure A2D converter clock division (prescaling)</span>
<a name="l00055"></a><a class="code" href="group__a2d.html#ga2">00055</a> <span class="keywordtype">void</span> <a class="code" href="group__a2d.html#ga2">a2dSetPrescaler</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> prescale)
00056 {
00057     outb(ADCSR, ((inb(ADCSR) &amp; ~ADC_PRESCALE_MASK) | prescale));
00058 }
00059 
00060 <span class="comment">// configure A2D converter voltage reference</span>
<a name="l00061"></a><a class="code" href="group__a2d.html#ga3">00061</a> <span class="keywordtype">void</span> <a class="code" href="group__a2d.html#ga3">a2dSetReference</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> ref)
00062 {
00063     outb(ADMUX, ((inb(ADMUX) &amp; ~ADC_REFERENCE_MASK) | (ref&lt;&lt;6)));
00064 }
00065 
00066 <span class="comment">// sets the a2d input channel</span>
<a name="l00067"></a><a class="code" href="group__a2d.html#ga4">00067</a> <span class="keywordtype">void</span> <a class="code" href="group__a2d.html#ga4">a2dSetChannel</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> ch)
00068 {
00069     outb(ADMUX, (inb(ADMUX) &amp; ~ADC_MUX_MASK) | (ch &amp; ADC_MUX_MASK));    <span class="comment">// set channel</span>
00070 }
00071 
00072 <span class="comment">// start a conversion on the current a2d input channel</span>
<a name="l00073"></a><a class="code" href="group__a2d.html#ga5">00073</a> <span class="keywordtype">void</span> <a class="code" href="group__a2d.html#ga5">a2dStartConvert</a>(<span class="keywordtype">void</span>)
00074 {
00075     sbi(ADCSR, ADIF);   <span class="comment">// clear hardware "conversion complete" flag </span>
00076     sbi(ADCSR, ADSC);   <span class="comment">// start conversion</span>
00077 }
00078 
00079 <span class="comment">// return TRUE if conversion is complete</span>
<a name="l00080"></a><a class="code" href="group__a2d.html#ga6">00080</a> u08 <a class="code" href="group__a2d.html#ga6">a2dIsComplete</a>(<span class="keywordtype">void</span>)
00081 {
00082     <span class="keywordflow">return</span> bit_is_set(ADCSR, ADSC);
00083 }
00084 
00085 <span class="comment">// Perform a 10-bit conversion</span>
00086 <span class="comment">// starts conversion, waits until conversion is done, and returns result</span>
<a name="l00087"></a><a class="code" href="group__a2d.html#ga7">00087</a> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> <a class="code" href="group__a2d.html#ga7">a2dConvert10bit</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> ch)
00088 {
00089     <a class="code" href="a2d_8c.html#a0">a2dCompleteFlag</a> = FALSE;                <span class="comment">// clear conversion complete flag</span>
00090     outb(ADMUX, (inb(ADMUX) &amp; ~ADC_MUX_MASK) | (ch &amp; ADC_MUX_MASK));    <span class="comment">// set channel</span>
00091     sbi(ADCSR, ADIF);                       <span class="comment">// clear hardware "conversion complete" flag </span>
00092     sbi(ADCSR, ADSC);                       <span class="comment">// start conversion</span>
00093     <span class="comment">//while(!a2dCompleteFlag);              // wait until conversion complete</span>
00094     <span class="comment">//while( bit_is_clear(ADCSR, ADIF) );       // wait until conversion complete</span>
00095     <span class="keywordflow">while</span>( bit_is_set(ADCSR, ADSC) );       <span class="comment">// wait until conversion complete</span>
00096 
00097     <span class="comment">// CAUTION: MUST READ ADCL BEFORE ADCH!!!</span>
00098     <span class="keywordflow">return</span> (inb(ADCL) | (inb(ADCH)&lt;&lt;8));    <span class="comment">// read ADC (full 10 bits);</span>
00099 }
00100 
00101 <span class="comment">// Perform a 8-bit conversion.</span>
00102 <span class="comment">// starts conversion, waits until conversion is done, and returns result</span>
<a name="l00103"></a><a class="code" href="group__a2d.html#ga8">00103</a> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> <a class="code" href="group__a2d.html#ga8">a2dConvert8bit</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> ch)
00104 {
00105     <span class="comment">// do 10-bit conversion and return highest 8 bits</span>
00106     <span class="keywordflow">return</span> <a class="code" href="group__a2d.html#ga7">a2dConvert10bit</a>(ch)&gt;&gt;2;          <span class="comment">// return ADC MSB byte</span>
00107 }
00108 <span class="comment"></span>
00109 <span class="comment">//! Interrupt handler for ADC complete interrupt.</span>
<a name="l00110"></a><a class="code" href="a2d_8c.html#a10">00110</a> <span class="comment"></span><a class="code" href="a2d_8c.html#a10">SIGNAL</a>(SIG_ADC)
00111 {
00112     <span class="comment">// set the a2d conversion flag to indicate "complete"</span>
00113     <a class="code" href="a2d_8c.html#a0">a2dCompleteFlag</a> = TRUE;
00114 }
00115 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Sun Oct 29 03:41:06 2006 for Procyon AVRlib by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.2 </small></address>
</body>
</html>
