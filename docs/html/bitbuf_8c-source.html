<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Procyon AVRlib: bitbuf.c Source File</title>
<link href="dox.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.2 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>bitbuf.c</h1><a href="bitbuf_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*! \file bitbuf.c \brief Multipurpose bit buffer structure and methods. */</span>
00002 <span class="comment">//*****************************************************************************</span>
00003 <span class="comment">//</span>
00004 <span class="comment">// File Name    : 'bitbuf.c'</span>
00005 <span class="comment">// Title        : Multipurpose bit buffer structure and methods</span>
00006 <span class="comment">// Author       : Pascal Stang - Copyright (C) 2001-2002</span>
00007 <span class="comment">// Created      : 7/10/2002</span>
00008 <span class="comment">// Revised      : 7/10/2002</span>
00009 <span class="comment">// Version      : 0.5</span>
00010 <span class="comment">// Target MCU   : any</span>
00011 <span class="comment">// Editor Tabs  : 4</span>
00012 <span class="comment">//</span>
00013 <span class="comment">// This code is distributed under the GNU Public License</span>
00014 <span class="comment">//      which can be found at http://www.gnu.org/licenses/gpl.txt</span>
00015 <span class="comment">//</span>
00016 <span class="comment">//*****************************************************************************</span>
00017 
00018 <span class="preprocessor">#include "<a class="code" href="bitbuf_8h.html">bitbuf.h</a>"</span>
00019 
00020 <span class="comment">// global variables</span>
00021 <span class="comment"></span>
00022 <span class="comment">//! Initialize the bit buffer</span>
00023 <span class="comment"></span><span class="comment">//  sets the start location and size of the buffer in memory</span>
<a name="l00024"></a><a class="code" href="group__bitbuf.html#ga1">00024</a> <span class="keywordtype">void</span> <a class="code" href="group__bitbuf.html#ga1">bitbufInit</a>(BitBuf* bitBuffer, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *start, <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> bytesize)
00025 {
00026     <span class="comment">// set start pointer of the buffer</span>
00027     bitBuffer-&gt;dataptr = start;
00028     bitBuffer-&gt;size = bytesize;
00029     <span class="comment">// initialize indexing and length</span>
00030     bitBuffer-&gt;dataindex = 0;
00031     <a class="code" href="group__bitbuf.html#ga7">bitbufFlush</a>(bitBuffer);
00032 }
00033 
00034 <span class="comment">// access routines</span>
00035 <span class="comment"></span>
00036 <span class="comment">//! Get a bit from the current position in the buffer</span>
00037 <span class="comment"></span><span class="comment">//  returns the bit at the current position in the buffer</span>
00038 <span class="comment">//  and increments the bit position</span>
<a name="l00039"></a><a class="code" href="group__bitbuf.html#ga2">00039</a> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> <a class="code" href="group__bitbuf.html#ga2">bitbufGet</a>(BitBuf* bitBuffer)
00040 {
00041     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> byte;
00042     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> bit;
00043     
00044     <span class="comment">// get current working byte</span>
00045     byte = bitBuffer-&gt;dataptr[bitBuffer-&gt;bytePos];
00046     <span class="comment">// read data bit</span>
00047     bit = (byte &amp; (1&lt;&lt;bitBuffer-&gt;bitPos))?(1):(0);
00048 
00049     <span class="comment">// increment bit counter</span>
00050     <span class="keywordflow">if</span>(bitBuffer-&gt;bitPos &lt; 7)
00051     {
00052         bitBuffer-&gt;bitPos++;
00053     }
00054     <span class="keywordflow">else</span>
00055     {
00056         <span class="comment">// increment byte counter</span>
00057         bitBuffer-&gt;bitPos = 0;
00058         bitBuffer-&gt;bytePos++;
00059     }
00060 
00061     <span class="comment">// return bit value</span>
00062     <span class="keywordflow">return</span> bit;
00063 }
00064 <span class="comment"></span>
00065 <span class="comment">//! Get a bit from a given index into the buffer</span>
00066 <span class="comment"></span><span class="comment">//  returns the bit at position [bitIndex] in the buffer</span>
<a name="l00067"></a><a class="code" href="group__bitbuf.html#ga3">00067</a> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> <a class="code" href="group__bitbuf.html#ga3">bitbufGetAtIndex</a>(BitBuf* bitBuffer, <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> bitIndex)
00068 {
00069     <span class="comment">// return bit at index in buffer</span>
00070     <span class="keywordflow">return</span> (bitBuffer-&gt;dataptr[bitIndex&gt;&gt;3] &amp; (1&lt;&lt;(bitIndex &amp; 0x07)))?(1):(0);
00071 }
00072 <span class="comment"></span>
00073 <span class="comment">//! Store a bit at the current position in the buffer</span>
00074 <span class="comment"></span><span class="comment">//  stores the bit at the current position in the buffer</span>
00075 <span class="comment">//  and increments the bit position</span>
<a name="l00076"></a><a class="code" href="group__bitbuf.html#ga4">00076</a> <span class="keywordtype">void</span> <a class="code" href="group__bitbuf.html#ga4">bitbufStore</a>(BitBuf* bitBuffer, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> bit)
00077 {
00078     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> byte;
00079     <span class="comment">// get current working byte</span>
00080     byte = bitBuffer-&gt;dataptr[bitBuffer-&gt;bytePos];
00081     <span class="comment">// apply data bit</span>
00082     <span class="keywordflow">if</span>(bit)
00083         byte |=  (1&lt;&lt;bitBuffer-&gt;bitPos);
00084     <span class="keywordflow">else</span>
00085         byte &amp;= ~(1&lt;&lt;bitBuffer-&gt;bitPos);
00086     <span class="comment">// store data</span>
00087     bitBuffer-&gt;dataptr[bitBuffer-&gt;bytePos] = byte;
00088     bitBuffer-&gt;datalength++;
00089 
00090     <span class="comment">// increment bit counter</span>
00091     <span class="keywordflow">if</span>(bitBuffer-&gt;bitPos &lt; 7)
00092     {
00093         bitBuffer-&gt;bitPos++;
00094     }
00095     <span class="keywordflow">else</span>
00096     {
00097         <span class="comment">// increment byte counter</span>
00098         bitBuffer-&gt;bitPos = 0;
00099         bitBuffer-&gt;bytePos++;
00100     }
00101 }
00102 
<a name="l00103"></a><a class="code" href="group__bitbuf.html#ga6">00103</a> <span class="keywordtype">void</span> <a class="code" href="group__bitbuf.html#ga6">bitbufReset</a>(BitBuf* bitBuffer)
00104 {
00105     <span class="comment">// reset counters</span>
00106     bitBuffer-&gt;bytePos = 0;
00107     bitBuffer-&gt;bitPos = 0;
00108 }
00109 
<a name="l00110"></a><a class="code" href="group__bitbuf.html#ga7">00110</a> <span class="keywordtype">void</span> <a class="code" href="group__bitbuf.html#ga7">bitbufFlush</a>(BitBuf* bitBuffer)
00111 {
00112     <span class="comment">// flush contents of the buffer</span>
00113     bitBuffer-&gt;datalength = 0;
00114     <span class="comment">// reset indexing</span>
00115     <a class="code" href="group__bitbuf.html#ga6">bitbufReset</a>(bitBuffer);
00116 }
00117 
<a name="l00118"></a><a class="code" href="group__bitbuf.html#ga5">00118</a> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> <a class="code" href="group__bitbuf.html#ga5">bitbufGetDataLength</a>(BitBuf* bitBuffer)
00119 {
00120     <span class="keywordflow">return</span> bitBuffer-&gt;datalength;
00121 }
00122 
00123 <span class="comment">/*</span>
00124 <span class="comment">unsigned char bitbufIsNotFull(cBuffer* buffer)</span>
00125 <span class="comment">{</span>
00126 <span class="comment">    // check to see if the buffer has room</span>
00127 <span class="comment">    // return true if there is room</span>
00128 <span class="comment">    return (buffer-&gt;datalength &lt; buffer-&gt;size);</span>
00129 <span class="comment">}</span>
00130 <span class="comment">*/</span>
00131 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Sun Oct 29 03:41:06 2006 for Procyon AVRlib by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.2 </small></address>
</body>
</html>
