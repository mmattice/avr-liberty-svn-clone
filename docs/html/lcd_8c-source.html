<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Procyon AVRlib: lcd.c Source File</title>
<link href="dox.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.2 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>lcd.c</h1><a href="lcd_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*! \file lcd.c \brief Character LCD driver for HD44780/SED1278 displays. */</span>
00002 <span class="comment">//*****************************************************************************</span>
00003 <span class="comment">//</span>
00004 <span class="comment">// File Name    : 'lcd.c'</span>
00005 <span class="comment">// Title        : Character LCD driver for HD44780/SED1278 displays</span>
00006 <span class="comment">//                  (usable in mem-mapped, or I/O mode)</span>
00007 <span class="comment">// Author       : Pascal Stang</span>
00008 <span class="comment">// Created      : 11/22/2000</span>
00009 <span class="comment">// Revised      : 4/30/2002</span>
00010 <span class="comment">// Version      : 1.1</span>
00011 <span class="comment">// Target MCU   : Atmel AVR series</span>
00012 <span class="comment">// Editor Tabs  : 4</span>
00013 <span class="comment">//</span>
00014 <span class="comment">// This code is distributed under the GNU Public License</span>
00015 <span class="comment">//      which can be found at http://www.gnu.org/licenses/gpl.txt</span>
00016 <span class="comment">//</span>
00017 <span class="comment">//*****************************************************************************</span>
00018 
00019 <span class="preprocessor">#include &lt;avr/io.h&gt;</span>
00020 <span class="preprocessor">#include &lt;avr/pgmspace.h&gt;</span>
00021 
00022 <span class="preprocessor">#include "<a class="code" href="global_8h.html">global.h</a>"</span>
00023 <span class="preprocessor">#include "<a class="code" href="timer_8h.html">timer.h</a>"</span>
00024 
00025 <span class="preprocessor">#include "<a class="code" href="lcd_8h.html">lcd.h</a>"</span>
00026 
00027 <span class="comment">// custom LCD characters</span>
00028 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> __attribute__ ((progmem)) LcdCustomChar[] =
00029 {
00030     0x00, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x00, <span class="comment">// 0. 0/5 full progress block</span>
00031     0x00, 0x1F, 0x10, 0x10, 0x10, 0x10, 0x1F, 0x00, <span class="comment">// 1. 1/5 full progress block</span>
00032     0x00, 0x1F, 0x18, 0x18, 0x18, 0x18, 0x1F, 0x00, <span class="comment">// 2. 2/5 full progress block</span>
00033     0x00, 0x1F, 0x1C, 0x1C, 0x1C, 0x1C, 0x1F, 0x00, <span class="comment">// 3. 3/5 full progress block</span>
00034     0x00, 0x1F, 0x1E, 0x1E, 0x1E, 0x1E, 0x1F, 0x00, <span class="comment">// 4. 4/5 full progress block</span>
00035     0x00, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x00, <span class="comment">// 5. 5/5 full progress block</span>
00036     0x03, 0x07, 0x0F, 0x1F, 0x0F, 0x07, 0x03, 0x00, <span class="comment">// 6. rewind arrow</span>
00037     0x00, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x00, <span class="comment">// 7. stop block</span>
00038     0x1B, 0x1B, 0x1B, 0x1B, 0x1B, 0x1B, 0x1B, 0x00, <span class="comment">// 8. pause bars</span>
00039     0x18, 0x1C, 0x1E, 0x1F, 0x1E, 0x1C, 0x18, 0x00, <span class="comment">// 9. fast-forward arrow</span>
00040     0x00, 0x04, 0x04, 0x0E, 0x0E, 0x1F, 0x1F, 0x00, <span class="comment">// 10. scroll up arrow</span>
00041     0x00, 0x1F, 0x1F, 0x0E, 0x0E, 0x04, 0x04, 0x00, <span class="comment">// 11. scroll down arrow</span>
00042     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, <span class="comment">// 12. blank character</span>
00043     0x00, 0x0E, 0x19, 0x15, 0x13, 0x0E, 0x00, 0x00, <span class="comment">// 13. animated play icon frame 0</span>
00044     0x00, 0x0E, 0x15, 0x15, 0x15, 0x0E, 0x00, 0x00, <span class="comment">// 14. animated play icon frame 1</span>
00045     0x00, 0x0E, 0x13, 0x15, 0x19, 0x0E, 0x00, 0x00, <span class="comment">// 15. animated play icon frame 2</span>
00046     0x00, 0x0E, 0x11, 0x1F, 0x11, 0x0E, 0x00, 0x00, <span class="comment">// 16. animated play icon frame 3</span>
00047 };
00048 
00049 <span class="comment">/*************************************************************/</span>
00050 <span class="comment">/********************** LOCAL FUNCTIONS **********************/</span>
00051 <span class="comment">/*************************************************************/</span>
00052 
00053 <span class="keywordtype">void</span> lcdInitHW(<span class="keywordtype">void</span>)
00054 {
00055     <span class="comment">// initialize I/O ports</span>
00056     <span class="comment">// if I/O interface is in use</span>
00057 <span class="preprocessor">#ifdef LCD_PORT_INTERFACE</span>
00058 <span class="preprocessor"></span>    <span class="comment">// initialize LCD control lines</span>
00059     cbi(LCD_CTRL_PORT, LCD_CTRL_RS);
00060     cbi(LCD_CTRL_PORT, LCD_CTRL_RW);
00061     cbi(LCD_CTRL_PORT, LCD_CTRL_E);
00062     <span class="comment">// initialize LCD control lines to output</span>
00063     sbi(LCD_CTRL_DDR, LCD_CTRL_RS);
00064     sbi(LCD_CTRL_DDR, LCD_CTRL_RW);
00065     sbi(LCD_CTRL_DDR, LCD_CTRL_E);
00066     <span class="comment">// initialize LCD data port to input</span>
00067     <span class="comment">// initialize LCD data lines to pull-up</span>
00068 <span class="preprocessor">    #ifdef LCD_DATA_4BIT</span>
00069 <span class="preprocessor"></span>        outb(LCD_DATA_DDR, inb(LCD_DATA_DDR)&amp;0x0F);     <span class="comment">// set data I/O lines to input (4bit)</span>
00070         outb(LCD_DATA_POUT, inb(LCD_DATA_POUT)|0xF0);   <span class="comment">// set pull-ups to on (4bit)</span>
00071 <span class="preprocessor">    #else</span>
00072 <span class="preprocessor"></span>        outb(LCD_DATA_DDR, 0x00);                       <span class="comment">// set data I/O lines to input (8bit)</span>
00073         outb(LCD_DATA_POUT, 0xFF);                      <span class="comment">// set pull-ups to on (8bit)</span>
00074 <span class="preprocessor">    #endif</span>
00075 <span class="preprocessor"></span><span class="preprocessor">#else</span>
00076 <span class="preprocessor"></span>    <span class="comment">// enable external memory bus if not already enabled</span>
00077     sbi(MCUCR, SRE);            <span class="comment">// enable bus interface</span>
00078 <span class="preprocessor">#endif</span>
00079 <span class="preprocessor"></span>}
00080 
00081 <span class="keywordtype">void</span> lcdBusyWait(<span class="keywordtype">void</span>)
00082 {
00083     <span class="comment">// wait until LCD busy bit goes to zero</span>
00084     <span class="comment">// do a read from control register</span>
00085 <span class="preprocessor">#ifdef LCD_PORT_INTERFACE</span>
00086 <span class="preprocessor"></span>    cbi(LCD_CTRL_PORT, LCD_CTRL_RS);                <span class="comment">// set RS to "control"</span>
00087 <span class="preprocessor">    #ifdef LCD_DATA_4BIT</span>
00088 <span class="preprocessor"></span>        outb(LCD_DATA_DDR, inb(LCD_DATA_DDR)&amp;0x0F); <span class="comment">// set data I/O lines to input (4bit)</span>
00089         outb(LCD_DATA_POUT, inb(LCD_DATA_POUT)|0xF0);   <span class="comment">// set pull-ups to on (4bit)</span>
00090 <span class="preprocessor">    #else</span>
00091 <span class="preprocessor"></span>        outb(LCD_DATA_DDR, 0x00);                   <span class="comment">// set data I/O lines to input (8bit)</span>
00092         outb(LCD_DATA_POUT, 0xFF);                  <span class="comment">// set pull-ups to on (8bit)</span>
00093 <span class="preprocessor">    #endif</span>
00094 <span class="preprocessor"></span>    sbi(LCD_CTRL_PORT, LCD_CTRL_RW);                <span class="comment">// set R/W to "read"</span>
00095     sbi(LCD_CTRL_PORT, LCD_CTRL_E);                 <span class="comment">// set "E" line</span>
00096     LCD_DELAY;                              <span class="comment">// wait</span>
00097     <span class="keywordflow">while</span>(inb(LCD_DATA_PIN) &amp; 1&lt;&lt;LCD_BUSY)
00098     {
00099         cbi(LCD_CTRL_PORT, LCD_CTRL_E);     <span class="comment">// clear "E" line</span>
00100         LCD_DELAY;                                  <span class="comment">// wait</span>
00101         LCD_DELAY;                                  <span class="comment">// wait</span>
00102         sbi(LCD_CTRL_PORT, LCD_CTRL_E);     <span class="comment">// set "E" line</span>
00103         LCD_DELAY;                                  <span class="comment">// wait</span>
00104         LCD_DELAY;                                  <span class="comment">// wait</span>
00105 <span class="preprocessor">        #ifdef LCD_DATA_4BIT                        // do an extra clock for 4 bit reads</span>
00106 <span class="preprocessor"></span>            cbi(LCD_CTRL_PORT, LCD_CTRL_E); <span class="comment">// clear "E" line</span>
00107             LCD_DELAY;                              <span class="comment">// wait</span>
00108             LCD_DELAY;                              <span class="comment">// wait</span>
00109             sbi(LCD_CTRL_PORT, LCD_CTRL_E); <span class="comment">// set "E" line</span>
00110             LCD_DELAY;                              <span class="comment">// wait</span>
00111             LCD_DELAY;                              <span class="comment">// wait</span>
00112 <span class="preprocessor">        #endif</span>
00113 <span class="preprocessor"></span>    }
00114     cbi(LCD_CTRL_PORT, LCD_CTRL_E);         <span class="comment">// clear "E" line</span>
00115     <span class="comment">//  leave data lines in input mode so they can be most easily used for other purposes</span>
00116 <span class="preprocessor">#else</span>
00117 <span class="preprocessor"></span>    <span class="comment">// memory bus read</span>
00118     <span class="comment">// sbi(MCUCR, SRW);         // enable RAM waitstate</span>
00119     <span class="comment">// wait until LCD busy bit goes to zero</span>
00120     <span class="keywordflow">while</span>( (*((<span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) (LCD_CTRL_ADDR))) &amp; (1&lt;&lt;LCD_BUSY) );
00121     <span class="comment">// cbi(MCUCR, SRW);         // disable RAM waitstate</span>
00122 <span class="preprocessor">#endif</span>
00123 <span class="preprocessor"></span>}
00124 
00125 <span class="keywordtype">void</span> lcdControlWrite(u08 data) 
00126 {
00127 <span class="comment">// write the control byte to the display controller</span>
00128 <span class="preprocessor">#ifdef LCD_PORT_INTERFACE</span>
00129 <span class="preprocessor"></span>    lcdBusyWait();                          <span class="comment">// wait until LCD not busy</span>
00130     cbi(LCD_CTRL_PORT, LCD_CTRL_RS);            <span class="comment">// set RS to "control"</span>
00131     cbi(LCD_CTRL_PORT, LCD_CTRL_RW);            <span class="comment">// set R/W to "write"</span>
00132 <span class="preprocessor">    #ifdef LCD_DATA_4BIT</span>
00133 <span class="preprocessor"></span>        <span class="comment">// 4 bit write</span>
00134         sbi(LCD_CTRL_PORT, LCD_CTRL_E); <span class="comment">// set "E" line</span>
00135         outb(LCD_DATA_DDR, inb(LCD_DATA_DDR)|0xF0); <span class="comment">// set data I/O lines to output (4bit)</span>
00136         outb(LCD_DATA_POUT, (inb(LCD_DATA_POUT)&amp;0x0F) | (data&amp;0xF0) );  <span class="comment">// output data, high 4 bits</span>
00137         LCD_DELAY;                              <span class="comment">// wait</span>
00138         LCD_DELAY;                              <span class="comment">// wait</span>
00139         cbi(LCD_CTRL_PORT, LCD_CTRL_E); <span class="comment">// clear "E" line</span>
00140         LCD_DELAY;                              <span class="comment">// wait</span>
00141         LCD_DELAY;                              <span class="comment">// wait</span>
00142         sbi(LCD_CTRL_PORT, LCD_CTRL_E); <span class="comment">// set "E" line</span>
00143         outb(LCD_DATA_POUT, (inb(LCD_DATA_POUT)&amp;0x0F) | (data&lt;&lt;4) );    <span class="comment">// output data, low 4 bits</span>
00144         LCD_DELAY;                              <span class="comment">// wait</span>
00145         LCD_DELAY;                              <span class="comment">// wait</span>
00146         cbi(LCD_CTRL_PORT, LCD_CTRL_E); <span class="comment">// clear "E" line</span>
00147 <span class="preprocessor">    #else</span>
00148 <span class="preprocessor"></span>        <span class="comment">// 8 bit write</span>
00149         sbi(LCD_CTRL_PORT, LCD_CTRL_E); <span class="comment">// set "E" line</span>
00150         outb(LCD_DATA_DDR, 0xFF);               <span class="comment">// set data I/O lines to output (8bit)</span>
00151         outb(LCD_DATA_POUT, data);              <span class="comment">// output data, 8bits</span>
00152         LCD_DELAY;                              <span class="comment">// wait</span>
00153         LCD_DELAY;                              <span class="comment">// wait</span>
00154         cbi(LCD_CTRL_PORT, LCD_CTRL_E); <span class="comment">// clear "E" line</span>
00155 <span class="preprocessor">    #endif</span>
00156 <span class="preprocessor"></span>    <span class="comment">//  leave data lines in input mode so they can be most easily used for other purposes</span>
00157 <span class="preprocessor">    #ifdef LCD_DATA_4BIT</span>
00158 <span class="preprocessor"></span>        outb(LCD_DATA_DDR, inb(LCD_DATA_DDR)&amp;0x0F);     <span class="comment">// set data I/O lines to input (4bit)</span>
00159         outb(LCD_DATA_POUT, inb(LCD_DATA_POUT)|0xF0);   <span class="comment">// set pull-ups to on (4bit)</span>
00160 <span class="preprocessor">    #else</span>
00161 <span class="preprocessor"></span>        outb(LCD_DATA_DDR, 0x00);           <span class="comment">// set data I/O lines to input (8bit)</span>
00162         outb(LCD_DATA_POUT, 0xFF);          <span class="comment">// set pull-ups to on (8bit)</span>
00163 <span class="preprocessor">    #endif</span>
00164 <span class="preprocessor"></span><span class="preprocessor">#else</span>
00165 <span class="preprocessor"></span>    <span class="comment">// memory bus write</span>
00166     <span class="comment">//sbi(MCUCR, SRW);          // enable RAM waitstate</span>
00167     lcdBusyWait();              <span class="comment">// wait until LCD not busy</span>
00168     *((<span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) (LCD_CTRL_ADDR)) = data;
00169     <span class="comment">//cbi(MCUCR, SRW);          // disable RAM waitstate</span>
00170 <span class="preprocessor">#endif</span>
00171 <span class="preprocessor"></span>}
00172 
00173 u08 lcdControlRead(<span class="keywordtype">void</span>)
00174 {
00175 <span class="comment">// read the control byte from the display controller</span>
00176     <span class="keyword">register</span> u08 data;
00177 <span class="preprocessor">#ifdef LCD_PORT_INTERFACE</span>
00178 <span class="preprocessor"></span>    lcdBusyWait();              <span class="comment">// wait until LCD not busy</span>
00179 <span class="preprocessor">    #ifdef LCD_DATA_4BIT</span>
00180 <span class="preprocessor"></span>        outb(LCD_DATA_DDR, inb(LCD_DATA_DDR)&amp;0x0F);     <span class="comment">// set data I/O lines to input (4bit)</span>
00181         outb(LCD_DATA_POUT, inb(LCD_DATA_POUT)|0xF0);   <span class="comment">// set pull-ups to on (4bit)</span>
00182 <span class="preprocessor">    #else</span>
00183 <span class="preprocessor"></span>        outb(LCD_DATA_DDR, 0x00);           <span class="comment">// set data I/O lines to input (8bit)</span>
00184         outb(LCD_DATA_POUT, 0xFF);          <span class="comment">// set pull-ups to on (8bit)</span>
00185 <span class="preprocessor">    #endif</span>
00186 <span class="preprocessor"></span>    cbi(LCD_CTRL_PORT, LCD_CTRL_RS);        <span class="comment">// set RS to "control"</span>
00187     sbi(LCD_CTRL_PORT, LCD_CTRL_RW);        <span class="comment">// set R/W to "read"</span>
00188 <span class="preprocessor">    #ifdef LCD_DATA_4BIT</span>
00189 <span class="preprocessor"></span>        <span class="comment">// 4 bit read</span>
00190         sbi(LCD_CTRL_PORT, LCD_CTRL_E); <span class="comment">// set "E" line</span>
00191         LCD_DELAY;                      <span class="comment">// wait</span>
00192         LCD_DELAY;                      <span class="comment">// wait</span>
00193         data = inb(LCD_DATA_PIN)&amp;0xF0;  <span class="comment">// input data, high 4 bits</span>
00194         cbi(LCD_CTRL_PORT, LCD_CTRL_E); <span class="comment">// clear "E" line</span>
00195         LCD_DELAY;                      <span class="comment">// wait</span>
00196         LCD_DELAY;                      <span class="comment">// wait</span>
00197         sbi(LCD_CTRL_PORT, LCD_CTRL_E); <span class="comment">// set "E" line</span>
00198         LCD_DELAY;                      <span class="comment">// wait</span>
00199         LCD_DELAY;                      <span class="comment">// wait</span>
00200         data |= inb(LCD_DATA_PIN)&gt;&gt;4;   <span class="comment">// input data, low 4 bits</span>
00201         cbi(LCD_CTRL_PORT, LCD_CTRL_E); <span class="comment">// clear "E" line</span>
00202 <span class="preprocessor">    #else</span>
00203 <span class="preprocessor"></span>        <span class="comment">// 8 bit read</span>
00204         sbi(LCD_CTRL_PORT, LCD_CTRL_E); <span class="comment">// set "E" line</span>
00205         LCD_DELAY;                      <span class="comment">// wait</span>
00206         LCD_DELAY;                      <span class="comment">// wait</span>
00207         data = inb(LCD_DATA_PIN);       <span class="comment">// input data, 8bits</span>
00208         cbi(LCD_CTRL_PORT, LCD_CTRL_E); <span class="comment">// clear "E" line</span>
00209 <span class="preprocessor">    #endif</span>
00210 <span class="preprocessor"></span>    <span class="comment">//  leave data lines in input mode so they can be most easily used for other purposes</span>
00211 <span class="preprocessor">#else</span>
00212 <span class="preprocessor"></span>    <span class="comment">//sbi(MCUCR, SRW);          // enable RAM waitstate</span>
00213     lcdBusyWait();              <span class="comment">// wait until LCD not busy</span>
00214     data = *((<span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) (LCD_CTRL_ADDR));
00215     <span class="comment">//cbi(MCUCR, SRW);          // disable RAM waitstate</span>
00216 <span class="preprocessor">#endif</span>
00217 <span class="preprocessor"></span>    <span class="keywordflow">return</span> data;
00218 }
00219 
00220 <span class="keywordtype">void</span> lcdDataWrite(u08 data) 
00221 {
00222 <span class="comment">// write a data byte to the display</span>
00223 <span class="preprocessor">#ifdef LCD_PORT_INTERFACE</span>
00224 <span class="preprocessor"></span>    lcdBusyWait();                          <span class="comment">// wait until LCD not busy</span>
00225     sbi(LCD_CTRL_PORT, LCD_CTRL_RS);        <span class="comment">// set RS to "data"</span>
00226     cbi(LCD_CTRL_PORT, LCD_CTRL_RW);        <span class="comment">// set R/W to "write"</span>
00227 <span class="preprocessor">    #ifdef LCD_DATA_4BIT</span>
00228 <span class="preprocessor"></span>        <span class="comment">// 4 bit write</span>
00229         sbi(LCD_CTRL_PORT, LCD_CTRL_E); <span class="comment">// set "E" line</span>
00230         outb(LCD_DATA_DDR, inb(LCD_DATA_DDR)|0xF0); <span class="comment">// set data I/O lines to output (4bit)</span>
00231         outb(LCD_DATA_POUT, (inb(LCD_DATA_POUT)&amp;0x0F) | (data&amp;0xF0) );  <span class="comment">// output data, high 4 bits</span>
00232         LCD_DELAY;                              <span class="comment">// wait</span>
00233         LCD_DELAY;                              <span class="comment">// wait</span>
00234         cbi(LCD_CTRL_PORT, LCD_CTRL_E); <span class="comment">// clear "E" line</span>
00235         LCD_DELAY;                              <span class="comment">// wait</span>
00236         LCD_DELAY;                              <span class="comment">// wait</span>
00237         sbi(LCD_CTRL_PORT, LCD_CTRL_E); <span class="comment">// set "E" line</span>
00238         outb(LCD_DATA_POUT, (inb(LCD_DATA_POUT)&amp;0x0F) | (data&lt;&lt;4) );    <span class="comment">// output data, low 4 bits</span>
00239         LCD_DELAY;                              <span class="comment">// wait</span>
00240         LCD_DELAY;                              <span class="comment">// wait</span>
00241         cbi(LCD_CTRL_PORT, LCD_CTRL_E); <span class="comment">// clear "E" line</span>
00242 <span class="preprocessor">    #else</span>
00243 <span class="preprocessor"></span>        <span class="comment">// 8 bit write</span>
00244         sbi(LCD_CTRL_PORT, LCD_CTRL_E); <span class="comment">// set "E" line</span>
00245         outb(LCD_DATA_DDR, 0xFF);           <span class="comment">// set data I/O lines to output (8bit)</span>
00246         outb(LCD_DATA_POUT, data);          <span class="comment">// output data, 8bits</span>
00247         LCD_DELAY;                              <span class="comment">// wait</span>
00248         LCD_DELAY;                              <span class="comment">// wait</span>
00249         cbi(LCD_CTRL_PORT, LCD_CTRL_E); <span class="comment">// clear "E" line</span>
00250 <span class="preprocessor">    #endif</span>
00251 <span class="preprocessor"></span>    <span class="comment">//  leave data lines in input mode so they can be most easily used for other purposes</span>
00252 <span class="preprocessor">    #ifdef LCD_DATA_4BIT</span>
00253 <span class="preprocessor"></span>        outb(LCD_DATA_DDR, inb(LCD_DATA_DDR)&amp;0x0F);     <span class="comment">// set data I/O lines to input (4bit)</span>
00254         outb(LCD_DATA_POUT, inb(LCD_DATA_POUT)|0xF0);   <span class="comment">// set pull-ups to on (4bit)</span>
00255 <span class="preprocessor">    #else</span>
00256 <span class="preprocessor"></span>        outb(LCD_DATA_DDR, 0x00);           <span class="comment">// set data I/O lines to input (8bit)</span>
00257         outb(LCD_DATA_POUT, 0xFF);          <span class="comment">// set pull-ups to on (8bit)</span>
00258 <span class="preprocessor">    #endif</span>
00259 <span class="preprocessor"></span><span class="preprocessor">#else</span>
00260 <span class="preprocessor"></span>    <span class="comment">// memory bus write</span>
00261     <span class="comment">//sbi(MCUCR, SRW);          // enable RAM waitstate</span>
00262     lcdBusyWait();              <span class="comment">// wait until LCD not busy</span>
00263     *((<span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) (LCD_DATA_ADDR)) = data;
00264     <span class="comment">//cbi(MCUCR, SRW);          // disable RAM waitstate</span>
00265 <span class="preprocessor">#endif</span>
00266 <span class="preprocessor"></span>}
00267 
00268 u08 lcdDataRead(<span class="keywordtype">void</span>)
00269 {
00270 <span class="comment">// read a data byte from the display</span>
00271     <span class="keyword">register</span> u08 data;
00272 <span class="preprocessor">#ifdef LCD_PORT_INTERFACE</span>
00273 <span class="preprocessor"></span>    lcdBusyWait();              <span class="comment">// wait until LCD not busy</span>
00274 <span class="preprocessor">    #ifdef LCD_DATA_4BIT</span>
00275 <span class="preprocessor"></span>        outb(LCD_DATA_DDR, inb(LCD_DATA_DDR)&amp;0x0F);     <span class="comment">// set data I/O lines to input (4bit)</span>
00276         outb(LCD_DATA_POUT, inb(LCD_DATA_POUT)|0xF0);   <span class="comment">// set pull-ups to on (4bit)</span>
00277 <span class="preprocessor">    #else</span>
00278 <span class="preprocessor"></span>        outb(LCD_DATA_DDR, 0x00);           <span class="comment">// set data I/O lines to input (8bit)</span>
00279         outb(LCD_DATA_POUT, 0xFF);          <span class="comment">// set pull-ups to on (8bit)</span>
00280 <span class="preprocessor">    #endif</span>
00281 <span class="preprocessor"></span>    sbi(LCD_CTRL_PORT, LCD_CTRL_RS);        <span class="comment">// set RS to "data"</span>
00282     sbi(LCD_CTRL_PORT, LCD_CTRL_RW);        <span class="comment">// set R/W to "read"</span>
00283 <span class="preprocessor">    #ifdef LCD_DATA_4BIT</span>
00284 <span class="preprocessor"></span>        <span class="comment">// 4 bit read</span>
00285         sbi(LCD_CTRL_PORT, LCD_CTRL_E); <span class="comment">// set "E" line</span>
00286         LCD_DELAY;                              <span class="comment">// wait</span>
00287         LCD_DELAY;                              <span class="comment">// wait</span>
00288         data = inb(LCD_DATA_PIN)&amp;0xF0;  <span class="comment">// input data, high 4 bits</span>
00289         cbi(LCD_CTRL_PORT, LCD_CTRL_E); <span class="comment">// clear "E" line</span>
00290         LCD_DELAY;                              <span class="comment">// wait</span>
00291         LCD_DELAY;                              <span class="comment">// wait</span>
00292         sbi(LCD_CTRL_PORT, LCD_CTRL_E); <span class="comment">// set "E" line</span>
00293         LCD_DELAY;                              <span class="comment">// wait</span>
00294         LCD_DELAY;                              <span class="comment">// wait</span>
00295         data |= inb(LCD_DATA_PIN)&gt;&gt;4;           <span class="comment">// input data, low 4 bits</span>
00296         cbi(LCD_CTRL_PORT, LCD_CTRL_E); <span class="comment">// clear "E" line</span>
00297 <span class="preprocessor">    #else</span>
00298 <span class="preprocessor"></span>        <span class="comment">// 8 bit read</span>
00299         sbi(LCD_CTRL_PORT, LCD_CTRL_E); <span class="comment">// set "E" line</span>
00300         LCD_DELAY;                              <span class="comment">// wait</span>
00301         LCD_DELAY;                              <span class="comment">// wait</span>
00302         data = inb(LCD_DATA_PIN);           <span class="comment">// input data, 8bits</span>
00303         cbi(LCD_CTRL_PORT, LCD_CTRL_E); <span class="comment">// clear "E" line</span>
00304 <span class="preprocessor">    #endif</span>
00305 <span class="preprocessor"></span>    <span class="comment">//  leave data lines in input mode so they can be most easily used for other purposes</span>
00306 <span class="preprocessor">#else</span>
00307 <span class="preprocessor"></span>    <span class="comment">// memory bus read</span>
00308     <span class="comment">//sbi(MCUCR, SRW);          // enable RAM waitstate</span>
00309     lcdBusyWait();              <span class="comment">// wait until LCD not busy</span>
00310     data = *((<span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) (LCD_DATA_ADDR));
00311     <span class="comment">//cbi(MCUCR, SRW);          // disable RAM waitstate</span>
00312 <span class="preprocessor">#endif</span>
00313 <span class="preprocessor"></span>    <span class="keywordflow">return</span> data;
00314 }
00315 
00316 
00317 
00318 <span class="comment">/*************************************************************/</span>
00319 <span class="comment">/********************* PUBLIC FUNCTIONS **********************/</span>
00320 <span class="comment">/*************************************************************/</span>
00321 
00322 <span class="keywordtype">void</span> lcdInit()
00323 {
00324     <span class="comment">// initialize hardware</span>
00325     lcdInitHW();
00326     <span class="comment">// LCD function set</span>
00327     lcdControlWrite(LCD_FUNCTION_DEFAULT);
00328     <span class="comment">// clear LCD</span>
00329     lcdControlWrite(1&lt;&lt;LCD_CLR);
00330     delay(60000);   <span class="comment">// wait 60ms</span>
00331     <span class="comment">// set entry mode</span>
00332     lcdControlWrite(1&lt;&lt;LCD_ENTRY_MODE | 1&lt;&lt;LCD_ENTRY_INC);
00333     <span class="comment">// set display to on</span>
00334     <span class="comment">//lcdControlWrite(1&lt;&lt;LCD_ON_CTRL | 1&lt;&lt;LCD_ON_DISPLAY | 1&lt;&lt;LCD_ON_BLINK);</span>
00335     lcdControlWrite(1&lt;&lt;LCD_ON_CTRL | 1&lt;&lt;LCD_ON_DISPLAY );
00336     <span class="comment">// move cursor to home</span>
00337     lcdControlWrite(1&lt;&lt;LCD_HOME);
00338     <span class="comment">// set data address to 0</span>
00339     lcdControlWrite(1&lt;&lt;LCD_DDRAM | 0x00);
00340 
00341     <span class="comment">// load the first 8 custom characters</span>
00342     lcdLoadCustomChar((u08*)LcdCustomChar,0,0);
00343     lcdLoadCustomChar((u08*)LcdCustomChar,1,1);
00344     lcdLoadCustomChar((u08*)LcdCustomChar,2,2);
00345     lcdLoadCustomChar((u08*)LcdCustomChar,3,3);
00346     lcdLoadCustomChar((u08*)LcdCustomChar,4,4);
00347     lcdLoadCustomChar((u08*)LcdCustomChar,5,5);
00348     lcdLoadCustomChar((u08*)LcdCustomChar,6,6);
00349     lcdLoadCustomChar((u08*)LcdCustomChar,7,7);
00350 }
00351 
00352 <span class="keywordtype">void</span> lcdHome(<span class="keywordtype">void</span>)
00353 {
00354     <span class="comment">// move cursor to home</span>
00355     lcdControlWrite(1&lt;&lt;LCD_HOME);
00356 }
00357 
00358 <span class="keywordtype">void</span> lcdClear(<span class="keywordtype">void</span>)
00359 {
00360     <span class="comment">// clear LCD</span>
00361     lcdControlWrite(1&lt;&lt;LCD_CLR);
00362 }
00363 
00364 <span class="keywordtype">void</span> lcdGotoXY(u08 x, u08 y)
00365 {
00366     <span class="keyword">register</span> u08 DDRAMAddr;
00367 
00368     <span class="comment">// remap lines into proper order</span>
00369     <span class="keywordflow">switch</span>(y)
00370     {
00371     <span class="keywordflow">case</span> 0: DDRAMAddr = LCD_LINE0_DDRAMADDR+x; <span class="keywordflow">break</span>;
00372     <span class="keywordflow">case</span> 1: DDRAMAddr = LCD_LINE1_DDRAMADDR+x; <span class="keywordflow">break</span>;
00373     <span class="keywordflow">case</span> 2: DDRAMAddr = LCD_LINE2_DDRAMADDR+x; <span class="keywordflow">break</span>;
00374     <span class="keywordflow">case</span> 3: DDRAMAddr = LCD_LINE3_DDRAMADDR+x; <span class="keywordflow">break</span>;
00375     <span class="keywordflow">default</span>: DDRAMAddr = LCD_LINE0_DDRAMADDR+x;
00376     }
00377 
00378     <span class="comment">// set data address</span>
00379     lcdControlWrite(1&lt;&lt;LCD_DDRAM | DDRAMAddr);
00380 }
00381 
00382 <span class="keywordtype">void</span> lcdLoadCustomChar(u08* lcdCustomCharArray, u08 romCharNum, u08 lcdCharNum)
00383 {
00384     <span class="keyword">register</span> u08 i;
00385     u08 saveDDRAMAddr;
00386 
00387     <span class="comment">// backup the current cursor position</span>
00388     saveDDRAMAddr = lcdControlRead() &amp; 0x7F;
00389 
00390     <span class="comment">// multiply the character index by 8</span>
00391     lcdCharNum = (lcdCharNum&lt;&lt;3);   <span class="comment">// each character occupies 8 bytes</span>
00392     romCharNum = (romCharNum&lt;&lt;3);   <span class="comment">// each character occupies 8 bytes</span>
00393 
00394     <span class="comment">// copy the 8 bytes into CG (character generator) RAM</span>
00395     <span class="keywordflow">for</span>(i=0; i&lt;8; i++)
00396     {
00397         <span class="comment">// set CG RAM address</span>
00398         lcdControlWrite((1&lt;&lt;LCD_CGRAM) | (lcdCharNum+i));
00399         <span class="comment">// write character data</span>
00400         lcdDataWrite( pgm_read_byte(lcdCustomCharArray+romCharNum+i) );
00401     }
00402 
00403     <span class="comment">// restore the previous cursor position</span>
00404     lcdControlWrite(1&lt;&lt;LCD_DDRAM | saveDDRAMAddr);
00405 
00406 }
00407 
00408 <span class="keywordtype">void</span> lcdPrintData(<span class="keywordtype">char</span>* data, u08 nBytes)
00409 {
00410     <span class="keyword">register</span> u08 i;
00411 
00412     <span class="comment">// check to make sure we have a good pointer</span>
00413     <span class="keywordflow">if</span> (!data) <span class="keywordflow">return</span>;
00414 
00415     <span class="comment">// print data</span>
00416     <span class="keywordflow">for</span>(i=0; i&lt;nBytes; i++)
00417     {
00418         lcdDataWrite(data[i]);
00419     }
00420 }
00421 
00422 <span class="keywordtype">void</span> lcdProgressBar(u16 progress, u16 maxprogress, u08 length)
00423 {
00424     u08 i;
00425     u32 pixelprogress;
00426     u08 c;
00427 
00428     <span class="comment">// draw a progress bar displaying (progress / maxprogress)</span>
00429     <span class="comment">// starting from the current cursor position</span>
00430     <span class="comment">// with a total length of "length" characters</span>
00431     <span class="comment">// ***note, LCD chars 0-5 must be programmed as the bar characters</span>
00432     <span class="comment">// char 0 = empty ... char 5 = full</span>
00433 
00434     <span class="comment">// total pixel length of bargraph equals length*PROGRESSPIXELS_PER_CHAR;</span>
00435     <span class="comment">// pixel length of bar itself is</span>
00436     pixelprogress = ((progress*(length*PROGRESSPIXELS_PER_CHAR))/maxprogress);
00437     
00438     <span class="comment">// print exactly "length" characters</span>
00439     <span class="keywordflow">for</span>(i=0; i&lt;length; i++)
00440     {
00441         <span class="comment">// check if this is a full block, or partial or empty</span>
00442         <span class="comment">// (u16) cast is needed to avoid sign comparison warning</span>
00443         <span class="keywordflow">if</span>( ((i*(u16)PROGRESSPIXELS_PER_CHAR)+5) &gt; pixelprogress )
00444         {
00445             <span class="comment">// this is a partial or empty block</span>
00446             <span class="keywordflow">if</span>( ((i*(u16)PROGRESSPIXELS_PER_CHAR)) &gt; pixelprogress )
00447             {
00448                 <span class="comment">// this is an empty block</span>
00449                 <span class="comment">// use space character?</span>
00450                 c = 0;
00451             }
00452             <span class="keywordflow">else</span>
00453             {
00454                 <span class="comment">// this is a partial block</span>
00455                 c = pixelprogress % PROGRESSPIXELS_PER_CHAR;
00456             }
00457         }
00458         <span class="keywordflow">else</span>
00459         {
00460             <span class="comment">// this is a full block</span>
00461             c = 5;
00462         }
00463         
00464         <span class="comment">// write character to display</span>
00465         lcdDataWrite(c);
00466     }
00467 
00468 }
00469 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Sun Oct 29 03:41:07 2006 for Procyon AVRlib by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.2 </small></address>
</body>
</html>
