<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Procyon AVRlib: timer128.c Source File</title>
<link href="dox.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.2 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>timer128.c</h1><a href="timer128_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*! \file timer128.c \brief System Timer function library for Mega128. */</span>
00002 <span class="comment">//*****************************************************************************</span>
00003 <span class="comment">//</span>
00004 <span class="comment">// File Name    : 'timer128.c'</span>
00005 <span class="comment">// Title        : System Timer function library for Mega128</span>
00006 <span class="comment">// Author       : Pascal Stang - Copyright (C) 2000-2003</span>
00007 <span class="comment">// Created      : 11/22/2000</span>
00008 <span class="comment">// Revised      : 02/24/2003</span>
00009 <span class="comment">// Version      : 1.2</span>
00010 <span class="comment">// Target MCU   : Atmel AVR Series</span>
00011 <span class="comment">// Editor Tabs  : 4</span>
00012 <span class="comment">//</span>
00013 <span class="comment">// This code is distributed under the GNU Public License</span>
00014 <span class="comment">//      which can be found at http://www.gnu.org/licenses/gpl.txt</span>
00015 <span class="comment">//</span>
00016 <span class="comment">//*****************************************************************************</span>
00017 
00018 <span class="preprocessor">#include &lt;avr/io.h&gt;</span>
00019 <span class="preprocessor">#include &lt;avr/interrupt.h&gt;</span>
00020 <span class="preprocessor">#include &lt;avr/pgmspace.h&gt;</span>
00021 <span class="preprocessor">#include &lt;avr/sleep.h&gt;</span>
00022 
00023 <span class="preprocessor">#include "<a class="code" href="global_8h.html">global.h</a>"</span>
00024 <span class="preprocessor">#include "<a class="code" href="timer128_8h.html">timer128.h</a>"</span>
00025 
00026 <span class="comment">// Program ROM constants</span>
00027 <span class="comment">// the prescale division values stored in order of timer control register index</span>
00028 <span class="comment">// STOP, CLK, CLK/8, CLK/64, CLK/256, CLK/1024</span>
00029 <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> __attribute__ ((progmem)) TimerPrescaleFactor[] = {0,1,8,64,256,1024};
00030 <span class="comment">// the prescale division values stored in order of timer control register index</span>
00031 <span class="comment">// STOP, CLK, CLK/8, CLK/32, CLK/64, CLK/128, CLK/256, CLK/1024</span>
00032 <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> __attribute__ ((progmem)) TimerRTCPrescaleFactor[] = {0,1,8,32,64,128,256,1024};
00033 
00034 <span class="comment">// Global variables</span>
00035 <span class="comment">// time registers</span>
00036 <span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> TimerPauseReg;
00037 <span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> Timer0Reg0;
00038 <span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> Timer0Reg1;
00039 <span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> Timer2Reg0;
00040 <span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> Timer2Reg1;
00041 
00042 <span class="keyword">typedef</span> void (*voidFuncPtr)(void);
00043 <span class="keyword">volatile</span> <span class="keyword">static</span> voidFuncPtr TimerIntFunc[TIMER_NUM_INTERRUPTS];
00044 
00045 <span class="comment">// delay for a minimum of &lt;us&gt; microseconds </span>
00046 <span class="comment">// the time resolution is dependent on the time the loop takes </span>
00047 <span class="comment">// e.g. with 4Mhz and 5 cycles per loop, the resolution is 1.25 us </span>
00048 <span class="keywordtype">void</span> delay_us(<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> time_us) 
00049 {
00050     <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> delay_loops;
00051     <span class="keyword">register</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> i;
00052 
00053     delay_loops = (time_us+3)/5*CYCLES_PER_US; <span class="comment">// +3 for rounding up (dirty) </span>
00054 
00055     <span class="comment">// one loop takes 5 cpu cycles </span>
00056     <span class="keywordflow">for</span> (i=0; i &lt; delay_loops; i++) {};
00057 }
00058 <span class="comment">/*</span>
00059 <span class="comment">void delay_ms(unsigned char time_ms)</span>
00060 <span class="comment">{</span>
00061 <span class="comment">    unsigned short delay_count = F_CPU / 4000;</span>
00062 <span class="comment"></span>
00063 <span class="comment">    unsigned short cnt;</span>
00064 <span class="comment">    asm volatile ("\n"</span>
00065 <span class="comment">                  "L_dl1%=:\n\t"</span>
00066 <span class="comment">                  "mov %A0, %A2\n\t"</span>
00067 <span class="comment">                  "mov %B0, %B2\n"</span>
00068 <span class="comment">                  "L_dl2%=:\n\t"</span>
00069 <span class="comment">                  "sbiw %A0, 1\n\t"</span>
00070 <span class="comment">                  "brne L_dl2%=\n\t"</span>
00071 <span class="comment">                  "dec %1\n\t" "brne L_dl1%=\n\t":"=&amp;w" (cnt)</span>
00072 <span class="comment">                  :"r"(time_ms), "r"((unsigned short) (delay_count))</span>
00073 <span class="comment">    );</span>
00074 <span class="comment">}</span>
00075 <span class="comment">*/</span>
<a name="l00076"></a><a class="code" href="group__timer.html#ga1">00076</a> <span class="keywordtype">void</span> <a class="code" href="group__timer.html#ga1">timerInit</a>(<span class="keywordtype">void</span>)
00077 {
00078     u08 intNum;
00079     <span class="comment">// detach all user functions from interrupts</span>
00080     <span class="keywordflow">for</span>(intNum=0; intNum&lt;TIMER_NUM_INTERRUPTS; intNum++)
00081         <a class="code" href="group__timer.html#ga9">timerDetach</a>(intNum);
00082 
00083     <span class="comment">// initialize all timers</span>
00084     <a class="code" href="group__timer.html#ga2">timer0Init</a>();
00085     <a class="code" href="group__timer.html#ga3">timer1Init</a>();
00086     timer2Init();
00087     timer3Init();
00088     <span class="comment">// enable interrupts</span>
00089     sei();
00090 }
00091 
<a name="l00092"></a><a class="code" href="group__timer.html#ga2">00092</a> <span class="keywordtype">void</span> <a class="code" href="group__timer.html#ga2">timer0Init</a>()
00093 {
00094     <span class="comment">// initialize timer 0</span>
00095     <a class="code" href="group__timer.html#ga4">timer0SetPrescaler</a>( <a class="code" href="group__timer.html#ga33">TIMER0PRESCALE</a> );   <span class="comment">// set prescaler</span>
00096     outb(TCNT0, 0);                         <span class="comment">// reset TCNT0</span>
00097     sbi(TIMSK, TOIE0);                      <span class="comment">// enable TCNT0 overflow interrupt</span>
00098 
00099     <a class="code" href="group__timer.html#ga11">timer0ClearOverflowCount</a>();             <span class="comment">// initialize time registers</span>
00100 }
00101 
<a name="l00102"></a><a class="code" href="group__timer.html#ga3">00102</a> <span class="keywordtype">void</span> <a class="code" href="group__timer.html#ga3">timer1Init</a>(<span class="keywordtype">void</span>)
00103 {
00104     <span class="comment">// initialize timer 1</span>
00105     <a class="code" href="group__timer.html#ga6">timer1SetPrescaler</a>( <a class="code" href="group__timer.html#ga34">TIMER1PRESCALE</a> );   <span class="comment">// set prescaler</span>
00106     outb(TCNT1H, 0);                        <span class="comment">// reset TCNT1</span>
00107     outb(TCNT1L, 0);
00108     sbi(TIMSK, TOIE1);                      <span class="comment">// enable TCNT1 overflow</span>
00109 }
00110 
00111 <span class="keywordtype">void</span> timer2Init(<span class="keywordtype">void</span>)
00112 {
00113     <span class="comment">// initialize timer 2</span>
00114     <a class="code" href="group__timer128.html#ga8">timer2SetPrescaler</a>( <a class="code" href="group__timer.html#ga35">TIMER2PRESCALE</a> );   <span class="comment">// set prescaler</span>
00115     outb(TCNT2, 0);                         <span class="comment">// reset TCNT2</span>
00116     sbi(TIMSK, TOIE2);                      <span class="comment">// enable TCNT2 overflow</span>
00117 
00118     timer2ClearOverflowCount();             <span class="comment">// initialize time registers</span>
00119 }
00120 
00121 <span class="keywordtype">void</span> timer3Init(<span class="keywordtype">void</span>)
00122 {
00123     <span class="comment">// initialize timer 3</span>
00124     <a class="code" href="group__timer128.html#ga9">timer3SetPrescaler</a>( <a class="code" href="group__timer128.html#ga66">TIMER3PRESCALE</a> );   <span class="comment">// set prescaler</span>
00125     outb(TCNT3H, 0);                        <span class="comment">// reset TCNT3</span>
00126     outb(TCNT3L, 0);
00127     sbi(ETIMSK, TOIE3);                     <span class="comment">// enable TCNT3 overflow</span>
00128 }
00129 
<a name="l00130"></a><a class="code" href="group__timer.html#ga4">00130</a> <span class="keywordtype">void</span> <a class="code" href="group__timer.html#ga4">timer0SetPrescaler</a>(u08 prescale)
00131 {
00132     <span class="comment">// set prescaler on timer 0</span>
00133     outb(TCCR0, (inb(TCCR0) &amp; ~<a class="code" href="group__timer.html#ga23">TIMER_PRESCALE_MASK</a>) | prescale);
00134 }
00135 
<a name="l00136"></a><a class="code" href="group__timer.html#ga6">00136</a> <span class="keywordtype">void</span> <a class="code" href="group__timer.html#ga6">timer1SetPrescaler</a>(u08 prescale)
00137 {
00138     <span class="comment">// set prescaler on timer 1</span>
00139     outb(TCCR1B, (inb(TCCR1B) &amp; ~<a class="code" href="group__timer.html#ga23">TIMER_PRESCALE_MASK</a>) | prescale);
00140 }
00141 
<a name="l00142"></a><a class="code" href="group__timer128.html#ga8">00142</a> <span class="keywordtype">void</span> <a class="code" href="group__timer128.html#ga8">timer2SetPrescaler</a>(u08 prescale)
00143 {
00144     <span class="comment">// set prescaler on timer 2</span>
00145     outb(TCCR2, (inb(TCCR2) &amp; ~<a class="code" href="group__timer.html#ga23">TIMER_PRESCALE_MASK</a>) | prescale);
00146 }
00147 
<a name="l00148"></a><a class="code" href="group__timer128.html#ga9">00148</a> <span class="keywordtype">void</span> <a class="code" href="group__timer128.html#ga9">timer3SetPrescaler</a>(u08 prescale)
00149 {
00150     <span class="comment">// set prescaler on timer 2</span>
00151     outb(TCCR3B, (inb(TCCR3B) &amp; ~<a class="code" href="group__timer.html#ga23">TIMER_PRESCALE_MASK</a>) | prescale);
00152 }
00153 
<a name="l00154"></a><a class="code" href="group__timer.html#ga5">00154</a> u16 <a class="code" href="group__timer.html#ga5">timer0GetPrescaler</a>(<span class="keywordtype">void</span>)
00155 {
00156     <span class="comment">// get the current prescaler setting</span>
00157     <span class="keywordflow">return</span> (pgm_read_word(TimerPrescaleFactor+(inb(TCCR0) &amp; <a class="code" href="group__timer.html#ga23">TIMER_PRESCALE_MASK</a>)));
00158 }
00159 
<a name="l00160"></a><a class="code" href="group__timer.html#ga7">00160</a> u16 <a class="code" href="group__timer.html#ga7">timer1GetPrescaler</a>(<span class="keywordtype">void</span>)
00161 {
00162     <span class="comment">// get the current prescaler setting</span>
00163     <span class="keywordflow">return</span> (pgm_read_word(TimerPrescaleFactor+(inb(TCCR1B) &amp; <a class="code" href="group__timer.html#ga23">TIMER_PRESCALE_MASK</a>)));
00164 }
00165 
<a name="l00166"></a><a class="code" href="group__timer128.html#ga12">00166</a> u16 <a class="code" href="group__timer128.html#ga12">timer2GetPrescaler</a>(<span class="keywordtype">void</span>)
00167 {
00168     <span class="comment">// get the current prescaler setting</span>
00169     <span class="keywordflow">return</span> (pgm_read_word(TimerPrescaleFactor+(inb(TCCR2) &amp; <a class="code" href="group__timer.html#ga23">TIMER_PRESCALE_MASK</a>)));
00170 }
00171 
<a name="l00172"></a><a class="code" href="group__timer128.html#ga13">00172</a> u16 <a class="code" href="group__timer128.html#ga13">timer3GetPrescaler</a>(<span class="keywordtype">void</span>)
00173 {
00174     <span class="comment">// get the current prescaler setting</span>
00175     <span class="keywordflow">return</span> (pgm_read_word(TimerPrescaleFactor+(inb(TCCR3B) &amp; <a class="code" href="group__timer.html#ga23">TIMER_PRESCALE_MASK</a>)));
00176 }
00177 
<a name="l00178"></a><a class="code" href="group__timer.html#ga8">00178</a> <span class="keywordtype">void</span> <a class="code" href="group__timer.html#ga8">timerAttach</a>(u08 interruptNum, <span class="keywordtype">void</span> (*userFunc)(<span class="keywordtype">void</span>) )
00179 {
00180     <span class="comment">// make sure the interrupt number is within bounds</span>
00181     <span class="keywordflow">if</span>(interruptNum &lt; TIMER_NUM_INTERRUPTS)
00182     {
00183         <span class="comment">// set the interrupt function to run</span>
00184         <span class="comment">// the supplied user's function</span>
00185         TimerIntFunc[interruptNum] = userFunc;
00186     }
00187 }
00188 
<a name="l00189"></a><a class="code" href="group__timer.html#ga9">00189</a> <span class="keywordtype">void</span> <a class="code" href="group__timer.html#ga9">timerDetach</a>(u08 interruptNum)
00190 {
00191     <span class="comment">// make sure the interrupt number is within bounds</span>
00192     <span class="keywordflow">if</span>(interruptNum &lt; TIMER_NUM_INTERRUPTS)
00193     {
00194         <span class="comment">// set the interrupt function to run nothing</span>
00195         TimerIntFunc[interruptNum] = 0;
00196     }
00197 }
00198 
<a name="l00199"></a><a class="code" href="group__timer.html#ga10">00199</a> <span class="keywordtype">void</span> <a class="code" href="group__timer.html#ga10">timerPause</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> pause_ms)
00200 {
00201     <span class="comment">// pauses for exactly &lt;pause_ms&gt; number of milliseconds</span>
00202     u08 timerThres;
00203     u32 ticRateHz;
00204     u32 pause;
00205 
00206     <span class="comment">// capture current pause timer value</span>
00207     timerThres = inb(TCNT2);
00208     <span class="comment">// reset pause timer overflow count</span>
00209     TimerPauseReg = 0;
00210     <span class="comment">// calculate delay for [pause_ms] milliseconds</span>
00211     <span class="comment">// prescaler division = 1&lt;&lt;(pgm_read_byte(TimerPrescaleFactor+inb(TCCR2)))</span>
00212     ticRateHz = F_CPU/<a class="code" href="group__timer128.html#ga12">timer2GetPrescaler</a>();
00213     <span class="comment">// precision management</span>
00214     <span class="comment">// prevent overflow and precision underflow</span>
00215     <span class="comment">//  -could add more conditions to improve accuracy</span>
00216     <span class="keywordflow">if</span>( ((ticRateHz &lt; 429497) &amp;&amp; (pause_ms &lt;= 10000)) )
00217         pause = (pause_ms*ticRateHz)/1000;
00218     <span class="keywordflow">else</span>
00219         pause = pause_ms*(ticRateHz/1000);
00220     
00221     <span class="comment">// loop until time expires</span>
00222     <span class="keywordflow">while</span>( ((TimerPauseReg&lt;&lt;8) | inb(TCNT2)) &lt; (pause+timerThres) )
00223     {
00224         <span class="keywordflow">if</span>( TimerPauseReg &lt; (pause&gt;&gt;8));
00225         {
00226             <span class="comment">// save power by idling the processor</span>
00227             set_sleep_mode(SLEEP_MODE_IDLE);
00228             sleep_mode();
00229         }
00230     }
00231 }
00232 
<a name="l00233"></a><a class="code" href="group__timer.html#ga11">00233</a> <span class="keywordtype">void</span> <a class="code" href="group__timer.html#ga11">timer0ClearOverflowCount</a>(<span class="keywordtype">void</span>)
00234 {
00235     <span class="comment">// clear the timer overflow counter registers</span>
00236     Timer0Reg0 = 0; <span class="comment">// initialize time registers</span>
00237     Timer0Reg1 = 0; <span class="comment">// initialize time registers</span>
00238 }
00239 
<a name="l00240"></a><a class="code" href="group__timer.html#ga12">00240</a> <span class="keywordtype">long</span> <a class="code" href="group__timer.html#ga12">timer0GetOverflowCount</a>(<span class="keywordtype">void</span>)
00241 {
00242     <span class="comment">// return the current timer overflow count</span>
00243     <span class="comment">// (this is since the last timer0ClearOverflowCount() command was called)</span>
00244     <span class="keywordflow">return</span> Timer0Reg0;
00245 }
00246 
00247 <span class="keywordtype">void</span> timer2ClearOverflowCount(<span class="keywordtype">void</span>)
00248 {
00249     <span class="comment">// clear the timer overflow counter registers</span>
00250     Timer2Reg0 = 0; <span class="comment">// initialize time registers</span>
00251     Timer2Reg1 = 0; <span class="comment">// initialize time registers</span>
00252 }
00253 
00254 <span class="keywordtype">long</span> timer2GetOverflowCount(<span class="keywordtype">void</span>)
00255 {
00256     <span class="comment">// return the current timer overflow count</span>
00257     <span class="comment">// (this is since the last timer2ClearOverflowCount() command was called)</span>
00258     <span class="keywordflow">return</span> Timer2Reg0;
00259 }
00260 
00261 
<a name="l00262"></a><a class="code" href="group__timerpwm.html#ga0">00262</a> <span class="keywordtype">void</span> <a class="code" href="group__timerpwm.html#ga0">timer1PWMInit</a>(u08 bitRes)
00263 {
00264     <span class="comment">// configures timer1 for use with PWM output</span>
00265     <span class="comment">// on pins OC1A, OC1B, and OC1C</span>
00266 
00267     <span class="comment">// enable Timer1 as 8,9,10bit PWM</span>
00268     <span class="keywordflow">if</span>(bitRes == 9)
00269     {   <span class="comment">// 9bit mode</span>
00270         sbi(TCCR1A,WGMA1);
00271         cbi(TCCR1A,WGMA0);
00272     }
00273     <span class="keywordflow">else</span> <span class="keywordflow">if</span>( bitRes == 10 )
00274     {   <span class="comment">// 10bit mode</span>
00275         sbi(TCCR1A,WGMA1);
00276         sbi(TCCR1A,WGMA0);
00277     }
00278     <span class="keywordflow">else</span>
00279     {   <span class="comment">// default 8bit mode</span>
00280         cbi(TCCR1A,WGMA1);
00281         sbi(TCCR1A,WGMA0);
00282     }
00283 
00284     <span class="comment">// set clear-timer-on-compare-match</span>
00285     <span class="comment">//cbi(TCCR1B,CTC1);</span>
00286     <span class="comment">// clear output compare value A</span>
00287     outb(OCR1AH, 0);
00288     outb(OCR1AL, 0);
00289     <span class="comment">// clear output compare value B</span>
00290     outb(OCR1BH, 0);
00291     outb(OCR1BL, 0);
00292     <span class="comment">// clear output compare value C</span>
00293     outb(OCR1CH, 0);
00294     outb(OCR1CL, 0);
00295 }
00296 
<a name="l00297"></a><a class="code" href="group__timer128.html#ga22">00297</a> <span class="keywordtype">void</span> <a class="code" href="group__timerpwm.html#ga1">timer1PWMInitICR</a>(u16 topcount)
00298 {
00299     <span class="comment">// set PWM mode with ICR top-count</span>
00300     cbi(TCCR1A,WGM10);
00301     sbi(TCCR1A,WGM11);
00302     sbi(TCCR1B,WGM12);
00303     sbi(TCCR1B,WGM13);
00304     
00305     <span class="comment">// set top count value</span>
00306     ICR1H = (u08)(topcount&gt;&gt;8);
00307     ICR1L = (u08)topcount;
00308     
00309     <span class="comment">// clear output compare value A</span>
00310     outb(OCR1AH, 0);
00311     outb(OCR1AL, 0);
00312     <span class="comment">// clear output compare value B</span>
00313     outb(OCR1BH, 0);
00314     outb(OCR1BL, 0);
00315     <span class="comment">// clear output compare value C</span>
00316     outb(OCR1CH, 0);
00317     outb(OCR1CL, 0);
00318 }
00319 
<a name="l00320"></a><a class="code" href="group__timerpwm.html#ga2">00320</a> <span class="keywordtype">void</span> <a class="code" href="group__timerpwm.html#ga2">timer1PWMOff</a>(<span class="keywordtype">void</span>)
00321 {
00322     <span class="comment">// turn off PWM on Timer1</span>
00323     cbi(TCCR1A,WGMA1);
00324     cbi(TCCR1A,WGMA0);
00325     <span class="comment">// clear (disable) clear-timer-on-compare-match</span>
00326     <span class="comment">//cbi(TCCR1B,CTC1);</span>
00327     <span class="comment">// set PWM1A/B/C (OutputCompare action) to none</span>
00328     <a class="code" href="group__timerpwm.html#ga5">timer1PWMAOff</a>();
00329     <a class="code" href="group__timerpwm.html#ga6">timer1PWMBOff</a>();
00330     <a class="code" href="group__timer128.html#ga29">timer1PWMCOff</a>();
00331 }
00332 
<a name="l00333"></a><a class="code" href="group__timerpwm.html#ga3">00333</a> <span class="keywordtype">void</span> <a class="code" href="group__timerpwm.html#ga3">timer1PWMAOn</a>(<span class="keywordtype">void</span>)
00334 {
00335     <span class="comment">// turn on channel A (OC1A) PWM output</span>
00336     <span class="comment">// set OC1A as non-inverted PWM</span>
00337     sbi(TCCR1A,COMA1);
00338     cbi(TCCR1A,COMA0);
00339 }
00340 
<a name="l00341"></a><a class="code" href="group__timerpwm.html#ga4">00341</a> <span class="keywordtype">void</span> <a class="code" href="group__timerpwm.html#ga4">timer1PWMBOn</a>(<span class="keywordtype">void</span>)
00342 {
00343     <span class="comment">// turn on channel B (OC1B) PWM output</span>
00344     <span class="comment">// set OC1B as non-inverted PWM</span>
00345     sbi(TCCR1A,COMB1);
00346     cbi(TCCR1A,COMB0);
00347 }
00348 
<a name="l00349"></a><a class="code" href="group__timer128.html#ga26">00349</a> <span class="keywordtype">void</span> <a class="code" href="group__timer128.html#ga26">timer1PWMCOn</a>(<span class="keywordtype">void</span>)
00350 {
00351     <span class="comment">// turn on channel C (OC1C) PWM output</span>
00352     <span class="comment">// set OC1C as non-inverted PWM</span>
00353     sbi(TCCR1A,COMC1);
00354     cbi(TCCR1A,COMC0);
00355 }
00356 
<a name="l00357"></a><a class="code" href="group__timerpwm.html#ga5">00357</a> <span class="keywordtype">void</span> <a class="code" href="group__timerpwm.html#ga5">timer1PWMAOff</a>(<span class="keywordtype">void</span>)
00358 {
00359     <span class="comment">// turn off channel A (OC1A) PWM output</span>
00360     <span class="comment">// set OC1A (OutputCompare action) to none</span>
00361     cbi(TCCR1A,COMA1);
00362     cbi(TCCR1A,COMA0);
00363 }
00364 
<a name="l00365"></a><a class="code" href="group__timerpwm.html#ga6">00365</a> <span class="keywordtype">void</span> <a class="code" href="group__timerpwm.html#ga6">timer1PWMBOff</a>(<span class="keywordtype">void</span>)
00366 {
00367     <span class="comment">// turn off channel B (OC1B) PWM output</span>
00368     <span class="comment">// set OC1B (OutputCompare action) to none</span>
00369     cbi(TCCR1A,COMB1);
00370     cbi(TCCR1A,COMB0);
00371 }
00372 
<a name="l00373"></a><a class="code" href="group__timer128.html#ga29">00373</a> <span class="keywordtype">void</span> <a class="code" href="group__timer128.html#ga29">timer1PWMCOff</a>(<span class="keywordtype">void</span>)
00374 {
00375     <span class="comment">// turn off channel C (OC1C) PWM output</span>
00376     <span class="comment">// set OC1C (OutputCompare action) to none</span>
00377     cbi(TCCR1A,COMC1);
00378     cbi(TCCR1A,COMC0);
00379 }
00380 
<a name="l00381"></a><a class="code" href="group__timerpwm.html#ga7">00381</a> <span class="keywordtype">void</span> <a class="code" href="group__timerpwm.html#ga7">timer1PWMASet</a>(u16 pwmDuty)
00382 {
00383     <span class="comment">// set PWM (output compare) duty for channel A</span>
00384     <span class="comment">// this PWM output is generated on OC1A pin</span>
00385     <span class="comment">// NOTE:    pwmDuty should be in the range 0-255 for 8bit PWM</span>
00386     <span class="comment">//          pwmDuty should be in the range 0-511 for 9bit PWM</span>
00387     <span class="comment">//          pwmDuty should be in the range 0-1023 for 10bit PWM</span>
00388     outb(OCR1AH, (pwmDuty&gt;&gt;8));     <span class="comment">// set the high 8bits of OCR1A</span>
00389     outb(OCR1AL, (pwmDuty&amp;0x00FF)); <span class="comment">// set the low 8bits of OCR1A</span>
00390 }
00391 
<a name="l00392"></a><a class="code" href="group__timerpwm.html#ga8">00392</a> <span class="keywordtype">void</span> <a class="code" href="group__timerpwm.html#ga8">timer1PWMBSet</a>(u16 pwmDuty)
00393 {
00394     <span class="comment">// set PWM (output compare) duty for channel B</span>
00395     <span class="comment">// this PWM output is generated on OC1B pin</span>
00396     <span class="comment">// NOTE:    pwmDuty should be in the range 0-255 for 8bit PWM</span>
00397     <span class="comment">//          pwmDuty should be in the range 0-511 for 9bit PWM</span>
00398     <span class="comment">//          pwmDuty should be in the range 0-1023 for 10bit PWM</span>
00399     outb(OCR1BH, (pwmDuty&gt;&gt;8));     <span class="comment">// set the high 8bits of OCR1B</span>
00400     outb(OCR1BL, (pwmDuty&amp;0x00FF)); <span class="comment">// set the low 8bits of OCR1B</span>
00401 }
00402 
<a name="l00403"></a><a class="code" href="group__timer128.html#ga32">00403</a> <span class="keywordtype">void</span> <a class="code" href="group__timer128.html#ga32">timer1PWMCSet</a>(u16 pwmDuty)
00404 {
00405     <span class="comment">// set PWM (output compare) duty for channel C</span>
00406     <span class="comment">// this PWM output is generated on OC1C pin</span>
00407     <span class="comment">// NOTE:    pwmDuty should be in the range 0-255 for 8bit PWM</span>
00408     <span class="comment">//          pwmDuty should be in the range 0-511 for 9bit PWM</span>
00409     <span class="comment">//          pwmDuty should be in the range 0-1023 for 10bit PWM</span>
00410     outb(OCR1CH, (pwmDuty&gt;&gt;8));     <span class="comment">// set the high 8bits of OCR1C</span>
00411     outb(OCR1CL, (pwmDuty&amp;0x00FF)); <span class="comment">// set the low 8bits of OCR1C</span>
00412 }
00413 
00414 
<a name="l00415"></a><a class="code" href="group__timer128.html#ga33">00415</a> <span class="keywordtype">void</span> <a class="code" href="group__timer128.html#ga33">timer3PWMInit</a>(u08 bitRes)
00416 {
00417     <span class="comment">// configures timer1 for use with PWM output</span>
00418     <span class="comment">// on pins OC3A, OC3B, and OC3C</span>
00419 
00420     <span class="comment">// enable Timer3 as 8,9,10bit PWM</span>
00421     <span class="keywordflow">if</span>(bitRes == 9)
00422     {   <span class="comment">// 9bit mode</span>
00423         sbi(TCCR3A,WGMA1);
00424         cbi(TCCR3A,WGMA0);
00425     }
00426     <span class="keywordflow">else</span> <span class="keywordflow">if</span>( bitRes == 10 )
00427     {   <span class="comment">// 10bit mode</span>
00428         sbi(TCCR3A,WGMA1);
00429         sbi(TCCR3A,WGMA0);
00430     }
00431     <span class="keywordflow">else</span>
00432     {   <span class="comment">// default 8bit mode</span>
00433         cbi(TCCR3A,WGMA1);
00434         sbi(TCCR3A,WGMA0);
00435     }
00436 
00437     <span class="comment">// set clear-timer-on-compare-match</span>
00438     <span class="comment">//cbi(TCCR3B,CTC1);</span>
00439     <span class="comment">// clear output compare value A</span>
00440     outb(OCR3AH, 0);
00441     outb(OCR3AL, 0);
00442     <span class="comment">// clear output compare value B</span>
00443     outb(OCR3BH, 0);
00444     outb(OCR3BL, 0);
00445     <span class="comment">// clear output compare value B</span>
00446     outb(OCR3CH, 0);
00447     outb(OCR3CL, 0);
00448 }
00449 
<a name="l00450"></a><a class="code" href="group__timer128.html#ga34">00450</a> <span class="keywordtype">void</span> <a class="code" href="group__timer128.html#ga34">timer3PWMInitICR</a>(u16 topcount)
00451 {
00452     <span class="comment">// set PWM mode with ICR top-count</span>
00453     cbi(TCCR3A,WGM30);
00454     sbi(TCCR3A,WGM31);
00455     sbi(TCCR3B,WGM32);
00456     sbi(TCCR3B,WGM33);
00457     
00458     <span class="comment">// set top count value</span>
00459     ICR3H = (u08)(topcount&gt;&gt;8);
00460     ICR3L = (u08)topcount;
00461     
00462     <span class="comment">// clear output compare value A</span>
00463     outb(OCR3AH, 0);
00464     outb(OCR3AL, 0);
00465     <span class="comment">// clear output compare value B</span>
00466     outb(OCR3BH, 0);
00467     outb(OCR3BL, 0);
00468     <span class="comment">// clear output compare value C</span>
00469     outb(OCR3CH, 0);
00470     outb(OCR3CL, 0);
00471 }
00472 
<a name="l00473"></a><a class="code" href="group__timer128.html#ga35">00473</a> <span class="keywordtype">void</span> <a class="code" href="group__timer128.html#ga35">timer3PWMOff</a>(<span class="keywordtype">void</span>)
00474 {
00475     <span class="comment">// turn off PWM mode on Timer3</span>
00476     cbi(TCCR3A,WGMA1);
00477     cbi(TCCR3A,WGMA0);
00478     <span class="comment">// clear (disable) clear-timer-on-compare-match</span>
00479     <span class="comment">//cbi(TCCR3B,CTC1);</span>
00480     <span class="comment">// set OC3A/B/C (OutputCompare action) to none</span>
00481     <a class="code" href="group__timer128.html#ga39">timer3PWMAOff</a>();
00482     <a class="code" href="group__timer128.html#ga40">timer3PWMBOff</a>();
00483     <a class="code" href="group__timer128.html#ga41">timer3PWMCOff</a>();
00484 }
00485 
<a name="l00486"></a><a class="code" href="group__timer128.html#ga36">00486</a> <span class="keywordtype">void</span> <a class="code" href="group__timer128.html#ga36">timer3PWMAOn</a>(<span class="keywordtype">void</span>)
00487 {
00488     <span class="comment">// turn on channel A (OC3A) PWM output</span>
00489     <span class="comment">// set OC3A as non-inverted PWM</span>
00490     sbi(TCCR3A,COMA1);
00491     cbi(TCCR3A,COMA0);
00492 }
00493 
<a name="l00494"></a><a class="code" href="group__timer128.html#ga37">00494</a> <span class="keywordtype">void</span> <a class="code" href="group__timer128.html#ga37">timer3PWMBOn</a>(<span class="keywordtype">void</span>)
00495 {
00496     <span class="comment">// turn on channel B (OC3B) PWM output</span>
00497     <span class="comment">// set OC3B as non-inverted PWM</span>
00498     sbi(TCCR3A,COMB1);
00499     cbi(TCCR3A,COMB0);
00500 }
00501 
<a name="l00502"></a><a class="code" href="group__timer128.html#ga38">00502</a> <span class="keywordtype">void</span> <a class="code" href="group__timer128.html#ga38">timer3PWMCOn</a>(<span class="keywordtype">void</span>)
00503 {
00504     <span class="comment">// turn on channel C (OC3C) PWM output</span>
00505     <span class="comment">// set OC3C as non-inverted PWM</span>
00506     sbi(TCCR3A,COMC1);
00507     cbi(TCCR3A,COMC0);
00508 }
00509 
<a name="l00510"></a><a class="code" href="group__timer128.html#ga39">00510</a> <span class="keywordtype">void</span> <a class="code" href="group__timer128.html#ga39">timer3PWMAOff</a>(<span class="keywordtype">void</span>)
00511 {
00512     <span class="comment">// turn off channel A (OC3A) PWM output</span>
00513     <span class="comment">// set OC3A (OutputCompare action) to none</span>
00514     cbi(TCCR3A,COMA1);
00515     cbi(TCCR3A,COMA0);
00516 }
00517 
<a name="l00518"></a><a class="code" href="group__timer128.html#ga40">00518</a> <span class="keywordtype">void</span> <a class="code" href="group__timer128.html#ga40">timer3PWMBOff</a>(<span class="keywordtype">void</span>)
00519 {
00520     <span class="comment">// turn off channel B (OC3B) PWM output</span>
00521     <span class="comment">// set OC3B (OutputCompare action) to none</span>
00522     cbi(TCCR3A,COMB1);
00523     cbi(TCCR3A,COMB0);
00524 }
00525 
<a name="l00526"></a><a class="code" href="group__timer128.html#ga41">00526</a> <span class="keywordtype">void</span> <a class="code" href="group__timer128.html#ga41">timer3PWMCOff</a>(<span class="keywordtype">void</span>)
00527 {
00528     <span class="comment">// turn off channel C (OC3C) PWM output</span>
00529     <span class="comment">// set OC3C (OutputCompare action) to none</span>
00530     cbi(TCCR3A,COMC1);
00531     cbi(TCCR3A,COMC0);
00532 }
00533 
<a name="l00534"></a><a class="code" href="group__timer128.html#ga42">00534</a> <span class="keywordtype">void</span> <a class="code" href="group__timer128.html#ga42">timer3PWMASet</a>(u16 pwmDuty)
00535 {
00536     <span class="comment">// set PWM (output compare) duty for channel A</span>
00537     <span class="comment">// this PWM output is generated on OC3A pin</span>
00538     <span class="comment">// NOTE:    pwmDuty should be in the range 0-255 for 8bit PWM</span>
00539     <span class="comment">//          pwmDuty should be in the range 0-511 for 9bit PWM</span>
00540     <span class="comment">//          pwmDuty should be in the range 0-1023 for 10bit PWM</span>
00541     outb(OCR3AH, (pwmDuty&gt;&gt;8));     <span class="comment">// set the high 8bits of OCR3A</span>
00542     outb(OCR3AL, (pwmDuty&amp;0x00FF)); <span class="comment">// set the low 8bits of OCR3A</span>
00543 }
00544 
<a name="l00545"></a><a class="code" href="group__timer128.html#ga43">00545</a> <span class="keywordtype">void</span> <a class="code" href="group__timer128.html#ga43">timer3PWMBSet</a>(u16 pwmDuty)
00546 {
00547     <span class="comment">// set PWM (output compare) duty for channel B</span>
00548     <span class="comment">// this PWM output is generated on OC3B pin</span>
00549     <span class="comment">// NOTE:    pwmDuty should be in the range 0-255 for 8bit PWM</span>
00550     <span class="comment">//          pwmDuty should be in the range 0-511 for 9bit PWM</span>
00551     <span class="comment">//          pwmDuty should be in the range 0-1023 for 10bit PWM</span>
00552     outb(OCR3BH, (pwmDuty&gt;&gt;8));     <span class="comment">// set the high 8bits of OCR3B</span>
00553     outb(OCR3BL, (pwmDuty&amp;0x00FF)); <span class="comment">// set the low 8bits of OCR3B</span>
00554 }
00555 
<a name="l00556"></a><a class="code" href="group__timer128.html#ga44">00556</a> <span class="keywordtype">void</span> <a class="code" href="group__timer128.html#ga44">timer3PWMCSet</a>(u16 pwmDuty)
00557 {
00558     <span class="comment">// set PWM (output compare) duty for channel B</span>
00559     <span class="comment">// this PWM output is generated on OC3C pin</span>
00560     <span class="comment">// NOTE:    pwmDuty should be in the range 0-255 for 8bit PWM</span>
00561     <span class="comment">//          pwmDuty should be in the range 0-511 for 9bit PWM</span>
00562     <span class="comment">//          pwmDuty should be in the range 0-1023 for 10bit PWM</span>
00563     outb(OCR3CH, (pwmDuty&gt;&gt;8));     <span class="comment">// set the high 8bits of OCR3C</span>
00564     outb(OCR3CL, (pwmDuty&amp;0x00FF)); <span class="comment">// set the low 8bits of OCR3C</span>
00565 }
00566 
00567 <span class="comment"></span>
00568 <span class="comment">//! Interrupt handler for tcnt0 overflow interrupt</span>
<a name="l00569"></a><a class="code" href="timer128_8c.html#a53">00569</a> <span class="comment"></span>TIMER_INTERRUPT_HANDLER(SIG_OVERFLOW0)
00570 {
00571     Timer0Reg0++;       <span class="comment">// increment low-order counter</span>
00572     <span class="keywordflow">if</span>(!Timer0Reg0)     <span class="comment">// if low-order counter rollover</span>
00573         Timer0Reg1++;   <span class="comment">// increment high-order counter </span>
00574 
00575     <span class="comment">// if a user function is defined, execute it too</span>
00576     <span class="keywordflow">if</span>(TimerIntFunc[TIMER0OVERFLOW_INT])
00577         TimerIntFunc[TIMER0OVERFLOW_INT]();
00578 }
00579 <span class="comment"></span>
00580 <span class="comment">//! Interrupt handler for Timer1 overflow interrupt</span>
<a name="l00581"></a><a class="code" href="timer128_8c.html#a54">00581</a> <span class="comment"></span>TIMER_INTERRUPT_HANDLER(SIG_OVERFLOW1)
00582 {
00583     <span class="comment">// if a user function is defined, execute it</span>
00584     <span class="keywordflow">if</span>(TimerIntFunc[TIMER1OVERFLOW_INT])
00585         TimerIntFunc[TIMER1OVERFLOW_INT]();
00586 }
00587 <span class="comment"></span>
00588 <span class="comment">//! Interrupt handler for Timer2 overflow interrupt</span>
<a name="l00589"></a><a class="code" href="timer128_8c.html#a55">00589</a> <span class="comment"></span>TIMER_INTERRUPT_HANDLER(SIG_OVERFLOW2)
00590 {
00591     Timer2Reg0++;       <span class="comment">// increment low-order counter</span>
00592     <span class="keywordflow">if</span>(!Timer2Reg0)     <span class="comment">// if low-order counter rollover</span>
00593         Timer2Reg1++;   <span class="comment">// increment high-order counter </span>
00594 
00595     <span class="comment">// increment pause counter</span>
00596     TimerPauseReg++;
00597 
00598     <span class="comment">// if a user function is defined, execute it</span>
00599     <span class="keywordflow">if</span>(TimerIntFunc[TIMER2OVERFLOW_INT])
00600         TimerIntFunc[TIMER2OVERFLOW_INT]();
00601 }
00602 <span class="comment"></span>
00603 <span class="comment">//! Interrupt handler for Timer3 overflow interrupt</span>
<a name="l00604"></a><a class="code" href="timer128_8c.html#a56">00604</a> <span class="comment"></span>TIMER_INTERRUPT_HANDLER(SIG_OVERFLOW3)
00605 {
00606     <span class="comment">// if a user function is defined, execute it</span>
00607     <span class="keywordflow">if</span>(TimerIntFunc[TIMER3OVERFLOW_INT])
00608         TimerIntFunc[TIMER3OVERFLOW_INT]();
00609 }
00610 <span class="comment"></span>
00611 <span class="comment">//! Interrupt handler for OutputCompare0 match (OC0) interrupt</span>
<a name="l00612"></a><a class="code" href="timer128_8c.html#a57">00612</a> <span class="comment"></span>TIMER_INTERRUPT_HANDLER(SIG_OUTPUT_COMPARE0)
00613 {
00614     <span class="comment">// if a user function is defined, execute it</span>
00615     <span class="keywordflow">if</span>(TimerIntFunc[TIMER0OUTCOMPARE_INT])
00616         TimerIntFunc[TIMER0OUTCOMPARE_INT]();
00617 }
00618 <span class="comment"></span>
00619 <span class="comment">//! Interrupt handler for OutputCompare1A match (OC1A) interrupt</span>
<a name="l00620"></a><a class="code" href="timer128_8c.html#a58">00620</a> <span class="comment"></span>TIMER_INTERRUPT_HANDLER(SIG_OUTPUT_COMPARE1A)
00621 {
00622     <span class="comment">// if a user function is defined, execute it</span>
00623     <span class="keywordflow">if</span>(TimerIntFunc[TIMER1OUTCOMPAREA_INT])
00624         TimerIntFunc[TIMER1OUTCOMPAREA_INT]();
00625 }
00626 <span class="comment"></span>
00627 <span class="comment">//! Interrupt handler for OutputCompare1B match (OC1B) interrupt</span>
<a name="l00628"></a><a class="code" href="timer128_8c.html#a59">00628</a> <span class="comment"></span>TIMER_INTERRUPT_HANDLER(SIG_OUTPUT_COMPARE1B)
00629 {
00630     <span class="comment">// if a user function is defined, execute it</span>
00631     <span class="keywordflow">if</span>(TimerIntFunc[TIMER1OUTCOMPAREB_INT])
00632         TimerIntFunc[TIMER1OUTCOMPAREB_INT]();
00633 }
00634 <span class="comment"></span>
00635 <span class="comment">//! Interrupt handler for OutputCompare1C match (OC1C) interrupt</span>
<a name="l00636"></a><a class="code" href="timer128_8c.html#a60">00636</a> <span class="comment"></span>TIMER_INTERRUPT_HANDLER(SIG_OUTPUT_COMPARE1C)
00637 {
00638     <span class="comment">// if a user function is defined, execute it</span>
00639     <span class="keywordflow">if</span>(TimerIntFunc[TIMER1OUTCOMPAREC_INT])
00640         TimerIntFunc[TIMER1OUTCOMPAREC_INT]();
00641 }
00642 <span class="comment"></span>
00643 <span class="comment">//! Interrupt handler for InputCapture1(IC1) interrupt</span>
<a name="l00644"></a><a class="code" href="timer128_8c.html#a61">00644</a> <span class="comment"></span>TIMER_INTERRUPT_HANDLER(SIG_INPUT_CAPTURE1)
00645 {
00646     <span class="comment">// if a user function is defined, execute it</span>
00647     <span class="keywordflow">if</span>(TimerIntFunc[TIMER1INPUTCAPTURE_INT])
00648         TimerIntFunc[TIMER1INPUTCAPTURE_INT]();
00649 }
00650 <span class="comment"></span>
00651 <span class="comment">//! Interrupt handler for OutputCompare2 match (OC2) interrupt</span>
<a name="l00652"></a><a class="code" href="timer128_8c.html#a62">00652</a> <span class="comment"></span>TIMER_INTERRUPT_HANDLER(SIG_OUTPUT_COMPARE2)
00653 {
00654     <span class="comment">// if a user function is defined, execute it</span>
00655     <span class="keywordflow">if</span>(TimerIntFunc[TIMER2OUTCOMPARE_INT])
00656         TimerIntFunc[TIMER2OUTCOMPARE_INT]();
00657 }
00658 <span class="comment"></span>
00659 <span class="comment">//! Interrupt handler for OutputCompare3A match (OC3A) interrupt</span>
<a name="l00660"></a><a class="code" href="timer128_8c.html#a63">00660</a> <span class="comment"></span>TIMER_INTERRUPT_HANDLER(SIG_OUTPUT_COMPARE3A)
00661 {
00662     <span class="comment">// if a user function is defined, execute it</span>
00663     <span class="keywordflow">if</span>(TimerIntFunc[TIMER3OUTCOMPAREA_INT])
00664         TimerIntFunc[TIMER3OUTCOMPAREA_INT]();
00665 }
00666 <span class="comment"></span>
00667 <span class="comment">//! Interrupt handler for OutputCompare3B match (OC3B) interrupt</span>
<a name="l00668"></a><a class="code" href="timer128_8c.html#a64">00668</a> <span class="comment"></span>TIMER_INTERRUPT_HANDLER(SIG_OUTPUT_COMPARE3B)
00669 {
00670     <span class="comment">// if a user function is defined, execute it</span>
00671     <span class="keywordflow">if</span>(TimerIntFunc[TIMER3OUTCOMPAREB_INT])
00672         TimerIntFunc[TIMER3OUTCOMPAREB_INT]();
00673 }
00674 <span class="comment"></span>
00675 <span class="comment">//! Interrupt handler for OutputCompare3C match (OC3C) interrupt</span>
<a name="l00676"></a><a class="code" href="timer128_8c.html#a65">00676</a> <span class="comment"></span>TIMER_INTERRUPT_HANDLER(SIG_OUTPUT_COMPARE3C)
00677 {
00678     <span class="comment">// if a user function is defined, execute it</span>
00679     <span class="keywordflow">if</span>(TimerIntFunc[TIMER3OUTCOMPAREC_INT])
00680         TimerIntFunc[TIMER3OUTCOMPAREC_INT]();
00681 }
00682 <span class="comment"></span>
00683 <span class="comment">//! Interrupt handler for InputCapture3 (IC3) interrupt</span>
<a name="l00684"></a><a class="code" href="timer128_8c.html#a66">00684</a> <span class="comment"></span>TIMER_INTERRUPT_HANDLER(SIG_INPUT_CAPTURE3)
00685 {
00686     <span class="comment">// if a user function is defined, execute it</span>
00687     <span class="keywordflow">if</span>(TimerIntFunc[TIMER3INPUTCAPTURE_INT])
00688         TimerIntFunc[TIMER3INPUTCAPTURE_INT]();
00689 }
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Sun Oct 29 03:41:07 2006 for Procyon AVRlib by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.2 </small></address>
</body>
</html>
