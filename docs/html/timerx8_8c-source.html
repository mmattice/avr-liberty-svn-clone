<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Procyon AVRlib: timerx8.c Source File</title>
<link href="dox.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.2 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>timerx8.c</h1><a href="timerx8_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*! \file timerx8.c \brief Timer function library for ATmegaXX8 Processors. */</span>
00002 <span class="comment">//*****************************************************************************</span>
00003 <span class="comment">//</span>
00004 <span class="comment">// File Name    : 'timerx8.c'</span>
00005 <span class="comment">// Title        : Timer function library for ATmegaXX8 Processors</span>
00006 <span class="comment">// Author       : Pascal Stang - Copyright (C) 2000-2005</span>
00007 <span class="comment">// Created      : 11/22/2000</span>
00008 <span class="comment">// Revised      : 06/15/2005</span>
00009 <span class="comment">// Version      : 1.0</span>
00010 <span class="comment">// Target MCU   : Atmel AVR Series</span>
00011 <span class="comment">// Editor Tabs  : 4</span>
00012 <span class="comment">//</span>
00013 <span class="comment">// This code is distributed under the GNU Public License</span>
00014 <span class="comment">//      which can be found at http://www.gnu.org/licenses/gpl.txt</span>
00015 <span class="comment">//</span>
00016 <span class="comment">//*****************************************************************************</span>
00017 
00018 <span class="preprocessor">#include &lt;avr/io.h&gt;</span>
00019 <span class="preprocessor">#include &lt;avr/interrupt.h&gt;</span>
00020 <span class="preprocessor">#include &lt;avr/pgmspace.h&gt;</span>
00021 <span class="preprocessor">#include &lt;avr/sleep.h&gt;</span>
00022 
00023 <span class="preprocessor">#include "<a class="code" href="global_8h.html">global.h</a>"</span>
00024 <span class="preprocessor">#include "<a class="code" href="timerx8_8h.html">timerx8.h</a>"</span>
00025 
00026 <span class="comment">// Program ROM constants</span>
00027 <span class="comment">// the prescale division values stored in order of timer control register index</span>
00028 <span class="comment">// STOP, CLK, CLK/8, CLK/64, CLK/256, CLK/1024</span>
00029 <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> __attribute__ ((progmem)) TimerPrescaleFactor[] = {0,1,8,64,256,1024};
00030 <span class="comment">// the prescale division values stored in order of timer control register index</span>
00031 <span class="comment">// STOP, CLK, CLK/8, CLK/32, CLK/64, CLK/128, CLK/256, CLK/1024</span>
00032 <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> __attribute__ ((progmem)) TimerRTCPrescaleFactor[] = {0,1,8,32,64,128,256,1024};
00033 
00034 <span class="comment">// Global variables</span>
00035 <span class="comment">// time registers</span>
00036 <span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> TimerPauseReg;
00037 <span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> Timer0Reg0;
00038 <span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> Timer2Reg0;
00039 
00040 <span class="keyword">typedef</span> void (*voidFuncPtr)(void);
00041 <span class="keyword">volatile</span> <span class="keyword">static</span> voidFuncPtr TimerIntFunc[TIMER_NUM_INTERRUPTS];
00042 
00043 <span class="comment">// delay for a minimum of &lt;us&gt; microseconds </span>
00044 <span class="comment">// the time resolution is dependent on the time the loop takes </span>
00045 <span class="comment">// e.g. with 4Mhz and 5 cycles per loop, the resolution is 1.25 us </span>
00046 <span class="keywordtype">void</span> delay_us(<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> time_us) 
00047 {
00048     <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> delay_loops;
00049     <span class="keyword">register</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> i;
00050 
00051     delay_loops = (time_us+3)/5*CYCLES_PER_US; <span class="comment">// +3 for rounding up (dirty) </span>
00052 
00053     <span class="comment">// one loop takes 5 cpu cycles </span>
00054     <span class="keywordflow">for</span> (i=0; i &lt; delay_loops; i++) {};
00055 }
00056 <span class="comment">/*</span>
00057 <span class="comment">void delay_ms(unsigned char time_ms)</span>
00058 <span class="comment">{</span>
00059 <span class="comment">    unsigned short delay_count = F_CPU / 4000;</span>
00060 <span class="comment"></span>
00061 <span class="comment">    unsigned short cnt;</span>
00062 <span class="comment">    asm volatile ("\n"</span>
00063 <span class="comment">                  "L_dl1%=:\n\t"</span>
00064 <span class="comment">                  "mov %A0, %A2\n\t"</span>
00065 <span class="comment">                  "mov %B0, %B2\n"</span>
00066 <span class="comment">                  "L_dl2%=:\n\t"</span>
00067 <span class="comment">                  "sbiw %A0, 1\n\t"</span>
00068 <span class="comment">                  "brne L_dl2%=\n\t"</span>
00069 <span class="comment">                  "dec %1\n\t" "brne L_dl1%=\n\t":"=&amp;w" (cnt)</span>
00070 <span class="comment">                  :"r"(time_ms), "r"((unsigned short) (delay_count))</span>
00071 <span class="comment">    );</span>
00072 <span class="comment">}</span>
00073 <span class="comment">*/</span>
<a name="l00074"></a><a class="code" href="group__timer.html#ga1">00074</a> <span class="keywordtype">void</span> <a class="code" href="group__timer.html#ga1">timerInit</a>(<span class="keywordtype">void</span>)
00075 {
00076     u08 intNum;
00077     <span class="comment">// detach all user functions from interrupts</span>
00078     <span class="keywordflow">for</span>(intNum=0; intNum&lt;TIMER_NUM_INTERRUPTS; intNum++)
00079         <a class="code" href="group__timer.html#ga9">timerDetach</a>(intNum);
00080 
00081     <span class="comment">// initialize all timers</span>
00082     <a class="code" href="group__timer.html#ga2">timer0Init</a>();
00083     <a class="code" href="group__timer.html#ga3">timer1Init</a>();
00084 <span class="preprocessor">    #ifdef TCNT2    // support timer2 only if it exists</span>
00085 <span class="preprocessor"></span>    timer2Init();
00086 <span class="preprocessor">    #endif</span>
00087 <span class="preprocessor"></span>    <span class="comment">// enable interrupts</span>
00088     sei();
00089 }
00090 
<a name="l00091"></a><a class="code" href="group__timer.html#ga2">00091</a> <span class="keywordtype">void</span> <a class="code" href="group__timer.html#ga2">timer0Init</a>()
00092 {
00093     <span class="comment">// initialize timer 0</span>
00094     <a class="code" href="group__timer.html#ga4">timer0SetPrescaler</a>( <a class="code" href="group__timer.html#ga33">TIMER0PRESCALE</a> );   <span class="comment">// set prescaler</span>
00095     TCNT0 = 0;                              <span class="comment">// reset TCNT0</span>
00096     sbi(TIMSK0, TOIE0);                     <span class="comment">// enable TCNT0 overflow interrupt</span>
00097 
00098     <a class="code" href="group__timer.html#ga11">timer0ClearOverflowCount</a>();             <span class="comment">// initialize time registers</span>
00099 }
00100 
<a name="l00101"></a><a class="code" href="group__timer.html#ga3">00101</a> <span class="keywordtype">void</span> <a class="code" href="group__timer.html#ga3">timer1Init</a>(<span class="keywordtype">void</span>)
00102 {
00103     <span class="comment">// initialize timer 1</span>
00104     <a class="code" href="group__timer.html#ga6">timer1SetPrescaler</a>( <a class="code" href="group__timer.html#ga34">TIMER1PRESCALE</a> );   <span class="comment">// set prescaler</span>
00105     TCNT1 = 0;                              <span class="comment">// reset TCNT1</span>
00106     sbi(TIMSK1, TOIE1);                     <span class="comment">// enable TCNT1 overflow</span>
00107 }
00108 
00109 <span class="preprocessor">#ifdef TCNT2    // support timer2 only if it exists</span>
00110 <span class="preprocessor"></span><span class="keywordtype">void</span> timer2Init(<span class="keywordtype">void</span>)
00111 {
00112     <span class="comment">// initialize timer 2</span>
00113     <a class="code" href="group__timer128.html#ga8">timer2SetPrescaler</a>( <a class="code" href="group__timer.html#ga35">TIMER2PRESCALE</a> );   <span class="comment">// set prescaler</span>
00114     TCNT2 = 0;                              <span class="comment">// reset TCNT2</span>
00115     sbi(TIMSK2, TOIE2);                     <span class="comment">// enable TCNT2 overflow</span>
00116 
00117     timer2ClearOverflowCount();             <span class="comment">// initialize time registers</span>
00118 }
00119 <span class="preprocessor">#endif</span>
00120 <span class="preprocessor"></span>
<a name="l00121"></a><a class="code" href="group__timer.html#ga4">00121</a> <span class="keywordtype">void</span> <a class="code" href="group__timer.html#ga4">timer0SetPrescaler</a>(u08 prescale)
00122 {
00123     <span class="comment">// set prescaler on timer 0</span>
00124     TCCR0B = ((TCCR0B &amp; ~<a class="code" href="group__timer.html#ga23">TIMER_PRESCALE_MASK</a>) | prescale);
00125 }
00126 
<a name="l00127"></a><a class="code" href="group__timer.html#ga6">00127</a> <span class="keywordtype">void</span> <a class="code" href="group__timer.html#ga6">timer1SetPrescaler</a>(u08 prescale)
00128 {
00129     <span class="comment">// set prescaler on timer 1</span>
00130     TCCR1B = ((TCCR1B &amp; ~<a class="code" href="group__timer.html#ga23">TIMER_PRESCALE_MASK</a>) | prescale);
00131 }
00132 
00133 <span class="preprocessor">#ifdef TCNT2    // support timer2 only if it exists</span>
00134 <span class="preprocessor"></span><span class="keywordtype">void</span> <a class="code" href="group__timer128.html#ga8">timer2SetPrescaler</a>(u08 prescale)
00135 {
00136     <span class="comment">// set prescaler on timer 2</span>
00137     TCCR2B = ((TCCR2B &amp; ~<a class="code" href="group__timer.html#ga23">TIMER_PRESCALE_MASK</a>) | prescale);
00138 }
00139 <span class="preprocessor">#endif</span>
00140 <span class="preprocessor"></span>
<a name="l00141"></a><a class="code" href="group__timer.html#ga5">00141</a> u16 <a class="code" href="group__timer.html#ga5">timer0GetPrescaler</a>(<span class="keywordtype">void</span>)
00142 {
00143     <span class="comment">// get the current prescaler setting</span>
00144     <span class="keywordflow">return</span> (pgm_read_word(TimerPrescaleFactor+(TCCR0B &amp; <a class="code" href="group__timer.html#ga23">TIMER_PRESCALE_MASK</a>)));
00145 }
00146 
<a name="l00147"></a><a class="code" href="group__timer.html#ga7">00147</a> u16 <a class="code" href="group__timer.html#ga7">timer1GetPrescaler</a>(<span class="keywordtype">void</span>)
00148 {
00149     <span class="comment">// get the current prescaler setting</span>
00150     <span class="keywordflow">return</span> (pgm_read_word(TimerPrescaleFactor+(TCCR1B &amp; <a class="code" href="group__timer.html#ga23">TIMER_PRESCALE_MASK</a>)));
00151 }
00152 
00153 <span class="preprocessor">#ifdef TCNT2    // support timer2 only if it exists</span>
00154 <span class="preprocessor"></span>u16 <a class="code" href="group__timer128.html#ga12">timer2GetPrescaler</a>(<span class="keywordtype">void</span>)
00155 {
00156     <span class="comment">//TODO: can we assume for all 3-timer AVR processors,</span>
00157     <span class="comment">// that timer2 is the RTC timer?</span>
00158 
00159     <span class="comment">// get the current prescaler setting</span>
00160     <span class="keywordflow">return</span> (pgm_read_word(TimerRTCPrescaleFactor+(TCCR2B &amp; <a class="code" href="group__timer.html#ga23">TIMER_PRESCALE_MASK</a>)));
00161 }
00162 <span class="preprocessor">#endif</span>
00163 <span class="preprocessor"></span>
<a name="l00164"></a><a class="code" href="group__timer.html#ga8">00164</a> <span class="keywordtype">void</span> <a class="code" href="group__timer.html#ga8">timerAttach</a>(u08 interruptNum, <span class="keywordtype">void</span> (*userFunc)(<span class="keywordtype">void</span>) )
00165 {
00166     <span class="comment">// make sure the interrupt number is within bounds</span>
00167     <span class="keywordflow">if</span>(interruptNum &lt; TIMER_NUM_INTERRUPTS)
00168     {
00169         <span class="comment">// set the interrupt function to run</span>
00170         <span class="comment">// the supplied user's function</span>
00171         TimerIntFunc[interruptNum] = userFunc;
00172     }
00173 }
00174 
<a name="l00175"></a><a class="code" href="group__timer.html#ga9">00175</a> <span class="keywordtype">void</span> <a class="code" href="group__timer.html#ga9">timerDetach</a>(u08 interruptNum)
00176 {
00177     <span class="comment">// make sure the interrupt number is within bounds</span>
00178     <span class="keywordflow">if</span>(interruptNum &lt; TIMER_NUM_INTERRUPTS)
00179     {
00180         <span class="comment">// set the interrupt function to run nothing</span>
00181         TimerIntFunc[interruptNum] = 0;
00182     }
00183 }
00184 <span class="comment">/*</span>
00185 <span class="comment">u32 timerMsToTics(u16 ms)</span>
00186 <span class="comment">{</span>
00187 <span class="comment">    // calculate the prescaler division rate</span>
00188 <span class="comment">    u16 prescaleDiv = 1&lt;&lt;(pgm_read_byte(TimerPrescaleFactor+inb(TCCR0)));</span>
00189 <span class="comment">    // calculate the number of timer tics in x milliseconds</span>
00190 <span class="comment">    return (ms*(F_CPU/(prescaleDiv*256)))/1000;</span>
00191 <span class="comment">}</span>
00192 <span class="comment"></span>
00193 <span class="comment">u16 timerTicsToMs(u32 tics)</span>
00194 <span class="comment">{</span>
00195 <span class="comment">    // calculate the prescaler division rate</span>
00196 <span class="comment">    u16 prescaleDiv = 1&lt;&lt;(pgm_read_byte(TimerPrescaleFactor+inb(TCCR0)));</span>
00197 <span class="comment">    // calculate the number of milliseconds in x timer tics</span>
00198 <span class="comment">    return (tics*1000*(prescaleDiv*256))/F_CPU;</span>
00199 <span class="comment">}</span>
00200 <span class="comment">*/</span>
<a name="l00201"></a><a class="code" href="group__timer.html#ga10">00201</a> <span class="keywordtype">void</span> <a class="code" href="group__timer.html#ga10">timerPause</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> pause_ms)
00202 {
00203     <span class="comment">// pauses for exactly &lt;pause_ms&gt; number of milliseconds</span>
00204     u08 timerThres;
00205     u32 ticRateHz;
00206     u32 pause;
00207 
00208     <span class="comment">// capture current pause timer value</span>
00209     timerThres = TCNT0;
00210     <span class="comment">// reset pause timer overflow count</span>
00211     TimerPauseReg = 0;
00212     <span class="comment">// calculate delay for [pause_ms] milliseconds</span>
00213     <span class="comment">// prescaler division = 1&lt;&lt;(pgm_read_byte(TimerPrescaleFactor+inb(TCCR0)))</span>
00214     ticRateHz = F_CPU/<a class="code" href="group__timer.html#ga5">timer0GetPrescaler</a>();
00215     <span class="comment">// precision management</span>
00216     <span class="comment">// prevent overflow and precision underflow</span>
00217     <span class="comment">//  -could add more conditions to improve accuracy</span>
00218     <span class="keywordflow">if</span>( ((ticRateHz &lt; 429497) &amp;&amp; (pause_ms &lt;= 10000)) )
00219         pause = (pause_ms*ticRateHz)/1000;
00220     <span class="keywordflow">else</span>
00221         pause = pause_ms*(ticRateHz/1000);
00222 
00223     <span class="comment">// loop until time expires</span>
00224     <span class="keywordflow">while</span>( ((TimerPauseReg&lt;&lt;8) | (TCNT0)) &lt; (pause+timerThres) )
00225     {
00226         <span class="keywordflow">if</span>( TimerPauseReg &lt; (pause&gt;&gt;8));
00227         {
00228             <span class="comment">// save power by idling the processor</span>
00229             set_sleep_mode(SLEEP_MODE_IDLE);
00230             sleep_mode();
00231         }
00232     }
00233 
00234     <span class="comment">/* old inaccurate code, for reference</span>
00235 <span class="comment">    </span>
00236 <span class="comment">    // calculate delay for [pause_ms] milliseconds</span>
00237 <span class="comment">    u16 prescaleDiv = 1&lt;&lt;(pgm_read_byte(TimerPrescaleFactor+inb(TCCR0)));</span>
00238 <span class="comment">    u32 pause = (pause_ms*(F_CPU/(prescaleDiv*256)))/1000;</span>
00239 <span class="comment">    </span>
00240 <span class="comment">    TimerPauseReg = 0;</span>
00241 <span class="comment">    while(TimerPauseReg &lt; pause);</span>
00242 <span class="comment"></span>
00243 <span class="comment">    */</span>
00244 }
00245 
<a name="l00246"></a><a class="code" href="group__timer.html#ga11">00246</a> <span class="keywordtype">void</span> <a class="code" href="group__timer.html#ga11">timer0ClearOverflowCount</a>(<span class="keywordtype">void</span>)
00247 {
00248     <span class="comment">// clear the timer overflow counter registers</span>
00249     Timer0Reg0 = 0; <span class="comment">// initialize time registers</span>
00250 }
00251 
<a name="l00252"></a><a class="code" href="group__timer.html#ga12">00252</a> <span class="keywordtype">long</span> <a class="code" href="group__timer.html#ga12">timer0GetOverflowCount</a>(<span class="keywordtype">void</span>)
00253 {
00254     <span class="comment">// return the current timer overflow count</span>
00255     <span class="comment">// (this is since the last timer0ClearOverflowCount() command was called)</span>
00256     <span class="keywordflow">return</span> Timer0Reg0;
00257 }
00258 
00259 <span class="preprocessor">#ifdef TCNT2    // support timer2 only if it exists</span>
00260 <span class="preprocessor"></span><span class="keywordtype">void</span> timer2ClearOverflowCount(<span class="keywordtype">void</span>)
00261 {
00262     <span class="comment">// clear the timer overflow counter registers</span>
00263     Timer2Reg0 = 0; <span class="comment">// initialize time registers</span>
00264 }
00265 
00266 <span class="keywordtype">long</span> timer2GetOverflowCount(<span class="keywordtype">void</span>)
00267 {
00268     <span class="comment">// return the current timer overflow count</span>
00269     <span class="comment">// (this is since the last timer2ClearOverflowCount() command was called)</span>
00270     <span class="keywordflow">return</span> Timer2Reg0;
00271 }
00272 <span class="preprocessor">#endif</span>
00273 <span class="preprocessor"></span>
<a name="l00274"></a><a class="code" href="group__timerpwm.html#ga0">00274</a> <span class="keywordtype">void</span> <a class="code" href="group__timerpwm.html#ga0">timer1PWMInit</a>(u08 bitRes)
00275 {
00276     <span class="comment">// configures timer1 for use with PWM output</span>
00277     <span class="comment">// on OC1A and OC1B pins</span>
00278 
00279     <span class="comment">// enable timer1 as 8,9,10bit PWM</span>
00280     <span class="keywordflow">if</span>(bitRes == 9)
00281     {   <span class="comment">// 9bit mode</span>
00282         sbi(TCCR1A,PWM11);
00283         cbi(TCCR1A,PWM10);
00284     }
00285     <span class="keywordflow">else</span> <span class="keywordflow">if</span>( bitRes == 10 )
00286     {   <span class="comment">// 10bit mode</span>
00287         sbi(TCCR1A,PWM11);
00288         sbi(TCCR1A,PWM10);
00289     }
00290     <span class="keywordflow">else</span>
00291     {   <span class="comment">// default 8bit mode</span>
00292         cbi(TCCR1A,PWM11);
00293         sbi(TCCR1A,PWM10);
00294     }
00295 
00296     <span class="comment">// clear output compare value A</span>
00297     OCR1A = 0;
00298     <span class="comment">// clear output compare value B</span>
00299     OCR1B = 0;
00300 }
00301 
00302 <span class="preprocessor">#ifdef WGM10</span>
00303 <span class="preprocessor"></span><span class="comment">// include support for arbitrary top-count PWM</span>
00304 <span class="comment">// on new AVR processors that support it</span>
00305 <span class="keywordtype">void</span> <a class="code" href="group__timerpwm.html#ga1">timer1PWMInitICR</a>(u16 topcount)
00306 {
00307     <span class="comment">// set PWM mode with ICR top-count</span>
00308     cbi(TCCR1A,WGM10);
00309     sbi(TCCR1A,WGM11);
00310     sbi(TCCR1B,WGM12);
00311     sbi(TCCR1B,WGM13);
00312     
00313     <span class="comment">// set top count value</span>
00314     ICR1 = topcount;
00315     
00316     <span class="comment">// clear output compare value A</span>
00317     OCR1A = 0;
00318     <span class="comment">// clear output compare value B</span>
00319     OCR1B = 0;
00320 
00321 }
00322 <span class="preprocessor">#endif</span>
00323 <span class="preprocessor"></span>
<a name="l00324"></a><a class="code" href="group__timerpwm.html#ga2">00324</a> <span class="keywordtype">void</span> <a class="code" href="group__timerpwm.html#ga2">timer1PWMOff</a>(<span class="keywordtype">void</span>)
00325 {
00326     <span class="comment">// turn off timer1 PWM mode</span>
00327     cbi(TCCR1A,PWM11);
00328     cbi(TCCR1A,PWM10);
00329     <span class="comment">// set PWM1A/B (OutputCompare action) to none</span>
00330     <a class="code" href="group__timerpwm.html#ga5">timer1PWMAOff</a>();
00331     <a class="code" href="group__timerpwm.html#ga6">timer1PWMBOff</a>();
00332 }
00333 
<a name="l00334"></a><a class="code" href="group__timerpwm.html#ga3">00334</a> <span class="keywordtype">void</span> <a class="code" href="group__timerpwm.html#ga3">timer1PWMAOn</a>(<span class="keywordtype">void</span>)
00335 {
00336     <span class="comment">// turn on channel A (OC1A) PWM output</span>
00337     <span class="comment">// set OC1A as non-inverted PWM</span>
00338     sbi(TCCR1A,COM1A1);
00339     cbi(TCCR1A,COM1A0);
00340 }
00341 
<a name="l00342"></a><a class="code" href="group__timerpwm.html#ga4">00342</a> <span class="keywordtype">void</span> <a class="code" href="group__timerpwm.html#ga4">timer1PWMBOn</a>(<span class="keywordtype">void</span>)
00343 {
00344     <span class="comment">// turn on channel B (OC1B) PWM output</span>
00345     <span class="comment">// set OC1B as non-inverted PWM</span>
00346     sbi(TCCR1A,COM1B1);
00347     cbi(TCCR1A,COM1B0);
00348 }
00349 
<a name="l00350"></a><a class="code" href="group__timerpwm.html#ga5">00350</a> <span class="keywordtype">void</span> <a class="code" href="group__timerpwm.html#ga5">timer1PWMAOff</a>(<span class="keywordtype">void</span>)
00351 {
00352     <span class="comment">// turn off channel A (OC1A) PWM output</span>
00353     <span class="comment">// set OC1A (OutputCompare action) to none</span>
00354     cbi(TCCR1A,COM1A1);
00355     cbi(TCCR1A,COM1A0);
00356 }
00357 
<a name="l00358"></a><a class="code" href="group__timerpwm.html#ga6">00358</a> <span class="keywordtype">void</span> <a class="code" href="group__timerpwm.html#ga6">timer1PWMBOff</a>(<span class="keywordtype">void</span>)
00359 {
00360     <span class="comment">// turn off channel B (OC1B) PWM output</span>
00361     <span class="comment">// set OC1B (OutputCompare action) to none</span>
00362     cbi(TCCR1A,COM1B1);
00363     cbi(TCCR1A,COM1B0);
00364 }
00365 
<a name="l00366"></a><a class="code" href="group__timerpwm.html#ga7">00366</a> <span class="keywordtype">void</span> <a class="code" href="group__timerpwm.html#ga7">timer1PWMASet</a>(u16 pwmDuty)
00367 {
00368     <span class="comment">// set PWM (output compare) duty for channel A</span>
00369     <span class="comment">// this PWM output is generated on OC1A pin</span>
00370     <span class="comment">// NOTE:    pwmDuty should be in the range 0-255 for 8bit PWM</span>
00371     <span class="comment">//          pwmDuty should be in the range 0-511 for 9bit PWM</span>
00372     <span class="comment">//          pwmDuty should be in the range 0-1023 for 10bit PWM</span>
00373     <span class="comment">//outp( (pwmDuty&gt;&gt;8), OCR1AH);      // set the high 8bits of OCR1A</span>
00374     <span class="comment">//outp( (pwmDuty&amp;0x00FF), OCR1AL);  // set the low 8bits of OCR1A</span>
00375     OCR1A = pwmDuty;
00376 }
00377 
<a name="l00378"></a><a class="code" href="group__timerpwm.html#ga8">00378</a> <span class="keywordtype">void</span> <a class="code" href="group__timerpwm.html#ga8">timer1PWMBSet</a>(u16 pwmDuty)
00379 {
00380     <span class="comment">// set PWM (output compare) duty for channel B</span>
00381     <span class="comment">// this PWM output is generated on OC1B pin</span>
00382     <span class="comment">// NOTE:    pwmDuty should be in the range 0-255 for 8bit PWM</span>
00383     <span class="comment">//          pwmDuty should be in the range 0-511 for 9bit PWM</span>
00384     <span class="comment">//          pwmDuty should be in the range 0-1023 for 10bit PWM</span>
00385     <span class="comment">//outp( (pwmDuty&gt;&gt;8), OCR1BH);      // set the high 8bits of OCR1B</span>
00386     <span class="comment">//outp( (pwmDuty&amp;0x00FF), OCR1BL);  // set the low 8bits of OCR1B</span>
00387     OCR1B = pwmDuty;
00388 }
00389 <span class="comment"></span>
00390 <span class="comment">//! Interrupt handler for tcnt0 overflow interrupt</span>
<a name="l00391"></a><a class="code" href="timerx8_8c.html#a27">00391</a> <span class="comment"></span>TIMER_INTERRUPT_HANDLER(SIG_OVERFLOW0)
00392 {
00393     Timer0Reg0++;           <span class="comment">// increment low-order counter</span>
00394 
00395     <span class="comment">// increment pause counter</span>
00396     TimerPauseReg++;
00397 
00398     <span class="comment">// if a user function is defined, execute it too</span>
00399     <span class="keywordflow">if</span>(TimerIntFunc[TIMER0OVERFLOW_INT])
00400         TimerIntFunc[TIMER0OVERFLOW_INT]();
00401 }
00402 <span class="comment"></span>
00403 <span class="comment">//! Interrupt handler for tcnt1 overflow interrupt</span>
<a name="l00404"></a><a class="code" href="timerx8_8c.html#a28">00404</a> <span class="comment"></span>TIMER_INTERRUPT_HANDLER(SIG_OVERFLOW1)
00405 {
00406     <span class="comment">// if a user function is defined, execute it</span>
00407     <span class="keywordflow">if</span>(TimerIntFunc[TIMER1OVERFLOW_INT])
00408         TimerIntFunc[TIMER1OVERFLOW_INT]();
00409 }
00410 
00411 <span class="preprocessor">#ifdef TCNT2    // support timer2 only if it exists</span>
00412 <span class="preprocessor"></span><span class="comment">//! Interrupt handler for tcnt2 overflow interrupt</span>
00413 <span class="comment"></span>TIMER_INTERRUPT_HANDLER(SIG_OVERFLOW2)
00414 {
00415     Timer2Reg0++;           <span class="comment">// increment low-order counter</span>
00416 
00417     <span class="comment">// if a user function is defined, execute it</span>
00418     <span class="keywordflow">if</span>(TimerIntFunc[TIMER2OVERFLOW_INT])
00419         TimerIntFunc[TIMER2OVERFLOW_INT]();
00420 }
00421 <span class="preprocessor">#endif</span>
00422 <span class="preprocessor"></span>
00423 <span class="preprocessor">#ifdef OCR0</span>
00424 <span class="preprocessor"></span><span class="comment">// include support for Output Compare 0 for new AVR processors that support it</span><span class="comment"></span>
00425 <span class="comment">//! Interrupt handler for OutputCompare0 match (OC0) interrupt</span>
00426 <span class="comment"></span>TIMER_INTERRUPT_HANDLER(SIG_OUTPUT_COMPARE0)
00427 {
00428     <span class="comment">// if a user function is defined, execute it</span>
00429     <span class="keywordflow">if</span>(TimerIntFunc[TIMER0OUTCOMPARE_INT])
00430         TimerIntFunc[TIMER0OUTCOMPARE_INT]();
00431 }
00432 <span class="preprocessor">#endif</span>
00433 <span class="preprocessor"></span><span class="comment"></span>
00434 <span class="comment">//! Interrupt handler for CutputCompare1A match (OC1A) interrupt</span>
<a name="l00435"></a><a class="code" href="timerx8_8c.html#a29">00435</a> <span class="comment"></span>TIMER_INTERRUPT_HANDLER(SIG_OUTPUT_COMPARE1A)
00436 {
00437     <span class="comment">// if a user function is defined, execute it</span>
00438     <span class="keywordflow">if</span>(TimerIntFunc[TIMER1OUTCOMPAREA_INT])
00439         TimerIntFunc[TIMER1OUTCOMPAREA_INT]();
00440 }
00441 <span class="comment"></span>
00442 <span class="comment">//! Interrupt handler for OutputCompare1B match (OC1B) interrupt</span>
<a name="l00443"></a><a class="code" href="timerx8_8c.html#a30">00443</a> <span class="comment"></span>TIMER_INTERRUPT_HANDLER(SIG_OUTPUT_COMPARE1B)
00444 {
00445     <span class="comment">// if a user function is defined, execute it</span>
00446     <span class="keywordflow">if</span>(TimerIntFunc[TIMER1OUTCOMPAREB_INT])
00447         TimerIntFunc[TIMER1OUTCOMPAREB_INT]();
00448 }
00449 <span class="comment"></span>
00450 <span class="comment">//! Interrupt handler for InputCapture1 (IC1) interrupt</span>
<a name="l00451"></a><a class="code" href="timerx8_8c.html#a31">00451</a> <span class="comment"></span>TIMER_INTERRUPT_HANDLER(SIG_INPUT_CAPTURE1)
00452 {
00453     <span class="comment">// if a user function is defined, execute it</span>
00454     <span class="keywordflow">if</span>(TimerIntFunc[TIMER1INPUTCAPTURE_INT])
00455         TimerIntFunc[TIMER1INPUTCAPTURE_INT]();
00456 }
00457 <span class="comment"></span>
00458 <span class="comment">//! Interrupt handler for OutputCompare2A match (OC2A) interrupt</span>
<a name="l00459"></a><a class="code" href="timerx8_8c.html#a32">00459</a> <span class="comment"></span>TIMER_INTERRUPT_HANDLER(SIG_OUTPUT_COMPARE2A)
00460 {
00461     <span class="comment">// if a user function is defined, execute it</span>
00462     <span class="keywordflow">if</span>(TimerIntFunc[TIMER2OUTCOMPARE_INT])
00463         TimerIntFunc[TIMER2OUTCOMPARE_INT]();
00464 }
00465 <span class="comment"></span>
00466 <span class="comment">//! Interrupt handler for OutputCompare2B match (OC2B) interrupt</span>
<a name="l00467"></a><a class="code" href="timerx8_8c.html#a33">00467</a> <span class="comment"></span>TIMER_INTERRUPT_HANDLER(SIG_OUTPUT_COMPARE2B)
00468 {
00469     <span class="comment">// if a user function is defined, execute it</span>
00470     <span class="keywordflow">if</span>(TimerIntFunc[TIMER2OUTCOMPARE_INT])
00471         TimerIntFunc[TIMER2OUTCOMPARE_INT]();
00472 }
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Sun Oct 29 03:41:07 2006 for Procyon AVRlib by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.2 </small></address>
</body>
</html>
